<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>まだまだだね</title>
  
  <subtitle>飞光飞光，劝你一杯酒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/xxq1999/"/>
  <updated>2021-04-21T08:39:14.910Z</updated>
  <id>http://github.com/xxq1999/</id>
  
  <author>
    <name>xxQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>粒子群优化边缘计算</title>
    <link href="http://github.com/xxq1999/2021/04/22/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E5%8D%B8%E8%BD%BD/"/>
    <id>http://github.com/xxq1999/2021/04/22/粒子群优化边缘计算中的卸载/</id>
    <published>2021-04-22T10:22:00.000Z</published>
    <updated>2021-04-21T08:39:14.910Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>用户设备会将任务分发到移动边缘计算服务器上，但是在offload过程中，由于小基站的高干扰、多址、资源有限，需要一种高效的计算卸载方案。在这篇论文中，作者研究了在小型蜂窝网络下的边缘计算系统的节能计算卸载方案，通过计算卸载决策、频谱、功率和计算资源的联合优化，为的就是减少所有终端设备的能耗。终端设备不仅要决策是否卸载，也要决策卸载到哪里。</p><p>文章首先给出了计算卸载模型，并将此问题表述为一个NP难的混合整数非线性规划问题。利用遗传算法和粒子群优化算法，设计了一个次优算法——分层遗传算法（hierarchical GA）和基于粒子群算法（PSO-based computation）的计算算法。最后通过仿真研究了收敛性，并与其他基准算法比较，验证了它的性能。</p><a id="more"></a><table><thead><tr><th>英文缩写</th><th>全称</th><th>中文</th></tr></thead><tbody><tr><td>UEs</td><td>user equipments</td><td>用户设备</td></tr><tr><td>MEC</td><td>mobile edge computing</td><td>移动边缘计算</td></tr><tr><td>SCNs</td><td>small cell networks</td><td>小型蜂窝网络</td></tr><tr><td>SBSs</td><td>small cell base station</td><td>小型蜂窝基站</td></tr><tr><td>PSO</td><td>particle swarm optimization</td><td>粒子群算法</td></tr><tr><td>GA</td><td>genetic algorithm</td><td>遗传算法</td></tr><tr><td>QoS</td><td>quality of user services</td><td>用户服务质量</td></tr><tr><td>MBS</td><td>Macro base stations</td><td>大型/宏基站</td></tr><tr><td>MINLP</td><td>mix integer non-linear programming</td><td>混合整型非线性编程问题</td></tr><tr><td>HGPCA</td><td></td><td>作者提出的次优化算法</td></tr></tbody></table><p>​        high interference、multi-access property、limited resources of small cell base station</p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><p>移动边缘计算中，计算卸载是关键环节，包含：传输过程、远程执行过程、结果回传过程。通过网络将计算卸载到边缘计算服务器中，大大降低时延，延长设备使用。</p><p>该团队解决了三个挑战：计算决策、无线资源分配、计算资源分配。</p><ul><li><p>计算决策问题</p><p>决定计算任务要在云端还是用户设备端进行。虽然边缘服务器可以为设备提供云服务，但是无法保证所有的设备在有限的网络和计算能力下都能得到服务。或者是过量的任务卸载到边缘，会造成拥塞、用户间交流的高干扰。</p><p>——通过优化多用户间多小区网络中的计算决策问题、平衡用户服务和系统收益。</p></li><li><p>无线资源分配</p><p>能耗是很重要的一部分。由于UE与边缘服务器的通信距离相对短，可以降低能耗。但是计算卸载的能效依赖于无线资源分配方案。传输功率增加，数据速率增加，但干扰和传输能耗也增加，延迟也可能增加。因此分配无线资源时，需要更高效的干扰管理方案，自适应的功率控制。</p></li><li><p>计算资源分配</p><p>应该不均匀分配。1）不同用户有不同的任务大小；2）根据网络状况的良莠，QoS需要更多/更少的计算资源</p><p>联合动态无线和计算资源分配方案。</p></li></ul><p>考虑多个SBS服务多个用户的MEC系统，考虑干扰管理、功率控制方案，优化卸载决策、信道分配、计算资源分配方案来研究节能计算方案。工作：</p><ul><li>提出采用MEC的分布式SCN的计算卸载系统模型，MBS与SBS都配备了MEC服务器。从延迟和能耗方面给用户带来好处，给系统的效率提升。</li><li>在边缘计算系统中，将能耗计算卸载问题定义为一个混合整型非线性编程问题（MINLP）——NP-hard。主要就是为例如在满足所有用户设备的异构质量服务要求和资源分配原则下，以最少的能耗完成任务。</li><li>基于层次GA、PSO，提出HGPCA次优化算法。提高收敛速度和性能。并分析算法的复杂性和收敛性。</li><li>模拟时，部署了数百个用户和数十个小基站，研究算法收敛性并与其他基准算法比较验证性能。</li></ul><h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><h4 id="A-小型蜂窝网络下的移动边缘计算系统"><a href="#A-小型蜂窝网络下的移动边缘计算系统" class="headerlink" title="A. 小型蜂窝网络下的移动边缘计算系统"></a>A. 小型蜂窝网络下的移动边缘计算系统</h4><table><thead><tr><th>变量</th><th>意义</th><th>中文</th></tr></thead><tbody><tr><td>$$N_B={0,1,2,…i,…,N}$$</td><td>SBS</td><td>基站</td></tr><tr><td>$$u={1,2,…,j,…,U}$$</td><td>UEs</td><td>用户终端</td></tr><tr><td>$$T_j={d_j,X_j,T^{max}_j}$$</td><td>Task</td><td>j的计算任务</td></tr></tbody></table><ul><li><p>每个UE都有一个非密集型计算任务需要完成。</p></li><li><p>SBS与UE随机分配在MBS周围</p></li><li><p>计算任务j：<br>$$<br>T_j={d_j,X_j,t^{max}_j}<br>$$</p></li></ul><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>$$d_j$$</td><td>计算需要上传的数据</td></tr><tr><td>$$X_j$$</td><td>处理1位输入需要的CPU周期数，每个任务都不同</td></tr><tr><td>$$t^{max}_j$$</td><td>任务能接受的最大时延</td></tr><tr><td>$$f_j=d_jX_j$$</td><td>完成第j个计算任务需要的CPU周期数</td></tr></tbody></table><ul><li>每个任务可以在本地计算，也可以卸载到MBS或SBS中的MEC服务器。</li><li>卸载需要三步：1）通过无线信道上传数据；2）在MEC服务器上执行任务；3）从MEC服务器上下载结果到UE。【重点放在前两步，涉及到一个通信模型和一个计算模型】</li></ul><h4 id="B-通信模型"><a href="#B-通信模型" class="headerlink" title="B. 通信模型"></a>B. 通信模型</h4><p>主要集中在上行链路传输。</p><table><thead><tr><th>变量</th><th>意义</th><th></th></tr></thead><tbody><tr><td>$$a^{(i)}_j\in{0,1}$$</td><td>任务j是否卸载、卸载到哪个基站</td><td>0：不卸载，1：卸载</td></tr><tr><td>$$A={a^{(i)}_j,i\in N_B,j\in u}$$</td><td>决策profile</td><td></td></tr><tr><td>$$\sum_{i\in N_B}a^{(i)}_j \le1$$</td><td>终端j的任务只能被一个基站处理</td><td></td></tr><tr><td>$$c={1,2,…,k,…,C}$$</td><td>信道们</td><td></td></tr><tr><td>$$c_M={1,2,…,C_M}$$</td><td>MBS的信道</td><td></td></tr><tr><td>$$c_S={C_M+1,C_M+2,…,C}$$</td><td>SBS的信道</td><td>$C-C_M=\rvert c_S\rvert$</td></tr><tr><td>$$W$$</td><td>每个信道的带宽</td><td>每个信道都是独立同分布的</td></tr></tbody></table><ul><li>假设MBS与SBS使用不用的无线电频谱来避免层间干扰。对于SBS，频谱 以叠加的方式使用时，意味着在小区之间存在干扰。而每个信道是正交的，也就是说同一个区内，不存在干扰。</li><li>MaUs ：UE的任务被大型基站处理    </li><li>SUs ：UE的任务被小型基站处理</li></ul><table><thead><tr><th>变量</th><th>意义</th><th></th></tr></thead><tbody><tr><td>$$b^{(k)}_j\in{0,1}$$</td><td>信道分配指示器</td><td>信道k分配给UE-j</td></tr><tr><td>$$B={b^{(k)}_j,j\in u,k\in c}$$</td><td>信道分配指示profile</td><td>满足1）2）条件</td></tr><tr><td>$$\sum_{i\in N_B}\sum_{k\in{c_a}}a^{(i)}_jb^{(k)}_j\le1$$</td><td>每个基站的一个信道最多只能分配给给一个任务</td><td>1）</td></tr><tr><td>$\sum_{j\in u}\sum {k\in c_a}a^{(i)}_jb^{(k)}_j\le\rvert c_a\rvert$</td><td>分配给所有终端的信道不能超过每个BS中的信道总数。</td><td>2）</td></tr><tr><td>$$c_a$$</td><td>一些基站中可得到的信道集合</td><td>对于SBS来说$c_a=C_S$,对于MBS来说$c_a=C_M$</td></tr></tbody></table><ul><li>假设所有终端在传输时它的传输功率是静态的。</li></ul><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>$$p_j$$</td><td>终端j的传输功率</td></tr><tr><td>$$P={p_1,…,p_j,…,p_U}$$</td><td>终端传输功率集profile</td></tr><tr><td>$$p_{max}$$</td><td>最大传输功率</td></tr></tbody></table><h5 id="传输速率R-0"><a href="#传输速率R-0" class="headerlink" title="传输速率R_0"></a>传输速率R_0</h5><p>当满足$a^{(0)}<em>j=1$时，UE-j分配得信道k ($b^{(k)}_j=1$)，则<strong>传输速率R</strong>满足：<br>$$<br>R^{0}_j(A</em>{_j},B,P)=\sum_{k\in{c_a}}b^{(k)}<em>jWlog_2(1+\frac{p_j\rvert h</em>{0j}^{(k)}\rvert^2}{N_0})<br>$$</p><ul><li>$A_{_j}$是除了UE-j外的卸载决策profile</li><li>$h_{0j}^{(k)}$是从UE-j到MBS的信道增益</li><li>$N_0$是复高斯白噪声方差</li></ul><h5 id="小区间干扰指示函数-delta"><a href="#小区间干扰指示函数-delta" class="headerlink" title="小区间干扰指示函数$\delta$"></a>小区间干扰指示函数$\delta$</h5><p>考虑相邻的SBS中的SU对该SU接收信号的干扰，将<strong>小区间干扰指示函数</strong>表示为：<br>$$<br>\delta_{i,j^{‘}}^{(k)}=\begin{cases}<br>1,RSS_{i,j^{‘}}^{(k)} \ge RSS_{th}\<br>0,else.<br>\end{cases}<br>$$</p><p>$$<br>RSS_{i,j^{‘}}^{(k)} =  \sum_{i^{‘}\in{N_B}\setminus i}<br>a^{(i{‘})}<em>{j{‘}}b^{(k)}</em>{j{‘}}p_{j{‘}}<br>\rvert h^{(k)}_{i,j{‘}}\rvert^2<br>$$</p><p>RSS表示SU-j’ 对SBS-i的分配信道k上的干扰功率，RSSth表示干扰阈值；su-j’和SBS-i不相关。</p><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>$$RSS_{i,j^{‘}}^{(k)}$$</td><td>$SU-j’$ 在$SBS-i$ 分配的信道$k$上收到的干扰功率</td></tr><tr><td>$$RSS_{th}$$</td><td>干扰阈值</td></tr><tr><td></td><td>$SU-j’$ 与$SBS-i$ 不相关</td></tr></tbody></table><h5 id="来自其他SU对SBS-i的信道k的干扰I"><a href="#来自其他SU对SBS-i的信道k的干扰I" class="headerlink" title="来自其他SU对SBS-i的信道k的干扰I"></a>来自其他SU对SBS-i的信道k的干扰I</h5><p>来自其他SU对SBS-i、信道k的干扰：<br>$$<br>I_{ij}^{(k)}(A_{_j},B_{_j},P_{_j})=<br>\sum_{i’\in N_B\setminus 0}<br>\sum_{j’\in u\setminus j}<br>a^{(i’)}<em>{j’}b^{(k)}</em>{j’}<br>\delta_{i,j^{‘}}^{(k)}<br>p_{j’}\rvert h_{i,j’}^{(k)}\rvert^2<br>$$</p><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>$$B_{_j}$$</td><td>除了UE-j外的信道分配指示集</td></tr><tr><td>$$P_{_j}$$</td><td>除了UE-j外的传输功率集</td></tr><tr><td>$$h_{i,j’}^{(k)}$$</td><td>在SBS-i和UE-j’之间的信道k的信道增益</td></tr></tbody></table><h5 id="传输速率R-i"><a href="#传输速率R-i" class="headerlink" title="传输速率R_i"></a>传输速率R_i</h5><p>故，达到的<strong>传输速率</strong>：<br>$$<br>R^i_j(A_{_j},B,P)=<br>\sum_{k\in c_a}<br>b^{(k)}<em>j Wlog_2<br>(1+\frac<br>{p_j\rvert h</em>{ij}^{(k)}\rvert^2}<br>{I^{(k)}<em>{ij} (A</em>{_j},B_{_j},P_{_j})+N_0})<br>$$</p><h4 id="C-计算模型"><a href="#C-计算模型" class="headerlink" title="C. 计算模型"></a>C. 计算模型</h4><p>计算任务是如何在本地终端的UE上执行的，或者是在MEC服务器上远程执行。</p><h5 id="1）本地计算"><a href="#1）本地计算" class="headerlink" title="1）本地计算"></a>1）本地计算</h5><p>假设每个终端的CPU在计算时的频率不变，但不同的终端可能有不同的频率。</p><table><thead><tr><th>变量</th><th>意义</th><th></th></tr></thead><tbody><tr><td>$$F_j^{(l)}$$</td><td>每个终端UE-j的计算能力</td><td>通过CPU周期表示(Hz/s)</td></tr><tr><td>$$p^{(e)}_{j,l}$$</td><td>终端UE-j本地计算时CPU一个周期的能耗</td><td></td></tr></tbody></table><h6 id="终端本地计算的延迟T"><a href="#终端本地计算的延迟T" class="headerlink" title="终端本地计算的延迟T"></a>终端本地计算的延迟T</h6><p>$$<br>T^{(e)}_{j,l}=\frac<br>{f_j}<br>{F_j^{(l)}}<br>$$</p><h6 id="本地计算的能耗E"><a href="#本地计算的能耗E" class="headerlink" title="本地计算的能耗E"></a>本地计算的能耗E</h6><p>$$<br>E_{j,l}^{(e)}=f_jp^{(e)}_{j,l}<br>$$</p><h5 id="2）边缘计算"><a href="#2）边缘计算" class="headerlink" title="2）边缘计算"></a>2）边缘计算</h5><h6 id="BS-传输的延迟T（第一阶段）"><a href="#BS-传输的延迟T（第一阶段）" class="headerlink" title="BS 传输的延迟T（第一阶段）"></a>BS 传输的延迟T（第一阶段）</h6><p>$$<br>T_{j,off}^{(i,tr)}(A_{_j},B,P)=\frac<br>{d_j}<br>{R_j^{(i)}(A_{_j},B,P)}<br>,i \ge0<br>$$</p><h6 id="BS-传输能耗E（第一阶段）"><a href="#BS-传输能耗E（第一阶段）" class="headerlink" title="BS 传输能耗E（第一阶段）"></a>BS 传输能耗E（第一阶段）</h6><p>$$<br>E_{j,off}^{(i,tr)}(A_{_j},B,P)=<br>P_jT_{j,off}^{(i,tr)}(A_{_j},B,P)<br>$$</p><table><thead><tr><th>变量</th><th>意义</th><th></th></tr></thead><tbody><tr><td>$$F_i (i\in N_B)$$</td><td>每个BS的计算能力</td><td>$F_0 \gg F_i,i&gt;0$，大型基站的计算能力要远远大于小型基站</td></tr><tr><td>$$F_j^{(i)}$$</td><td>UE=j分配到的MEC-i的计算资源</td><td></td></tr><tr><td>$$F={F_j^{(i)},i\in N_B,j\in u }$$</td><td>计算资源的分配集profile</td><td>$\sum_{j\in u}F_j^{(i)} \le F_i,\forall i\in N_B $，即对于分配给终端j的资源，必须小于等于基站i的总资源</td></tr></tbody></table><h6 id="边缘计算时延"><a href="#边缘计算时延" class="headerlink" title="边缘计算时延"></a>边缘计算时延</h6><p>$$<br>T_{j,off}^{(i,e)}(F)=\frac{f_j}{F_j^{(i)}}<br>$$</p><p>忽略MEC上执行任务的能耗，因为BS能源丰富。另外也不考虑第三阶段，因为实际情况，传入数据往往比输出的数据要大。</p><h6 id="总时延T"><a href="#总时延T" class="headerlink" title="总时延T"></a>总时延T</h6><p>$$<br>T_j^{(i,off)}(A_{_j},B,P,F)=<br>T_{j,off}^{(i,tr)}(A_{_j},B,P)+<br>T_{j,off}^{(i,e)}(F)<br>$$</p><h6 id="总能耗E"><a href="#总能耗E" class="headerlink" title="总能耗E"></a>总能耗E</h6><p>$$<br>E_j^{(i,off)}(A_{_j},B,P)=E_{j,off}^{(i,tr)}(A__j,B,P)<br>$$</p><h3 id="问题公式化和分析"><a href="#问题公式化和分析" class="headerlink" title="问题公式化和分析"></a>问题公式化和分析</h3><p>在该系统模型的基础上，将计算卸载问题定义为一个优化问题，包括计算卸载决策、无线资源管理、功率控制和计算资源分配。然后对所述问题进行了复杂性分析。</p><h5 id="A-问题表示"><a href="#A-问题表示" class="headerlink" title="A. 问题表示"></a>A. 问题表示</h5><p>对于A、B、F，可以得到完成UE-j任务的时延和能耗</p><h6 id="完成任务的时延"><a href="#完成任务的时延" class="headerlink" title="完成任务的时延"></a>完成任务的时延</h6><p>$$<br>T_j(A,B,P,F)=<br>\sum_{i \in N_B}a_j^{(i)}T_j^{(i,off)}<br>(A_{_j},B,P,F)+(1-\sum_{i\in N_B}a_j^{(i)})<br>T_{j,l}^{(e)}<br>$$</p><h6 id="完成任务的能耗"><a href="#完成任务的能耗" class="headerlink" title="完成任务的能耗"></a>完成任务的能耗</h6><p>$$<br>E_j(A,B,P,F)=<br>\sum_{i\in N_B}a_j^{(i)}E_j^{(i,off)}(A_{_j},B,P)+<br>(1-\sum_{i\in N_B}a_j^{(i)})E_{j,l}^{(e)}<br>$$</p><p>当满足$a_j^{(i)}=0$时，有$T_j^{(i,off)}=0,E_j^{(i,off)}=0$</p><h6 id="问题-P-0"><a href="#问题-P-0" class="headerlink" title="问题$P_0$"></a>问题$P_0$</h6><p>求最小的所有终端总能耗<br>$$<br>P_0: \min_{A,B,P,F} \sum_{j\in u}E_j(A,B,P,F)\<br>$$</p><table><thead><tr><th>序号</th><th>公式条件</th><th>意义</th></tr></thead><tbody><tr><td>C1</td><td>$$T_j(A,B,P,F)\le t_j^{max},\forall j\in N_u$$</td><td>所有UE的时延</td></tr><tr><td>C2</td><td>$$\sum_{j\in u}\sum_{k\in c_a}a_j^{(i)}b_j^{(k)}\le\rvert c_a\rvert$$</td><td>分配的信道之和不能超出可分配量</td></tr><tr><td>C3</td><td>$$\sum_{j\in u}F_j^{(i)}\le F_i,\forall i\in N_B$$</td><td>分配的计算资源不能超过该基站所有资源</td></tr><tr><td>C4</td><td>$$\sum_{i\in N_B}a_j^{(i)}\le 1,\forall j \in u$$</td><td>一个任务只能卸载到一个基站</td></tr><tr><td>C5</td><td>$$\sum_{i\in N_B}\sum_{k\in c_a} a_j^{(i)}b_j^{(k)} \le 1, \forall j\in u$$</td><td>一个信道只同时被一个终端使用</td></tr><tr><td>C6</td><td>$$a_j^{(i)}\in {0,1},\forall i\in N_B,j\in u$$</td><td>每个UE任务j是否卸载到BS-i</td></tr><tr><td>C7</td><td>$$b_j^{(k)}\in {0,1}, \forall i\in N_B,j\in u,k\in c$$</td><td>每个UE-j是否使用信道k</td></tr><tr><td>C8</td><td>$$0\le F_j{(i)}\le F_i,\forall i\in N_B,j\in u$$</td><td>UE-j从BS-i分配到的计算资源不能超过BS-i总量</td></tr><tr><td>C9</td><td>$$0\le p_j\le p_{max},\forall j \in u $$</td><td>UE-j的传输功率小于最大功率</td></tr><tr><td>C10</td><td>$$a_j^{(i)}=\sum_{k\in c_a}b_j^{(k)} = I(F_j^{(i)}),\forall i\in N_B,j\in u$$</td><td></td></tr><tr><td></td><td>$$I(·)=\begin{cases}1,·&gt;0\ 0,otherwise\end{cases}$$</td><td>指示器，避免一个终端只分配到计算资源或无线资源下的资源浪费</td></tr></tbody></table><h5 id="B-问题分析"><a href="#B-问题分析" class="headerlink" title="B. 问题分析"></a>B. 问题分析</h5><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><p>$P_0$旨在求得所有终端最小的总能耗，通过优化卸载决策A，信道分配指示B，传输功率P，计算资源分配指示F。</p><p>NP难问题——混合整数非线性编程问题（MINLP）A,B中是二进制变量，P、F中是正实数。$P_0$问题非光滑、非微分或连续。</p><h3 id="拟议算法"><a href="#拟议算法" class="headerlink" title="拟议算法"></a>拟议算法</h3><table><thead><tr><th>Algorithm1 HGPCA（基于粒子群PSO和分层遗传算法GA）</th></tr></thead><tbody><tr><td>1. <strong>input</strong> : 种群个体数量K，HGPCA的迭代T，收敛准则$\epsilon$，GA的参数$p_m,p_c,T_1$,PSO的参数$w,c_1,c_2,T_2$</td></tr><tr><td>2. <strong>output</strong> :  在T此迭代后的K个个体，和历史中的适应度值最佳的值</td></tr><tr><td>3. <strong>初始化</strong> : 用表达式（18）初始化K个个体，让$t=0$</td></tr><tr><td>4. <strong>Step 1</strong> : if $t&gt;T$ or $Fitness(t)-Fitness(t-1)\le\epsilon$，break；else，go to Step 2.</td></tr><tr><td>5. <strong>Step 2</strong> : 执行 Algorithm 2</td></tr><tr><td>6. <strong>Step 3</strong>: 执行 Algorithm 3</td></tr><tr><td>7. <strong>Step 4</strong>: $t=t+1$, go to Step 1</td></tr></tbody></table><h4 id="A-HGPCA-流程"><a href="#A-HGPCA-流程" class="headerlink" title="A. HGPCA 流程"></a>A. HGPCA 流程</h4><p>GA——优胜劣汰，适合大范围搜索，收敛速度慢（基础）</p><p>PSO——适合局部搜索，收敛快，易陷入局部最优（优化）</p><p>在每一次迭代时，先用GA作为T1迭代，得到粗粒度的结果，然后用T1的结果传入PSO作为T2的迭代，下一次迭代的输入，就是T2的迭代输出。当$t=0$时，用表达式（17）作为input。</p><table><thead><tr><th>Algorithm 2 底层GA</th></tr></thead><tbody><tr><td>1. <strong>Input</strong> : 种群中$K$个个体，$p_m,p_c$，GA $T_1$ 迭代次数</td></tr><tr><td>2. <strong>Output</strong> : 经过$T_1$迭代后的$K$个种群，以及最优值</td></tr><tr><td>3. <strong>Step 1</strong> :   if $t_1 &gt; T_1$, break; else, go to Step 2.</td></tr><tr><td>4. <strong>Step 2</strong> :  评估种群，即计算个体的适应度值</td></tr><tr><td>5. <strong>Step 3</strong> :  找到本次迭代中最优的个体$I_{best}^{t_1}$，并记录在历史最优上$H_{best}$。if $I_{best}^{t_1}$ is better than $I_{best}$，$I_{best}=I_{best}^{t_1}$，else $I_{best}=I_{best}^{t_1-1}$。</td></tr><tr><td>6. <strong>Step 4</strong> : 根据设定的规则选择$K$个个体，另外，如果$I_{best}$不在父集上，就用$I_{best}$代替坏的个体。另外，选择两个不可行的个体保留。</td></tr><tr><td>7. <strong>Step 5</strong> : 随机选择两个个体，并以交叉概率$p_c$进行交叉操作</td></tr><tr><td>8. <strong>Step 6</strong> : 对于每个个体，以突变概率$p_m$进行突变操作</td></tr><tr><td>9. <strong>Step 7</strong> : $t_1=t_1+1$，go to Step 1</td></tr></tbody></table><table><thead><tr><th align="left">Algorithm 3 上层PSO</th></tr></thead><tbody><tr><td align="left">1. <strong>Input</strong> : 由算法2生成的精英粒子$\kappa$，蜂群的大小$K$，PSO的迭代次数$T_2$，PSO的参数$w,c_1,c_2$</td></tr><tr><td align="left">2. <strong>Output</strong> : 在$T_2$迭代后的粒子，以及历史最优值</td></tr><tr><td align="left">3. <strong>初始化</strong> : 初始化精英粒子$\kappa$的速度，设置迭代次数$t_2=0$，计算每个粒子的最优值</td></tr><tr><td align="left">4. <strong>Step 1</strong> :  if $t_2 &gt; T_2$，break；else，go to Step 2</td></tr><tr><td align="left">5. <strong>Step 2</strong> : 根据表达式（22）和（23）更新粒子$\kappa$的速度$V_k^{t_2}$和位置$X_k^{t_2}$，找到历史最优粒子</td></tr><tr><td align="left">6. <strong>Step 3</strong> :  评估迭代中每个粒子的适合度值。对于每个粒子，如果它的新适应度比自己的最佳适应度$p_{best}$要好，就更新</td></tr><tr><td align="left">7. <strong>Step 4</strong> :  找到所有粒子中基于每个粒子$p_{best}$的最优值$g_{best}$</td></tr><tr><td align="left">8. <strong>Step 5</strong> :  $t_2=t_2+1$，go to Step 1</td></tr></tbody></table><h4 id="B-GA"><a href="#B-GA" class="headerlink" title="B. GA"></a>B. GA</h4><p>遗传算法采用了生物遗传中优胜劣汰的思想，只要求问题是可计算的，忽略它是否可微、连续等。它从一组初始解开始，通过选择、交叉和变异进行优化，直到达成可接受的解决方案或收敛。交叉和突变的操作可以保持种群多样性，扩展搜索区域，故不容易陷入局部最优。</p><h5 id="1）-染色体和适应度函数"><a href="#1）-染色体和适应度函数" class="headerlink" title="1） 染色体和适应度函数"></a>1） 染色体和适应度函数</h5><h6 id="染色体-expression（15）"><a href="#染色体-expression（15）" class="headerlink" title="染色体 expression（15）"></a>染色体 expression（15）</h6><p>使用real coded GA。一个个体由染色体定义，染色体是问题$P_0$的一个解决方案，某个种群的染色体和结构。为了减少要优化的变量的数量，将${A,B,P,F}$转化为$I$：<br>$$<br>I=[A^{<em>} \space\space B^{</em>}\space\space P\space\space F^{*}]^{\top}<br>$$<br><img src="https://xheartbeat.top/mdpicture/image-20210418150851266.png" alt="image-20210418150851266"></p><img src="https://xheartbeat.top/mdpicture/image-20210418150908872.png" alt="image-20210418150908872"><table><thead><tr><th>变量</th><th>意义</th></tr></thead><tbody><tr><td>$A^*={a^*_j,j\in N_B}$</td><td>计算卸载决策</td></tr><tr><td>$a_j^*\in {-1}\cup N_B$</td><td>UE-j选择的基站，-1代表没有选择</td></tr><tr><td>$B^*={b^*_j,j\in u}$</td><td>可得到的信道</td></tr><tr><td>$b_j^*\in 0\cup c_a$</td><td>分配给UE-j的信道</td></tr><tr><td>$F^*={f_j^*,j\in u}$</td><td>可得到的计算资源</td></tr><tr><td>$f_j^*\in [0,F]$</td><td>基站分配给UE-j的计算资源，F是基站总资源</td></tr><tr><td>图中的$I_j$</td><td>用户j的亚染色体</td></tr></tbody></table><h6 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h6><p>$$<br>Fitness=\sum_{j\in N_u}E_j(A,B,P,F)+Penalty<br>$$</p><p>$$<br>Penalty=\sum_{j\in N_u}\alpha_j[max(0,T_j(A,B,P,F)-t_j^{max})]<br>$$</p><table><thead><tr><th>变量</th><th align="left">意义</th><th></th></tr></thead><tbody><tr><td>$\alpha_i$</td><td align="left">惩罚因素，不允许种群往不合适的方向发展，使种群收敛到可行的极端点。</td><td>仅约束$C_1$使用，因为在初始化和遗传操作中确保了其他的约束们</td></tr></tbody></table><h5 id="2）初始化和选择"><a href="#2）初始化和选择" class="headerlink" title="2）初始化和选择"></a>2）初始化和选择</h5><h6 id="初始化-expression-18"><a href="#初始化-expression-18" class="headerlink" title="初始化 expression(18)"></a>初始化 expression(18)</h6><p>算法1中的初始化是在此工作中随机生成的，但是在$P_0$的约束中（除了$C_1$）。初始种群的基因产生如下：<br>$$<br>a^{<em>}_j(0)=randin({-1}\cup N_B)\<br>b^{</em>}<em>j(0)=randin({0}\cup c_a)\<br>p_j(0)=rand(p</em>{max})\<br>f_j^{<em>}(0)=rand(F_{a_j^{</em>}(0)})<br>$$<br>$randin(Set)$是一个生成器函数，元素的输出是从随机选择器$Set.rand(x)$返回的，在$[0,X]$的随机数。对于$b_j^{<em>}(0)$，有：<br>$$<br>\kappa = \begin{cases}<br>\emptyset,\space\space\space\space\space\space a_j^{</em>}(0)=-1\<br>C_M,\space\space a_j^{<em>}(0)=0\<br>C_S,\space\space\space a_j^{</em>}(0)&gt;0<br>\end{cases}<br>$$</p><h6 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h6><p>选择的方法上，采用了锦标赛，它是在选择父母时从K个人中选择最适合的一个。1. 计算成本较低，2. 选择好父母比只选择最好的父母更好。它保持多样性，并有机会培养更好的人, 3. 将其应用于最小化MINLP问题时无需修改。</p><h5 id="3）交叉与突变"><a href="#3）交叉与突变" class="headerlink" title="3）交叉与突变"></a>3）交叉与突变</h5><p>每次迭代中，应该用选择来维持父代，然后对父结点进行交叉和变异操作产生子结点。</p><h6 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h6><p>随机选择两个父代，以交叉概率$p_c$交换对应的基因片段，从而产生两个后代。保持多样性。</p><img src="https://xheartbeat.top/mdpicture/image-20210418160827150.png" alt="image-20210418160827150"><h6 id="突变-expression-19-20"><a href="#突变-expression-19-20" class="headerlink" title="突变 expression(19)(20)"></a>突变 expression(19)(20)</h6><p>先选择一个个体，然后对染色体的每个元素，在表达式（15）定义后的变量范围内以突变概率$p_m$发生突变。</p><img src="https://xheartbeat.top/mdpicture/image-20210418161401864.png" alt="image-20210418161401864"><p>突变原理如下：<br>$$<br>\hat x ^{<em>}_j=\begin{cases}<br>round(x_j^{</em>}+\gamma_1(x_{max}-x_j^{<em>})),<br>\space\space\gamma_2&gt;0.5<br>\<br>round(x_j^{</em>}-\gamma_1(x_j^{*}-x_{min})),<br>\space\space\gamma_2\le0.5<br>\<br>\end{cases}<br>$$</p><p>$$<br>\hat y ^{<em>}_j=\begin{cases}<br>y_j^{</em>}+\gamma_1(y_{max}-y_j^{<em>}),<br>\space\space\gamma_2&gt;0.5<br>\<br>y_j^{</em>}-\gamma_1(y_j^{*}-y_{min}),<br>\space\space\gamma_2\le0.5<br>\<br>\end{cases}<br>$$</p><p>$x$ 代表前两行的整数变量，$y$代表后两行连续的整数变量。</p><p>$round(·)$是输出不超过$(·)$的整数。</p><p>$\gamma_1$,$\gamma_2$是两个(0,1)范围内的随机数</p><table><thead><tr><th>变量</th><th>意义</th><th></th></tr></thead><tbody><tr><td>$x$</td><td>前两行的整数变量</td><td></td></tr><tr><td>$y$</td><td>后两行连续的整数变量</td><td></td></tr><tr><td>$round(·)$</td><td>输出不超过$(·)$的整数。</td><td></td></tr><tr><td>$\gamma_1$,$\gamma_2$</td><td>随机数$\gamma_1,\gamma_2\sim Uniform(0,1)$</td><td>$\gamma_1$在局部搜索步骤调整中起作用，越大代表突变的幅度越大；$\gamma_2$控制着搜索方向，大于0.5时，向最大方向变化，反之。</td></tr><tr><td></td><td>在边界处不可行个体可以在一小步内成为可行，为了增加种群的多样性，算法2保留了一些不可行个体。</td><td></td></tr></tbody></table><h4 id="C-PSO-exp-21"><a href="#C-PSO-exp-21" class="headerlink" title="C. PSO exp(21)"></a>C. PSO exp(21)</h4><p>粒子有速度、位置（基于社会信息共享）。粒子的位置表示所提问题的解，而速度表示解的演化过程。与GA相似，粒子的位置用$X=I$表示expression（15），粒子的速度：<br>$$<br>V=[V_1\space\space\space\space V_2\space\space\space\space V_3\space\space\space\space V_4]^{\top}<br>$$</p><h5 id="粒子的速度-expression-22"><a href="#粒子的速度-expression-22" class="headerlink" title="粒子的速度 expression(22)"></a>粒子的速度 expression(22)</h5><p>$$<br>V_{r,d}^{t+1}=wV_{r,d}^t+r_1c_1(pbest_{r,d}-X_{r,d}^{t})+r_2c_2(gbest_{r,d}-X_{r,d}^t)<br>$$</p><h5 id="粒子的位置-expression-23"><a href="#粒子的位置-expression-23" class="headerlink" title="粒子的位置 expression(23)"></a>粒子的位置 expression(23)</h5><p>$$<br>X_{r,d}^{t+1}=\begin{cases} \begin{aligned}<br>round(X_{r,d}^t+V_{r,d}^{t+1}),\space\space r=1,2\<br>X_{r,d}^t+V_{r,d}^{t+1}\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space r=3,4\<br>\end{aligned}\end{cases}<br>$$</p><p>$w$是惯性权值，$c_1$,$c_2$是瞬间加速度，$r_1$,$r_2$增加搜索随机性，在$[0,1]$之间。速度和位置不会超出expression(15)的约束。</p><h4 id="D-计算复杂性"><a href="#D-计算复杂性" class="headerlink" title="D. 计算复杂性"></a>D. 计算复杂性</h4><p>初始化、适合度计算、选择、交叉、突变操作。每个-&gt;总体</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><table><thead><tr><th>内容</th><th>复杂度</th></tr></thead><tbody><tr><td>初始化种群，生成基本的UEs和SBSs的信息，比如位置、计算卸载任务、计算资源</td><td>$O(U+N)$</td></tr><tr><td>计算终端本地能耗和最大时延</td><td>$O(U)$</td></tr><tr><td>生出初始化$K$个个体的复杂度</td><td>$O(K\times U\times 4)$</td></tr></tbody></table><p>初始化的总复杂度为<br>$$<br>O(U+N)+O(U)+O(K\times U\times 4)\approx O(K\times U+N), N&lt;U<br>$$</p><h5 id="GA-选择、交叉、突变"><a href="#GA-选择、交叉、突变" class="headerlink" title="GA 选择、交叉、突变"></a>GA 选择、交叉、突变</h5><table><thead><tr><th>内容</th><th>复杂度</th></tr></thead><tbody><tr><td>选择操作</td><td>$O(K\times N_t),N_t$是一次锦标赛中的个体数量。</td></tr><tr><td>交叉操作</td><td>$O(K\times 4)\approx O(K)$</td></tr><tr><td>突变操作</td><td>$O(K\times U\times 4)\approx O(K\times U)$</td></tr><tr><td>基因操作总复杂度</td><td>$O(T_1\times K\times N_t)+O(T_1\times K)+O(T_1\times K\times U)\approx O(T_1\times K\times U)$，满足$U&gt;N_t&gt;1$</td></tr><tr><td>评估个体</td><td>$O(U^2)$</td></tr><tr><td>评估全部</td><td>$O(T_1\times K \times U^2)$</td></tr></tbody></table><p>GA 总复杂度为：<br>$$<br>O(T_1\times K\times U)+O(T_1\times K \times U^2)\approx O(T_1\times K \times U^2)<br>$$</p><h5 id="PSO"><a href="#PSO" class="headerlink" title="PSO"></a>PSO</h5><table><thead><tr><th>内容</th><th>意义</th></tr></thead><tbody><tr><td>评估</td><td>$O(T_1\times K \times U^2)$</td></tr><tr><td>位置和速度更新</td><td>$O(K\times U\times 4)\approx O(K\times U)$</td></tr></tbody></table><p>PSO总复杂度：<br>$$<br>O(T_1\times K \times U^2)+O(K\times U)\approx O(T_2\times K\times U^2)<br>$$</p><h5 id="总复杂度"><a href="#总复杂度" class="headerlink" title="总复杂度"></a>总复杂度</h5><p>$$<br>O(K\times U+N)+O(T\times T_1\times K\times U^2)+O(T\times T_2\times K\times U^2)\approx O(T\times T_1\times K\times U^2)<br>$$</p><p>$set \space \space T_1&gt;T_2$</p><h4 id="E-收敛性分析"><a href="#E-收敛性分析" class="headerlink" title="E. 收敛性分析"></a>E. 收敛性分析</h4><p>针对HGPCA，给出一些引理。</p><h5 id="Lemma-1"><a href="#Lemma-1" class="headerlink" title="Lemma 1"></a>Lemma 1</h5><p>HGPCA具有全局收敛性，当他满足：</p><p>1）下层GA在评估流程中总是包含最优解决方案；</p><p>2）惯性权值$w$、上层PSO的加速度常数$c_1,c_2$满足以下约束：<br>$$<br>\sqrt{2(1+w-\beta)^2-4w}&lt;2<br>$$<br>且$\beta=\beta_1+\beta_2，\beta_1=c_1r_1，\beta_2=c_2r_2$</p><h6 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h6><p>虽然经典的GA是无法全局收敛到最优处的，但是GA的一个变体确是可做到的，那就是无论在选择前还是选择后，最佳个体总是存在于种群之中。在算法2中的第四步，总有用最优个体$I_{best}$代替最糟糕的个体。故底层GA是可收敛的。</p><p>对于PSO，已有证明它收敛于：<br>$$<br>X\to \frac<br>{\beta_1p_{best}+\beta_2g_{best}}<br>{\beta}<br>$$<br>假设全局最优为$g_{best}^{<em>}$，当上层粒子群达到全局最优时，下层GA也达到全局最优点$g_{best}^</em>$，故：<br>$$<br>X\to \frac<br>{\beta_1p_{best}+\beta_2g_{best}}<br>{\beta}<br>=<br>\frac<br>{(\beta_1+\beta_2)g_{best}}<br>{\beta}<br>=g_{best}^*<br>$$</p><h3 id="仿真结果与讨论"><a href="#仿真结果与讨论" class="headerlink" title="仿真结果与讨论"></a>仿真结果与讨论</h3><h4 id="A-仿真设置"><a href="#A-仿真设置" class="headerlink" title="A. 仿真设置"></a>A. 仿真设置</h4><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>area</td><td>$1000\times 1000 m^2$</td></tr><tr><td>maximum latency</td><td>90% of the local latency</td></tr></tbody></table><table><thead><tr><th>算法</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>GACA</td><td>genetic algorithm based</td><td>遗传算法</td></tr><tr><td>PSOCA</td><td>particle swarm optimizatio</td><td>粒子群算法</td></tr><tr><td>RCA</td><td>random</td><td>随机算法，用户随机作出任务卸载决策、选择传输功率，SBS随机分配信道和计算资源</td></tr><tr><td>LCA</td><td>local</td><td>本地计算，用户选择在终端计算</td></tr><tr><td></td><td>energy consumption</td><td>能耗，指终端完成任务的总能耗</td></tr></tbody></table><p>比较</p><table><thead><tr><th>算法</th><th>全称</th><th>解释</th></tr></thead><tbody><tr><td>JOIS</td><td>Joint Computation Offloading and Interference Management Scheme</td><td>联合计算卸载和干扰管理方案，迭代优化变量</td></tr><tr><td>VBFS</td><td>the  optimal  solution  obtained  by  the  verified  Brute  ForceSearching  Algorithm</td><td>暴力搜索的最优解。首先离散化连续变量，在一个相对小范围内搜索，使用HGPCA的解决方案来提高搜索效率</td></tr></tbody></table><h4 id="B-收敛性分析"><a href="#B-收敛性分析" class="headerlink" title="B. 收敛性分析"></a>B. 收敛性分析</h4><p>在遗传算法中，有三个重要的参数：不同的种群大小K、不同的$p_c$交叉概率，不同的$p_m$突变概率。</p><table><thead><tr><th align="center">$K$</th><th align="center">$p_c$</th><th align="center">$p_m$</th></tr></thead><tbody><tr><td align="center"><img src="https://xheartbeat.top/mdpicture/image-20210420184422195.png" alt="image-20210420184422195"></td><td align="center"><img src="https://xheartbeat.top/mdpicture/image-20210420184459883.png" alt="image-20210420184459883"></td><td align="center"><img src="https://xheartbeat.top/mdpicture/image-20210420184554456.png" alt="image-20210420184554456"></td></tr><tr><td align="center">$K=16$</td><td align="center">$p_c=0.6$</td><td align="center">$p_m=0.01$</td></tr><tr><td align="center">当k很小的时候，无法保证种族多样性；当k很大的时候，一个小的变异可能无法包含最优解，因此需要更多迭代来收敛</td><td align="center">当交叉概率很小的时候，对种群多样性的贡献很小，当交叉概率很大时，可能导致解的状态变差。</td><td align="center">突变是很随机的，它不参考任何已知的信息，设计的本意是增加种群的多样性，而突变概率过大的时候可能会违背这个本意。</td></tr></tbody></table><img src="https://xheartbeat.top/mdpicture/image-20210420190705148.png" alt="image-20210420190705148"><p>在上述参数下，跟GA与PSO算法对比，可以看到，PSO算法明显收敛最快，HGPCA次之，最后是GA；其次，HGPCA有着最低的能耗，PSO最高，这是因为HGPCA结合了两者的优点——GA更适合全局搜索、PSO更适合局部精确搜索。由于PSO收敛最快，因此它在传统的GA基础上，使算法的收敛速度提高。</p><img src="https://xheartbeat.top/mdpicture/image-20210420191531497.png" alt="image-20210420191531497"><p>和暴力搜索相比，（4个SBS，4UE，随机分布在MBS，每个SBS有一个信道，2.4GHz）随着迭代，能耗减少，但迭代次数更加大时，性能优化不明显。</p><h4 id="C-性能分析"><a href="#C-性能分析" class="headerlink" title="C. 性能分析"></a>C. 性能分析</h4><h5 id="信道和计算资源不同"><a href="#信道和计算资源不同" class="headerlink" title="信道和计算资源不同"></a>信道和计算资源不同</h5><p>首先分析SBS不同资源量（信道和计算资源）对此算法的影响。然后，在各种参数下，与前面提到的其他基线算法进行比较后，可以验证所提出的算法。</p><table><thead><tr><th>SBS拥有的信道数量与能耗、卸载方案的关系</th><th align="left">SBS的计算资源与能耗、卸载的关系</th></tr></thead><tbody><tr><td><img src="https://xheartbeat.top/mdpicture/image-20210420205752448.png" alt="image-20210420205752448"></td><td align="left"><img src="https://xheartbeat.top/mdpicture/image-20210420205846307.png" alt="image-20210420205846307.png"></td></tr><tr><td>（假设有足够的计算资源）不难看出，SBS的信道数量增加时，能耗会下降，UE中任务卸载数会上升。信道少的时候，<strong>UE之间的干扰</strong>就会很大，会导致时延，卸载少。</td><td align="left">SBS的计算资源与能耗、卸载的关系（信道30个）。资源增加时，能耗下降，卸载数增加。资源少，计算时间长，大多选择本地计算，能耗就高；资源多，计算时间就少，卸载的性价比就高。</td></tr><tr><td></td><td align="left">当计算资源很多，传输时延就成了提高性能的绊脚石。无线资源和计算资源的匹配也很重要。</td></tr></tbody></table><h5 id="六种算法对比"><a href="#六种算法对比" class="headerlink" title="六种算法对比"></a>六种算法对比</h5><h6 id="GA-PSO-R-L"><a href="#GA-PSO-R-L" class="headerlink" title="GA/PSO/R/L"></a>GA/PSO/R/L</h6><table><thead><tr><th>UE: 100,200,300; SBS:49</th><th>SBS: 36, 48, 64; UE: 200</th></tr></thead><tbody><tr><td><img src="https://xheartbeat.top/mdpicture/image-20210421141307614.png" alt="HGP与其他的对比(UE不同)"></td><td><img src="https://xheartbeat.top/mdpicture/image-20210421141318120.png" alt="HGP与其他的对比(SBS不同)"></td></tr><tr><td>可以直观看出，HGPCA的能耗总是低于其他算法。</td><td>三种情况下，HGPCA能耗都是最低的。</td></tr><tr><td>HGPCA的能耗随着UE增加而增加，因为任务数多了，UE之间的干扰也增加了。</td><td>系统包含更多的计算资源，同时干扰也增加了，因此既HGPCA与GA的能耗都增加。</td></tr><tr><td></td><td>由于UE不变，LCA的能耗不变；PSO不适合计算大范围的问题，总会陷入局部最优；RCA随机分配资源，所以性能不稳定。</td></tr></tbody></table><table><thead><tr><th>算法</th><th>评价</th></tr></thead><tbody><tr><td>HGPCA</td><td>能耗表现最低</td></tr><tr><td>RCA</td><td>由于是随机决策，会导致相邻终端之间的严重干扰，因此能耗可能会变得非常大。</td></tr><tr><td>GACA</td><td>对卸载、信道分配、功率控制、计算资源分配均有决策，控制卸载终端的数量和干扰，为UE节省能源。（全局最优</td></tr><tr><td>PSOCA</td><td>同上（局部搜索，收敛快，容易陷入局部最优</td></tr></tbody></table><h6 id="JOIS"><a href="#JOIS" class="headerlink" title="JOIS"></a>JOIS</h6><table><thead><tr><th>SBS信道数不同</th><th>SBS计算能力不同</th></tr></thead><tbody><tr><td><img src="https://xheartbeat.top/mdpicture/image-20210421152724086.png" alt="fig-13-不同信道数量下JOIS与HGP"></td><td><img src="https://xheartbeat.top/mdpicture/image-20210421152734203.png" alt="fig-14-不同计算能力下的JOIS与HGP"></td></tr><tr><td>4SBS、4UE</td><td></td></tr><tr><td>随着信道数量上升，能耗都减少，但HGPCA的能耗一直都比JOIS低</td><td>随着SBS计算能力上升，能耗都降低，但是显然HGPCA的能耗一直低于JOIS</td></tr><tr><td>随着信道数量上升，UE卸载任务数量都增加，但HGPCA的卸载数量高于JOIS</td><td>随着SBS计算能力上升，任务卸载数量增加，但HGPCA的任务卸载分配要优于JOIS</td></tr></tbody></table><table><thead><tr><th>算法</th><th>评价</th></tr></thead><tbody><tr><td>HGPCA</td><td></td></tr><tr><td>JOIS</td><td>该算法只考虑能耗和根据本地时延分配给本地的计算资源，会导致资源利用率低。[24]</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;用户设备会将任务分发到移动边缘计算服务器上，但是在offload过程中，由于小基站的高干扰、多址、资源有限，需要一种高效的计算卸载方案。在这篇论文中，作者研究了在小型蜂窝网络下的边缘计算系统的节能计算卸载方案，通过计算卸载决策、频谱、功率和计算资源的联合优化，为的就是减少所有终端设备的能耗。终端设备不仅要决策是否卸载，也要决策卸载到哪里。&lt;/p&gt;
&lt;p&gt;文章首先给出了计算卸载模型，并将此问题表述为一个NP难的混合整数非线性规划问题。利用遗传算法和粒子群优化算法，设计了一个次优算法——分层遗传算法（hierarchical GA）和基于粒子群算法（PSO-based computation）的计算算法。最后通过仿真研究了收敛性，并与其他基准算法比较，验证了它的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="study &amp; plan" scheme="http://github.com/xxq1999/categories/study-plan/"/>
    
    
      <category term="边缘计算" scheme="http://github.com/xxq1999/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>个人取向变化记录</title>
    <link href="http://github.com/xxq1999/2021/04/21/lyrics/"/>
    <id>http://github.com/xxq1999/2021/04/21/lyrics/</id>
    <published>2021-04-20T16:00:00.000Z</published>
    <updated>2021-04-21T07:22:13.138Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>每当我偶尔翻到以前写的、或者是摘录的文字的时候，总是感觉，咦……原来我那时候是这种调调啊……啧啧啧……</p><p>好奇自己究竟有什么“审美”上的变化过程，顺便也摘一些喜欢的句子，开了这部分记录，给自己以后回过头来翻看的时候用。</p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p><em>21岁，自己最喜欢的还是音乐</em></p><hr><blockquote><p>在幻妙的时间里 有 望喜 和奇遇</p><p>在嘈杂的城市间 有永恒 的相遇</p><p>在有生之年里 常相伴 有知己</p><p>在漫妙的年龄享有 诚挚的 爱情</p></blockquote><p><strong>[ 勐巴拉娜西 ]</strong> 刺猬的歌总是能给我带来许多惊喜。这一段是最后子健写给小春天的祝福，真的很美好。</p><blockquote><p>晚星就像你的眼睛杀人又放火</p></blockquote><p><strong>[ 漠河舞厅 ]</strong> 《再见了晚星》</p><h2 id="文学"><a href="#文学" class="headerlink" title="文学"></a>文学</h2><blockquote><p>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。</p><p>倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。</p></blockquote><p><strong>[ 热风 · 随感录四十一 ]</strong> </p><blockquote><p>我凭依栏杆，细看那萤火虫。我和萤火虫双方都长久地一动未动。只有夜风从我们身边掠过。榉树在黑暗中磨擦着无数叶片，籁籁作响。 </p><p>我久久、久久地等待着。</p><p>过了很长很长时间，萤火虫才起身飞去。它顿有所悟似的，蓦地张开双翅，旋即穿过栏杆，淡淡的萤光在黑暗中滑行开来。它绕着水塔飞快地曳着光环，似乎要挽回失去的时光。为了等待风力的缓和，它又稍停了一会儿，然后向东飞去。 </p><p>萤火虫消失之后，那光的轨迹仍久久地印在我脑海中。那微弱浅淡的光点，仿佛迷失方向的魂灵，在漆黑厚重的夜幕中往来彷徨。</p><p>我几次朝夜幕中伸出手去，指尖毫无所触，那小小的光点总是同指尖保持着不可触及的距离。</p></blockquote><p><strong>[ 萤 ]</strong> 读了一遍《萤》，过程中一直被那种从何而来的悲伤笼罩着，心里又很安静很安静。</p><blockquote><p>亲爱的康氏：</p><p>抱歉因为生分，再唤你为康氏，因为阔别许久，无法想象你因为衰老而未曾出现的祥和的相貌。苦难已过，世界大好，如果有通往另一处日夜不眠的隧道，我将驾驶我深褐色的吉普车，摇下吱吱作响因寒冷而结霜的脆窗，我想向你展示我坚不可摧的礼扣，以及我未有一日曾动摇的思念若渴。</p><p>我时常想，人因何而美丽，又因何而凋谢，是食用了天合造化的菌类，或者瘟不知所起的家禽，动人的颜料片片剥落，毛发似雪花。你一定不属于任何一种，羞耻地，我竟然还会夸奖你，你的美丽在我一亩三方田地里，从未凋谢过。</p><p>倘若我晚生十年，我一定是当代赫赫有名的情话大王，早生十年，孩子们一定也会背诵我的诗歌，他们将短小精悍的句子摘抄在硬皮本的扉页，坑坑巴巴地撕下，送给心仪的女孩。不免有些遗憾，我为你书写的信件，没有哪一家出版社愿意刊登，瞎了眼，谁看了都知道，若不是用情至深，我怎敢肆无忌惮地表达我对你的喜爱，我甚至找不出词汇，轻易描述你的优雅。换言之，我一定免不了花言巧语之嫌，被史学家所诟病，为搏你芳心，人们一定指责我有意令宇宙短暂熄灭。</p><p> ……</p></blockquote><p><strong>[再见了晚星]</strong> 我们看过许多婚姻的悲剧，却也仍然坚信爱情的美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;每当我偶尔翻到以前写的、或者是摘录的文字的时候，总是感觉，咦……原来我那时候是这种调调啊……啧啧啧……&lt;/p&gt;
&lt;p&gt;好奇自己究竟有什么“审美”上的变化过程，顺便也摘一些喜欢
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>边缘计算综述1</title>
    <link href="http://github.com/xxq1999/2021/04/13/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E7%BB%BC%E8%BF%B01/"/>
    <id>http://github.com/xxq1999/2021/04/13/边缘计算综述1/</id>
    <published>2021-04-13T10:22:00.000Z</published>
    <updated>2021-04-21T08:07:46.518Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h4 id="总体介绍框架"><a href="#总体介绍框架" class="headerlink" title="总体介绍框架"></a>总体介绍框架</h4><p>参考文献：《边缘计算：现状与展望》施巍松</p><p>1、边缘计算</p><p>将计算任务在接近数据源的计算资源上运行，有效减少计算系统的延迟，减少数据传输带宽，环节云计算中心压力，提高可用性，并能够保护数据安全和隐私。</p><p>2、三个问题</p><ol><li>边缘计算从哪儿来？</li><li>现状</li><li>到哪儿去？</li></ol><p>3、发展历程</p><p>技术储备期、快速增长期、稳健发展期。</p><p>4、七项关键技术</p><p>5、六类典型应用</p><p>6、需要解决的六类问题</p><a id="more"></a><h4 id="传统云计算中心缺点"><a href="#传统云计算中心缺点" class="headerlink" title="传统云计算中心缺点"></a>传统云计算中心缺点</h4><ol><li>实时性不够</li><li>带宽不足</li><li>能耗较大</li><li>不利于数据安全和隐私</li></ol><h4 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h4><p>1、操作对象</p><p>云服务的下行数据、万物互联服务的上行数据</p><p>2、边缘指的是</p><p>从数据源到云计算中心路径之间的任意<strong>计算和网络资源</strong>，是一个<strong>连续统</strong></p><p>3、与云计算关系</p><p>相辅相成，边缘计算需要云计算中心强大的计算能力和海量数据的支持；云计算中心需要边缘计算中边缘设备对海量数据及隐私数据的处理。</p><p>4、优点</p><ol><li>不把数据传入云端，极大减轻了网络带宽和数据中心功耗的压力；</li><li>不需要通过网络请求云计算中心的响应，减少了系统延迟、增强了服务响应能力。</li><li>隐私数据存在网络边缘设备，减少数据泄露风险，保护用户隐私。</li></ol><h5 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h5><p>1、技术储备期</p><ul><li><p>内容分发网络(CDN，content delivery netword)</p><p>基于互联网缓存网络，依靠部署在各地的缓存服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，将用户的访问指向距离最近的缓存服务器上，以此降低网络拥塞，提高用户访问响应速度和命中率。</p></li><li><p>功能缓存（function cache）</p><p>CDN强调内容的备份和缓存，边缘则是功能缓存。</p></li><li><p>小朵云（Cloudlet）</p><p>可信且自愿丰富的主机，部署在网络边缘，与互联网连接，移动设备可访问并提供服务。强调下行，即将云服务器上的功能下行至边缘服务器，减少带宽和时延。</p></li><li><p>移动边缘计算（MEC，mobile edge computing）</p><p>接近移动用户的无线接入网范围内，提供信息技术服务和云计算能力的一种新的网络结构，已成为一种标准化、规范化的技术。它强调在云计算中心与边缘计算设备之间建立边缘服务器，在边缘服务器上完成终端数据的计算任务。</p></li><li><p>雾计算（fog computing）</p><p>迁移云计算中心任务到网络边缘设备执行的一种高度虚拟化计算平台。通过减少云计算中心和移动用户之间的通信次数，缓解主干链路的贷款负载和能耗压力。关注基础设施之间的分布式资源共享问题。</p></li><li><p>海云计算（cloud-sea computing）</p></li></ul><p>2、快速增长期</p><p>3、稳健发展期</p><h5 id="七项核心技术"><a href="#七项核心技术" class="headerlink" title="七项核心技术"></a>七项核心技术</h5><h6 id="1-网络"><a href="#1-网络" class="headerlink" title="1. 网络"></a>1. 网络</h6><p>​    将计算推至靠近数据源的位置，甚至将整个计算部署于从数据源到云计算中心的传输路径上的节点。三个新要求：</p><ul><li><p>服务发现</p><p>计算服务请求者的动态性，如何知道周边的服务？</p></li><li><p>快速配置</p><p>用户、计算设备动态增加、减少（车……），服务也要迁移，导致大量突发网络流量。而广域网的网络情况比云计算中心复杂，带宽也有限。如何从设备层支持服务的快速配置？</p></li><li><p>负载均衡</p><p>边缘设备产生大量数据，边缘服务器提供大量服务，根据服务器和网络状况，如何动态调度到合适的计算服务提供者？解决方法：</p></li></ul><p>“建立一条从边缘到云的计算路径” 解决方法：</p><ul><li><p>命名数据网络（NDN，named data networking）</p><p>将数据和服务进行命名和寻址，以P2P和中心化方式相结合进行自组织的一种数据网络。</p><p>数据从源到云的传输关系？——使用NDN解决计算链路中服务发现的问题。</p></li><li><p>软件定义网络（SDN，software defined networking）</p><p>控制面和数据面分离的可编程网络+简单网络管理。网络管理者可以快速进行路由器、交换机的配置，减少网络的抖动，支持快速流量迁移。</p><p>数据服务迁移，网络层面的动态性请求？——结合SDN</p></li></ul><h6 id="2-隔离技术"><a href="#2-隔离技术" class="headerlink" title="2. 隔离技术"></a>2. 隔离技术</h6><p>​    边缘设备需要通过有效的隔离技术来保证服务的可靠性和服务质量。</p><ul><li><p>计算资源的隔离：应用间不能互相干扰。</p></li><li><p>数据的隔离：不同应用程序具有不同的访问权限。</p><p>——VM虚拟机、Docker容器技术</p><ul><li>Docker技术：实现应用在基于OS级虚拟化的隔离环境中运行，其存储驱动程序采用容器内分层镜像的结构，使得应用程序可以作为一个容器快速打包和发布，保证了应用间隔离。</li></ul></li></ul><h6 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="3. 体系结构"></a>3. 体系结构</h6><p>​        未来的体系结构应该是？通用处理器和异构计算硬件并存的模式。</p><p>​        异构硬件牺牲部分通用计算能力，使用专用加速单元减小了某一类或多类负载的执行时间。</p><p>​        边缘计算常针对某一类特定的计算场景设计边缘计算平台的体系结构。</p><h6 id="4-边缘操作系统"><a href="#4-边缘操作系统" class="headerlink" title="4. 边缘操作系统"></a>4. 边缘操作系统</h6><p>​        边缘操作系统，向下管理异构的计算资源，向上处理大量的异构数据以及多用的应用负载，负责将计算任务在边缘计算节点上部署、调度、迁移，从而保证计算任务的可靠性以及资源的最大化利用。倾向于对数据、计算任务、计算资源的管理框架。</p><ul><li><p>机器人操作系统（ROS，robot operating system)</p><p>提供硬件抽象和驱动、消息通信标准、软件包管理……</p></li></ul><h6 id="5-算法执行框架"><a href="#5-算法执行框架" class="headerlink" title="5. 算法执行框架"></a>5. 算法执行框架</h6><p>​    人工智能算法——在云数据中心，算法执行框架更多执行<strong>模型训练</strong>，输入的是大规模的批量数据集，关注的是训练时的迭代速度、收敛率和框架的可扩展性；在边缘设备上，执行<strong>预测任务</strong>，输入实时小规模数据，其计算资源存储资源受限，更关注算法执行框架预测式的速度、内存占用量和能效。</p><table><thead><tr><th>属性</th><th>云服务器</th><th>边缘设备</th></tr></thead><tbody><tr><td>输入</td><td>大规模、批量数据集</td><td>小规模、实时</td></tr><tr><td>任务</td><td>训练、预测</td><td>预测</td></tr><tr><td>关注点</td><td>训练的迭代速度、收敛率、框架可扩展性</td><td>预测速度延迟、内存占用量、能效</td></tr></tbody></table><p>支持边缘设备执行智能任务、针对边缘设备的算法执行框架：TensorFlow Lite、Caffe2、PyTorch、MXnet……但是没有一个能在所有的关注点维度都取得最好的表现。</p><h6 id="6-数据处理平台"><a href="#6-数据处理平台" class="headerlink" title="6. 数据处理平台"></a>6. 数据处理平台</h6><p>​    边缘设备时刻产生海量数据，来源和类型多样化，大多具有时空属性。构建数据处理平台，针对边缘数据进行管理、分析和共享。</p><ul><li>OpenVDAP：异构计算平台、操作系统、驾驶数据收集器、应用程序库。安装部署，完成车载应用计算、车与云、车与车、车与路边计算单元的通信。</li></ul><h6 id="7-安全和隐私"><a href="#7-安全和隐私" class="headerlink" title="7. 安全和隐私"></a>7. 安全和隐私</h6><p>​    处于靠近用户侧、传输路径上的数据，更容易被入侵。边缘计算节点的分布式、异构型——难以统一管理。存在安全问题：应用安全、网络安全、信息安全和系统安全。</p><ul><li><p>密码学——信息安全，</p></li><li><p>访问控制策略——越权访问防护</p></li><li><p>机器学习</p></li><li><p>可信执行环境（TEE，trusted execution environment）</p><p>在设备上一个独立于不可信操作系统而存在的可信的、隔离的、独立的执行环境，通过硬件机制来保障（Intel软件防护扩展、Intel管理引擎、x86系统管理模式、AMD内存加密……）。通过将应用运行到可惜的执行环境中，并将使用到的外存进行加解密，故当边缘计算节点被攻破时，其应用与数据仍然能保证安全。</p></li></ul><h5 id="六大典型应用"><a href="#六大典型应用" class="headerlink" title="六大典型应用"></a>六大典型应用</h5><p>1、公共安全中实时数据处理</p><p>​        滴滴行车录像、视屏有用性检测系统</p><p>2、智能网联车（CAVs）和自动驾驶</p><p>​        KITTI自动驾驶算法评测数据集、视觉算法……</p><p>​        传感、感知（定位、识别、追踪）、决策。</p><p>​        软件栈：Apollo（百度）、Autoware（早稻田）</p><p>3、虚拟现实（VR、AR增强现实）</p><p>​        MUVR，在边缘服务器上支持多用户VR程序的处理框架，其将VR图像渲染到边缘服务器，并尝试重用用户之前的VR图像帧，以降低边缘服务器的计算和通信负担。</p><p>​        Furion：移动端VR框架，将VR负载分为前景交互和背景环境2种，前景交互在云端处理，而背景环境渲染卸载到移动端处理。</p><p>​        Google glass数据收集、显示VR图像，cloudlet（边缘节点）图像渲染、人脸识别。</p><p>4、工业物联网</p><p>​        边缘计算应用于工业物联网的优势：</p><ol><li>改善性能，工业中常见的报警、分析等靠近数据生产者的地方处理和决策会更快；</li><li>保证数据隐私，避免数据传输到共享数据中心后数据暴露等带来的安全隐私问题；</li><li>减少操作成本，减少数据传输量和带宽，从而减少了工业生产中由网络、云数据中心。</li></ol><p>5、智能家居</p><p>​        对于异构的设备，设备的命名、数据的命名、设备之间的智能化联动都是问题。隐私数据不能上传到云端。边缘计算可以将数据推送到家庭内部的网关，减少家庭数据的外流。</p><p>​        eg. 亚马逊Echo、三星SmartThings、谷歌Google home ——智能家居控制中心（不能完全依靠自身）</p><p>​                微软HomeOS，苹果HomeKit，——智能家居框架</p><p>​                EdgeOSH：通信模块、数据管理模块、自管理模块（提供统一编程接口）</p><p>​                非侵入式负荷检测（NILM，non-intrusive load monitoring），关注家庭用电状况并分析。</p><p>6、智慧城市</p><p>​        无人驾驶——依赖车内计算单元来识别交通信号和障碍物，并且规划路径。</p><p>​        EdgeOSc：底层数据感知层、中间的网络互联层、顶层的数据应用管理层。</p><h5 id="六个面临的问题方向"><a href="#六个面临的问题方向" class="headerlink" title="六个面临的问题方向"></a>六个面临的问题方向</h5><h6 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h6><p>​        编程模型可以使开发者快速上手开发应用产品。从功能角度讲，边缘计算是一种分布式的计算系统，具有弹性管理、协同执行、环境异构的特点。包含三个关键内容：</p><ol><li><p>应用程序/服务功能可分割。一个任务可以分成若干个子任务，并任务功能可以迁移到不同的边缘设备。</p></li><li><p>数据可分布。针对不用的数据源而言。</p></li><li><p>资源可分布。数据有可分布性，从而要求处理数据的计算、存储和通信资源也有可分布性。</p><p>​    边缘设备大多是异构的计算平台，且每个设备上的运行环境数据不同，资源相对有限，因此在边缘计算场景下部署应用程序会比较困难。——轻量级编程语言EveryLite将计算迁移任务中主体为接口调用的时间和空间复杂度受限的任务称为“微任务”，EveryLite可以处理微任务。</p></li></ol><h6 id="软硬件选型"><a href="#软硬件选型" class="headerlink" title="软硬件选型"></a>软硬件选型</h6><p>​        边缘计算系统有碎片化、异构性的特点，硬件层面上，有CPU、GPU、FPGA、ASIC等各类计算单元。即使是基于同一计算单元，也有不同的整机产品，例如基于英伟达GPU的边缘硬件产品，既有计算能力较强的DRIVE PX2，又有计算能力较弱的Jetson TX2；在软件系统上，针对深度学习应用，有TensorFlow，Caffe，PyTorch等各类框架，不同的软硬件及组合有各自擅长的应用场景，使得开发者不知道该如何选用合适的产品——针对自身应用的计算特性、满足计算能力需求的硬件产品、合适的软件框架开发，成本。</p><p>​            工具？帮助用户对边缘计算平台性能、功耗分析并提供软硬件选型参考。</p><h6 id="基准程序与标准"><a href="#基准程序与标准" class="headerlink" title="基准程序与标准"></a>基准程序与标准</h6><p>​            如何评测边缘计算的系统和平台？——经典基准测试集（benchmark）：并行计算PARSEC、高性能计算HPCC、大数据计算BigDataBench。</p><p>​            边缘计算？SD-VBS、MEVBench是针对移动端设备评测基于机器视觉负载的基准测试集；SLAMBench针对移动端机器人计算系统；CAVBench针对智能网联车边缘计算系统。</p><p>​            趋势：先针对每个场景出现一个经典基准测试集，之后各个集相互融合借鉴，找出边缘计算场景下的若干类核心负载，最终形成边缘计算场景中的benchmark。</p><h6 id="动态调度"><a href="#动态调度" class="headerlink" title="动态调度"></a>动态调度</h6><p>​        边缘计算系统要根据任务类型和边缘设备的计算能力进行动态调度：</p><ul><li>云计算中心和边缘设备之间的调度；</li></ul><p>​        自下而上、自上而下。自下而上是在网络边缘处，将边缘设备采集或者产生的数据进行部分或全部的预处理，过滤无用的数据，降低传输带宽。自上而下是指将云计算中心所执行的复杂计算任务进行分割，然后分配给边缘设备执行，以充分利用边缘设备的计算资源。</p><ul><li>边缘设备之间的调度。</li></ul><h6 id="与垂直行业的紧密结合"><a href="#与垂直行业的紧密结合" class="headerlink" title="与垂直行业的紧密结合"></a>与垂直行业的紧密结合</h6><h6 id="边缘节点的落地"><a href="#边缘节点的落地" class="headerlink" title="边缘节点的落地"></a>边缘节点的落地</h6><ol><li>新型商业模式</li><li>边缘节点的选择</li><li>边缘数据选择</li><li>边缘节点的可靠性</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;总体介绍框架&quot;&gt;&lt;a href=&quot;#总体介绍框架&quot; class=&quot;headerlink&quot; title=&quot;总体介绍框架&quot;&gt;&lt;/a&gt;总体介绍框架&lt;/h4&gt;&lt;p&gt;参考文献：《边缘计算：现状与展望》施巍松&lt;/p&gt;
&lt;p&gt;1、边缘计算&lt;/p&gt;
&lt;p&gt;将计算任务在接近数据源的计算资源上运行，有效减少计算系统的延迟，减少数据传输带宽，环节云计算中心压力，提高可用性，并能够保护数据安全和隐私。&lt;/p&gt;
&lt;p&gt;2、三个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;边缘计算从哪儿来？&lt;/li&gt;
&lt;li&gt;现状&lt;/li&gt;
&lt;li&gt;到哪儿去？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3、发展历程&lt;/p&gt;
&lt;p&gt;技术储备期、快速增长期、稳健发展期。&lt;/p&gt;
&lt;p&gt;4、七项关键技术&lt;/p&gt;
&lt;p&gt;5、六类典型应用&lt;/p&gt;
&lt;p&gt;6、需要解决的六类问题&lt;/p&gt;
    
    </summary>
    
      <category term="study &amp; plan" scheme="http://github.com/xxq1999/categories/study-plan/"/>
    
    
      <category term="边缘计算" scheme="http://github.com/xxq1999/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>笔试回顾</title>
    <link href="http://github.com/xxq1999/2021/04/11/%E7%AC%94%E8%AF%95%E5%9B%9E%E9%A1%BE/"/>
    <id>http://github.com/xxq1999/2021/04/11/笔试回顾/</id>
    <published>2021-04-11T10:22:00.000Z</published>
    <updated>2021-04-12T06:51:05.394Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><blockquote><p>买房子。</p><p>在一条直线上有n个房子，房子之间的距离都相等。每个房子有价格a[i]，小团知道小美的房子就在某一些房子的其中一间。现在小团要买房子，她想买到小美的房子期望距离最短的一间，同时，又不能花超过k的价钱，若有多个选择，选择编号小的。</p><p>输入：</p><p>一个n，一个k，代表房子的数量，最高的价格。</p><p>接下来n个整数，代表每个房子的价格，若某个房子价格为0，则小美可能住在这个房子里，且小团不能买这个房子。</p><p>输出：</p><p>房子编号。</p><p>2&lt;=n&lt;=100, 1&lt;k,a[i]&lt;100。 </p></blockquote><blockquote><p>射箭比赛。</p><p>A队和B队分别有n、m个人参加射箭比赛。B队队长知道A、B两队会有多少人射中靶心，且知道每个人射中时，距离靶心有多远。比赛规定，射中靶心的人，当距离小于k时，得1分，当距离大于等于k时，得2分。假设距离在[1,1000]之间，那么当k等于某个值时，A队得分为AS，B队得分为BS，问BS-AS最大可以为多少？若BS&lt;AS，输出0。</p><p>n,m&lt;1e5 </p></blockquote><blockquote><p>魔法字符串。</p><p>有长度为n的01字符串，小团可以对它施加魔法，做一次魔法，就能随机消除掉三个连续的字符，问0与1的差值最大可以为多少？</p><p>n&lt;1e5?</p></blockquote><blockquote><p>字符串。</p><p>如果一个小写的英文字符串内，包含最多的英文字母出现的次数大于等于一半，那么它就是ok字符串。给你一个字符串，问你它有多少字串满足ok字符串？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;美团&quot;&gt;&lt;a href=&quot;#美团&quot; class=&quot;headerlink&quot; title=&quot;美团&quot;&gt;&lt;/a&gt;美团&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;买房子。&lt;/p
      
    
    </summary>
    
      <category term="Job" scheme="http://github.com/xxq1999/categories/Job/"/>
    
    
      <category term="笔试" scheme="http://github.com/xxq1999/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://github.com/xxq1999/2021/04/10/%E5%89%91%E6%8C%87offer/"/>
    <id>http://github.com/xxq1999/2021/04/10/剑指offer/</id>
    <published>2021-04-10T03:13:00.000Z</published>
    <updated>2021-04-15T10:59:58.505Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>一边看书一边刷题</p><a id="more"></a><h2 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1. 赋值运算符函数"></a>1. 赋值运算符函数</h2><blockquote><p>类型CMyString，添加一个赋值运算符函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">CMyString(<span class="keyword">const</span> CMyString&amp; cMyString);</span><br><span class="line">~CMyString(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>返回值</strong></li></ul><p>str1=str2=str3（为了连续赋值的可能性）</p><p>将返回值设置为该类型的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>传入参数</strong></li></ul><p>常量引用，如果传入的不是引用而是实例的话，那么从形参到实参，就会多调用一次拷贝构造函数，降低效率。</p><ul><li><strong>释放内存</strong></li></ul><p>防止内存泄漏。</p><ul><li><strong>细节</strong></li></ul><p>要判断传入的参数与赋值的是不是同一个，这样如果释放内存的话，就会导致传入的参数也被释放了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::Operator=(<span class="keyword">const</span> CMyString&amp; cMyString)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>==&amp;cMyString)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 释放原有的空间</span></span><br><span class="line"><span class="keyword">delete</span>[] m_pData;</span><br><span class="line">m_pData=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 申请一块新的空间，并赋值</span></span><br><span class="line">m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cMyString.m_pData)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(m_pData,cMyString.m_pData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::Operator=(<span class="keyword">const</span> CMyString&amp; cMyString)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;cMyString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 新建一个临时的实例</span></span><br><span class="line">CMyString new_str(cMyString);</span><br><span class="line"><span class="comment">// 指针指向这临时实例的地址</span></span><br><span class="line"><span class="keyword">char</span> *temp = new_str.m_pData;</span><br><span class="line"><span class="comment">// 临时实例的char指向赋值对象的地址</span></span><br><span class="line">new_str.m_pData = m_pData;</span><br><span class="line"><span class="comment">// 赋值对象的地址指向指针的地址。</span></span><br><span class="line">m_pData = temp;</span><br><span class="line">&#125; <span class="comment">// 跳出if后，临时实例被析构，指向地址的空间被自动释放</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><em>把一个CMyString的实例赋值给另一个实例</em>。</li><li><em>把一个CMyString的实例赋值给它自己</em>。</li><li><em>连续赋值。</em> </li></ol><br><h2 id="2-C-单例模式"><a href="#2-C-单例模式" class="headerlink" title="2. C# 单例模式"></a>2. C# 单例模式</h2><br><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h2><h6 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><strong>sizeof</strong></h6><ul><li><p>int类型，一个占4字节。int a[]={1,2,3,4,5}, 则sizeof(a) = 20。</p></li><li><p>对指针int* p = a, 则sizeof(p) = 4。</p></li><li><p>当数组通过函数的参数进行传递时，数组就自动退化为同类型的指针。因此对于函数中的数组参数sizeof，结果也是4。</p></li></ul><h6 id="数组中重复元素"><a href="#数组中重复元素" class="headerlink" title="数组中重复元素"></a><strong>数组中重复元素</strong></h6><blockquote><p>n个整数，a[i]∈[0,n-1]，a中有重复的数字，也不知道重复了几次，有几个数字重复，求所有的重复数字。</p></blockquote><ol><li>a[5] = 3, 则另a[3] = n+a[3]，判断a[3] 是否&gt;2n，如果大于2n，说明已重复；</li><li>a[1] = 3，a[3]=2，a[8]=1，则另a[1]与a[3]交换，再a[1]与a[8]换，直到a[i]=i，如果在交换的过程中发现，a[i]已经等于i了，那么i重复了。</li></ol><p>上述，时间复杂度为O(n)，空间复杂度O(1)。</p><p>如果不能修改数组呢？</p><ul><li><p>二分（需要自己写一下）</p><p>长度为8的数组{2,3,5,4,3,2,6,7}，从中间数字4，分为1-4，5-7，那么先判断1~4的数字一共出现了几次，不难发现是5次，那么一定有重复的数字……</p><p>这种方法不可保证能找到所有重复的数字。</p></li></ul><h6 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h6><blockquote><p>在一个二维数组中，每一行都按照从左到右递增，每一列从上到下递增。</p><p>输入这样的二维数组，判断该数组中是否含有某一整数。</p></blockquote><p>思路：从右上角判断，剔除一列、一行，缩小范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curi,curj;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        n=matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        curi=<span class="number">0</span>;</span><br><span class="line">        curj=m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((!flag)&amp;&amp;curi&lt;n&amp;&amp;curj&lt;m&amp;&amp;curi&gt;=<span class="number">0</span>&amp;&amp;curj&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[curi][curj]&gt;target)</span><br><span class="line">                curj=curj<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[curi][curj]&lt;target)</span><br><span class="line">                curi=curi+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><h6 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s2[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* s3=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* s4=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//判断s1与s2，s3与s4是否相同</span></span><br></pre></td></tr></table></figure><h6 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h6><blockquote><p>将字符串中每个空格替换成”%20”</p></blockquote><p>思考：提前申请空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1,p2;</span><br><span class="line">        p1=s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=p1;i++) <span class="comment">//这里也可以for(char/auto c : s) if(c==&#x27; &#x27;) ..</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        p2=p1+<span class="number">2</span>*cnt;</span><br><span class="line">        s+=<span class="built_in">string</span>(cnt*<span class="number">2</span>,<span class="string">&#x27; &#x27;</span>); <span class="comment">// 或者直接用char* c=new char[],然后s=string(c)</span></span><br><span class="line">        <span class="comment">// s.resize(p1+2*cnt);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p1;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[p2--]=s[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[p2--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[p2--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[p2--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5. 链表"></a>5. 链表</h2><br><h2 id="6-树"><a href="#6-树" class="headerlink" title="6. 树"></a>6. 树</h2><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>先序遍历、中序遍历、后序遍历、层次遍历</p><h6 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h6><blockquote><p>输入二叉树的前序、中序遍历的结果，重建该二叉树。假设输入的遍历结果中都不含重复的数字。</p></blockquote><p>思路：先序中取得根节点，在中序中查找根节点，左边的是左子树，右边的是右子树，递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMe</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==cur)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* tree = <span class="keyword">new</span> TreeNode(preorder[cur]);</span><br><span class="line">        <span class="keyword">int</span> x = getMe(inorder,preorder[cur],l,r);</span><br><span class="line">        tree-&gt;left = solve(preorder,inorder,l,x<span class="number">-1</span>,cur+<span class="number">1</span>);</span><br><span class="line">        tree-&gt;right = solve(preorder,inorder,x+<span class="number">1</span>,r,cur+<span class="number">1</span>+x-l);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=preorder.size();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> solve(preorder,inorder,<span class="number">0</span>,size<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="二叉树的下一个节点"><a href="#二叉树的下一个节点" class="headerlink" title="二叉树的下一个节点"></a>二叉树的下一个节点</h6><blockquote><p>给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了两个左右子树的指针，还有一个父节点指针。</p></blockquote><p>讲一下思路，这里的思路就是分类讨论：</p><table><thead><tr><th align="left">类型</th><th align="left">做法</th></tr></thead><tbody><tr><td align="left">存在右子节点</td><td align="left">找到右子节点的最左节点</td></tr><tr><td align="left">不存在右子节点，是父节点的左子节点</td><td align="left">父节点</td></tr><tr><td align="left">不存在右子节点，是父节点的右子节点</td><td align="left">向上寻找，直到找到一个点是父节点的左子节点</td></tr></tbody></table><h6 id="中序遍历二叉树（递归与非递归）"><a href="#中序遍历二叉树（递归与非递归）" class="headerlink" title="中序遍历二叉树（递归与非递归）"></a>中序遍历二叉树（递归与非递归）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse_solve</span><span class="params">(TreeNode* p,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurse_solve(p-&gt;left,vv);</span><br><span class="line">        vv.push_back(p-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">            recurse_solve(p-&gt;right,vv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stack_solve</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vv)</span></span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;myst;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>||!myst.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                myst.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=myst.top();</span><br><span class="line">                myst.pop();</span><br><span class="line">                vv.push_back(p-&gt;val);</span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vv;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> vv;</span><br><span class="line">        stack_solve(root,vv);</span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h5><p>O(logn)</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><blockquote><p>把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶子节点的最长路径的长度不超过最短路径的两倍。</p><p>在C++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。</p></blockquote><br><h2 id="7-栈和队列"><a href="#7-栈和队列" class="headerlink" title="7. 栈和队列"></a>7. 栈和队列</h2><h6 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">略</span><br></pre></td></tr></table></figure><h6 id="求斐波那契数列n项"><a href="#求斐波那契数列n项" class="headerlink" title="求斐波那契数列n项"></a>求斐波那契数列n项</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> eMarix[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>))%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">normal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last1=<span class="number">0</span>,last2=<span class="number">1</span>,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = last2;</span><br><span class="line">            last2 = (last1+last2)%MOD;</span><br><span class="line">            last1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">marix_solve</span><span class="params">(<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>],<span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">2</span>])</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">2</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp[i][j]+=<span class="number">1l</span>l*a[i][k]*b[k][j]%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[i][j]%=MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">                a[i][j]=temp[i][j];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">marix</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0,1,1,2,3,5,8</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curMarix[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">                marix_solve(curMarix,eMarix);</span><br><span class="line">            marix_solve(eMarix,eMarix);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curMarix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marix(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>$$ {矩阵快速幂}<br>\begin{bmatrix}f(n) &amp; f(n-1) \ f(n-1) &amp; f(n-2)\ \end{bmatrix}<br>=<br>\begin{bmatrix}1 &amp; 1 \ 1 &amp; 0 \end{bmatrix}^{n-1}<br>$$</p><h2 id="8-查找和排序"><a href="#8-查找和排序" class="headerlink" title="8. 查找和排序"></a>8. 查找和排序</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求非降序范围内第一个不小于value的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid,l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>[mid]&lt;value) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;<span class="comment">//or return r;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stl </span></span><br><span class="line">lower_bound(a,a+n,value)-a <span class="comment">// 第一个不小于value的位置</span></span><br><span class="line">upper_bound(a,a+n,value)-a <span class="comment">// 第一个大于value的位置</span></span><br></pre></td></tr></table></figure><h6 id="旋转数组的最小数"><a href="#旋转数组的最小数" class="headerlink" title="旋转数组的最小数"></a>旋转数组的最小数</h6><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=numbers.size();</span><br><span class="line">        <span class="keyword">int</span> mid,l=<span class="number">0</span>,r=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) <span class="comment">// 如果当前值要比最后的值小，说明要往前找（包括本身）；如果当前值要比最后的值大，说明要往后找，还没到；如果相等，有可能还在前面（包括本身：1 3 3/5 4 4）……</span></span><br><span class="line">        &#123;</span><br><span class="line">            mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&lt;numbers[r])</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[r])</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(numbers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交换数字"><a href="#交换数字" class="headerlink" title="交换数字"></a>交换数字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能对int 和 char</span></span><br><span class="line">x=x^y; </span><br><span class="line">y=x^y;</span><br><span class="line">x=x^y;</span><br><span class="line"></span><br><span class="line">x=x+y;</span><br><span class="line">y=x-y;</span><br><span class="line">x=x-y;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一边看书一边刷题&lt;/p&gt;
    
    </summary>
    
      <category term="目标" scheme="http://github.com/xxq1999/categories/%E7%9B%AE%E6%A0%87/"/>
    
    
  </entry>
  
  <entry>
    <title>研一下-&gt;暑期目标</title>
    <link href="http://github.com/xxq1999/2021/04/09/%E6%AF%8F%E6%97%A5%E5%AE%89%E6%8E%92/"/>
    <id>http://github.com/xxq1999/2021/04/09/每日安排/</id>
    <published>2021-04-09T03:13:00.000Z</published>
    <updated>2021-04-09T04:29:42.310Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><ul><li><p>总目标：找到实习</p></li><li><p>每日任务</p><ul><li>刷题</li><li>基础知识补足</li><li>拿出两个小时看论文+笔记</li></ul></li><li><p>思路</p><p>要么睡前看论文，要么起床后看</p><p>刷题LeetCode 剑指offer100题</p><p>基础知识：计网、操作系统、基础的数据结构、c++基础、linux知识</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;总目标：找到实习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每日任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷题&lt;/li&gt;
&lt;li&gt;基础知识补足&lt;/li&gt;
&lt;li&gt;拿出两个小时
      
    
    </summary>
    
      <category term="目标" scheme="http://github.com/xxq1999/categories/%E7%9B%AE%E6%A0%87/"/>
    
    
  </entry>
  
  <entry>
    <title>幻象波普星</title>
    <link href="http://github.com/xxq1999/2020/09/16/%E8%B5%84%E6%BA%90/"/>
    <id>http://github.com/xxq1999/2020/09/16/资源/</id>
    <published>2020-09-16T04:34:00.000Z</published>
    <updated>2020-09-16T07:52:27.227Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="音乐区"><a href="#音乐区" class="headerlink" title="音乐区"></a>音乐区</h2><ul><li>《还愿》游戏原声带压缩包  <a href="https://pan.baidu.com/s/1QNMD75Z28f3BJm-4MrTedQ" title="《还愿》">百度网盘 提取码: 9m7x</a></li></ul><h2 id="书籍区"><a href="#书籍区" class="headerlink" title="书籍区"></a>书籍区</h2><ul><li><p>《迷茫的旅行商：一个无处不在的计算机算法问题》<a href="https://pan.baidu.com/s/1BQpElAkrS1XfGQAwDmhoIQ" title="l旅行商问题">百度网盘 提取码：tix6 </a></p></li><li><p>《三体》（epub格式）<a href="https://pan.baidu.com/s/1WJo_8nG2cqLilXdOgSQxQQ">百度网盘 提取码：zch6</a> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;音乐区&quot;&gt;&lt;a href=&quot;#音乐区&quot; class=&quot;headerlink&quot; title=&quot;音乐区&quot;&gt;&lt;/a&gt;音乐区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;《还愿》游戏原声带压
      
    
    </summary>
    
      <category term="资源" scheme="http://github.com/xxq1999/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="音乐" scheme="http://github.com/xxq1999/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="下载" scheme="http://github.com/xxq1999/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>把苦难也熬成绿豆汤</title>
    <link href="http://github.com/xxq1999/2020/05/18/%E8%80%83%E7%A0%94/"/>
    <id>http://github.com/xxq1999/2020/05/18/考研/</id>
    <published>2020-05-18T13:18:00.000Z</published>
    <updated>2020-12-19T06:40:04.791Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=516358164&auto=0&height=66"></iframe><p>什么时候能说明白自己心里的感受呢？</p><h2 id="得过且过汤"><a href="#得过且过汤" class="headerlink" title="得过且过汤"></a>得过且过汤</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚踏入二零二零年的时候，谁都没有想到接下来的几个月会这样过去。我对此感到不可思议，因为我常常思考的一个问题总是，“为什么是我呢”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;奶奶说，我们晓青今年22岁，就是人生中会遇到坎的时候。大四，并不顺利的毕业设计，不上不下的初试成绩，divorce，急性肠胃炎，虚弱乏力，整日熬夜，昼夜颠倒……发胖，death。virus又好像让全世界的人都一起陪我倒霉。对啊，为什么呢？为什么这样一切都偏巧赶在一块儿了呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不知道，此刻的我既唯物，又唯心，还是个主观唯心。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样一段时间，我陷入焦虑和压抑，常常喜欢逃避。抓住一切可以出门的机会，去找他，去外边，离我的电脑越远越好，我不要想起这些东西，不要提起。我甚至开始恐惧，我怕如果考上了研究生，生活会更糟糕，于是我放弃了复试准备，我开始报名事业编制，一边询问身边所有人企图得到认同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放弃，听起来很可惜吧？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是消极成了全部。我真的很想要一碗汤，喝了这汤，一睡三天，只求结果，不问过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>幸好，没有这汤，夏天也会来的。</strong></p><h2 id="一个既幸运又幸福的家伙"><a href="#一个既幸运又幸福的家伙" class="headerlink" title="一个既幸运又幸福的家伙"></a>一个既幸运又幸福的家伙</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得自己很倒霉。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种倒霉就是每次做选择的时候，总能挑到最糟糕的那个。有的人就相反，运气总是很好。老实说我很嫉妒，并且无能为力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……可我好像也蛮幸运的。在关键时刻上，常常以为自己不行了，结果却出人意料。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于幸福，真的，平时感觉不到。唯有遇到苦难，才能在退出来之后，发现，哦，<strong>我原来是幸福的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就比如现在。</p><h2 id="MYSTERY-OF-LOVE"><a href="#MYSTERY-OF-LOVE" class="headerlink" title="MYSTERY OF LOVE"></a>MYSTERY OF LOVE</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我记得有一天我就躺在床上，然后阳台的门半开着，但是外面是阴天。我打开网易云，mystery of love，轻快明亮的曼陀铃，舒肤佳的声音唱着，我看着天花板，单曲循环一整个下午，然后阳光居然透过了云层中最薄的地方，照在了窗帘上……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也没有什么特别的，只是当时特别安静，想起前一天晚上刚闹过脾气，听过家人朋友的安慰，告诉我没关系，很担心自己。哎，再难也就这样吧，我想，也没什么大不了的，对吧？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;房间里变得有点热热的，我换上了裙子，哦，穿不下了，不过没问题，他们不会嫌弃我的。<strong>裙子，裤子，其实都一样的，两个选择而已。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那天我发了这样的一条心情：</p><blockquote><p>Mystery of Love<br>无论第几次听都会被惊艳到<br>无论现在是什么季节天上有几朵乌云<br>我好像就能从这间小小的，阴阴的屋子里看到了<br>那片森林，瀑布，草地，溪流，山脉，土壤……<br>生机勃勃的绿色从心底长出来了<br>空气变得热腾腾<br>喷泉无力的在暴晒下工作着<br>冰凉的 泳池的水<br>皮肤就要黏糊糊的了<br>眯缝着眼睛<br>和你分享一半的雪糕</p><p>……</p><p>阳光透过了黄色带花的窗帘<br>不用想象，夏天已经来了 </p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，其实跟这首歌没关系，我知道夏天已经来了。</p><br><img src="https://xheartbeat.top/mdpicture/2020051802.jpg" alt="光">]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;8
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>承诺</title>
    <link href="http://github.com/xxq1999/2020/01/18/%E6%89%BF%E8%AF%BA/"/>
    <id>http://github.com/xxq1999/2020/01/18/承诺/</id>
    <published>2020-01-18T14:11:00.000Z</published>
    <updated>2020-12-19T06:43:23.326Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 记得 "> <label for="pass"> 记得 </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19NR4EK0kCKl9/bpb3XFa16vJpfUzAee/9ZrA3bfqVnaAWyZWavZ/Bu4bAs4+I8eOAI9JskMeHhknQ4PAOVoqLvqbtYOeASpTzHuEVc3QfKNWWQ3kOlxWD5kmR/6XLS6LssbzMPeISxSWv5qvD3EaxPqRBLAuUCCcs7MRnCrfruCFDAQYf9b7zyRIpt47r62GmDJJE1ZFhfDezcJHqunpNqoRuBULpe69fxeeV1/ncGcum6NzPibMEvISXNAP27I/jdhZNPaXYMo8ANoMFSjLyana45x4JPUCQKG746FDGWZt8CQ9XpgMl75ji9tKPkqQRAgsvvQFp/Xprv0zovYlJZ/Rp8v21MpbmxrFxbHGxTdOw1Tqrx3URw </div>]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How many integers can you find（容斥裸）</title>
    <link href="http://github.com/xxq1999/2018/09/08/How-many-integers-can-you-find%EF%BC%88%E5%AE%B9%E6%96%A5%E8%A3%B8%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/09/08/How-many-integers-can-you-find（容斥裸）/</id>
    <published>2018-09-08T02:09:00.000Z</published>
    <updated>2020-09-16T04:56:59.171Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="How-many-integers-can-you-find"><a href="#How-many-integers-can-you-find" class="headerlink" title="How many integers can you find"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1796">How many integers can you find</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个n，一个长度为m的集合，集合里面有m个元素，问小于n的所有能被集合中任意元素整除的数字有多少。</p><p>n&lt;2^31,m&lt;=10</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//欧几里得算法，求最大公约数。</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> GCD(b, a % b); <span class="comment">//辗转相除。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//求最小公倍数。</span></span><br><span class="line">    <span class="keyword">return</span> a / GCD(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//深度优先搜索实现容斥原理。</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> Cnt_Manifold; <span class="comment">//遍历到的数的数量（数集的数量）。</span></span><br><span class="line">    <span class="keyword">int</span> Least_Common_Multiple; <span class="comment">//遍历到的Cnt_Manifold个数的最小公倍数。</span></span><br><span class="line">    Result = <span class="number">0</span>; <span class="comment">//记录每次深度搜索的结果。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123; <span class="comment">//i的二进制位代表此次遍历查找的是那几个数</span></span><br><span class="line">        Cnt_Manifold = <span class="number">0</span>;</span><br><span class="line">        Least_Common_Multiple = <span class="number">1</span>; <span class="comment">//1与任何数的最小公倍数还是那个数本身，所以初值赋为1.</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123; <span class="comment">//筛选出要找的数并求出他们的最小公倍数。</span></span><br><span class="line">                Cnt_Manifold++;</span><br><span class="line">                Least_Common_Multiple = LCM(Least_Common_Multiple, p[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (Cnt_Manifold &amp; <span class="number">1</span>) &#123; <span class="comment">//奇数个为正偶数个为负，其作用相当于(-1)^(n - 1).</span></span><br><span class="line">            Result += n / Least_Common_Multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Result -= n / Least_Common_Multiple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp; <span class="comment">//去除了0的情况</span></span><br><span class="line">            <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">                p[cnt++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m = cnt;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Solve(n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;How-many-integers-can-you-find&quot;&gt;&lt;a href=&quot;#How-many-integers-can-you-find&quot; class=&quot;h
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="容斥" scheme="http://github.com/xxq1999/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>容斥与鸽巢定理</title>
    <link href="http://github.com/xxq1999/2018/08/31/%E5%AE%B9%E6%96%A5%E4%B8%8E%E9%B8%BD%E5%B7%A2%E5%AE%9A%E7%90%86/"/>
    <id>http://github.com/xxq1999/2018/08/31/容斥与鸽巢定理/</id>
    <published>2018-08-31T04:44:00.000Z</published>
    <updated>2020-12-19T06:49:09.473Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$<br>|A_1∪A_2∪…∪A_n|=\sum_{i=1}^n|A_i|-\sum_{i=1}^n\sum_{j&gt;i}|A_i∩A_j|+\sum_{i=1}^n\sum_{j&gt;i}\sum_{k&gt;j}|A_i∩A_j∩A_k|+…<br>$$</p><p>$$<br>+(-1)^{n-1}|A_1∩A_2∩…∩A_n|<br>$$</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h3><p><a href="http://xheartbeat.top/2018/08/14/%E9%94%99%E6%8E%92%EF%BC%88%E5%85%AC%E5%BC%8F+%E4%B8%89%E7%A7%8D%E7%94%9F%E6%88%90%EF%BC%89/">【已写】</a></p><h3 id="棋盘多项式与有禁区的排列"><a href="#棋盘多项式与有禁区的排列" class="headerlink" title="棋盘多项式与有禁区的排列"></a>棋盘多项式与有禁区的排列</h3><h4 id="布棋问题"><a href="#布棋问题" class="headerlink" title="布棋问题"></a>布棋问题</h4><p>一个n*m棋盘上放k个棋子，其中任意两个棋子不能位于同一行或者同一列上。问种数。</p><p><strong>布棋方案数</strong> $R_k(C)$ <strong>:</strong> k个棋子依照上述规则放在棋盘C中的方案数</p><p><strong>棋盘多项式：</strong> 棋盘C中放不限定数量的棋子,$R(C)=\sum_{k=0}^∞R_k(C)x^k$（有点母函数的味道），由于k&lt;=C(格子数)，因此这个多项式也是有限的。</p><p><strong>放置：</strong>  $R_k(C)=R_{k-1}(C_x)+R_k(C_e)$</p><p>C表示这个棋盘，$C_x$表示放在棋盘C除去这个格子所在的行和列之后的棋盘，$C_e$表示棋盘C删去这个格子后的棋盘。<br>那么这个公式的意思就是，在棋盘C上放k个棋子的种数，等于（第k个棋子放在一个格子上，前k-1个数量的格子放在除了这个格子所在的行和列的地方），加上，（k个棋子放在除了这个格子的其他地方）。</p><p><strong>棋盘多项式性质：</strong></p><ol><li>$R(C)=xR(C_x)+R(C_e)$</li><li>若C由两个互不干扰的棋盘组成，有$R(C)=R(C_1)·R(C_2)$</li></ol><img src="https://xheartbeat.top/mdpicture/%E7%A6%81%E5%8C%BA%E6%A3%8B%E7%9B%98%E6%8E%92%E5%88%97%E5%AE%9E%E4%BE%8B.jpg" height="635" width="413" alt="棋盘排列构造多项式，利棋盘多项式的性质，如图"><h4 id="有禁区的排列"><a href="#有禁区的排列" class="headerlink" title="有禁区的排列"></a>有禁区的排列</h4><p><strong>排列数定理：</strong><br>$$<br>n！-r_1(n-1)!+r_2(n-2)!-…±r_n<br>$$<br>$r_i$表示有$r_i$个棋子布置到禁区的方案数。（**<em>仅适用n·n的棋盘**</em>）</p><p><strong>&lt; 例题 &gt;</strong> 有1,2,3,4号工人，A,B,C,D四个人物，1号不做B，2号不做B、C，3号不做C、D，4号不做D，问有多少种分配方式？</p><p>【解】先构造一个4*4的棋盘，然后画出这个棋盘的禁区，对于这个禁区计算它的棋盘多项式，得$R(C)=1+6x+10x^2+4x^3$，因此用容斥的思想，得到：<br>$$<br>4!- 6·(4-1)!+10·(4-2)!-4·(4-3)! +0(4-4)!= 4<br>$$</p><img src="https://xheartbeat.top/mdpicture/%E7%A6%81%E5%8C%BA%E6%A3%8B%E7%9B%98%E4%BE%8B%E9%A2%98.jpg" height="123" width="296" alt="例题棋盘禁区如图所示，构造的多项式原理同上图"><h1 id="鸽巢定理"><a href="#鸽巢定理" class="headerlink" title="鸽巢定理"></a>鸽巢定理</h1><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>n+1只鸽子飞回n个鸽巢，至少有一个鸽笼含有不少于2只的格子。</strong></p><p><strong>数学描述：</strong></p><p><strong>m($1\le m$)个元素分成n个组，那么总有一个组至少含有元素个数$\lceil\frac{m}{n}\rceil$</strong></p><h2 id="小应用"><a href="#小应用" class="headerlink" title="小应用"></a>小应用</h2><ol><li><p><strong>对于正整数序列，$a_1，a_2，…，a_m$，至少存在整数k和l, $1\le k&lt;l\le m$，使得$a_k+a_{k+1}+…+a_l$是m的倍数。</strong></p><p>【证明】对每个元素$a_i$构造一个前缀和sum[i]，则有两种可能性：</p><p>(1) 若有一个sum[i]是m的倍数，则证毕；</p><p>(2) 若没有一个sum[i]为m的倍数，则令$r_h\equiv S_h mod\ m $ 。    </p><p>其中，h=1,2,…,m，我们已知上面所有的项都非m的倍数，故余数r[i]的范围在[1,m-1]，共m个数，根据鸽巢定理，m个余数在[1,m-1]共m-1的范围内至少存在一对$r_h$,$r_k$，满足$r_k=r_h$,则sum[k]和sum[h]满足：<br>$$<br>S_k\equiv S_h mod \ m<br>$$<br>设h&gt;k的话，得到<br>$$<br>S_h-S_k=(a_1+a_2+…+a_h)-(a_1+a_2+…+a_k)<br>=a_{k+1}+…+a_h\equiv 0\ mod \ m<br>$$<br>证毕。</p></li><li><p><strong>中国剩余定理</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;容斥&quot;&gt;&lt;a href=&quot;#容斥&quot; class=&quot;headerlink&quot; title=&quot;容斥&quot;&gt;&lt;/a&gt;容斥&lt;/h1&gt;&lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习" scheme="http://github.com/xxq1999/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GCD?LCM!(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/20/GCDLCM!(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/20/GCDLCM!(莫比乌斯反演)/</id>
    <published>2018-08-20T15:17:00.000Z</published>
    <updated>2020-09-16T04:56:24.198Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="GCD-LCM"><a href="#GCD-LCM" class="headerlink" title=" GCD?LCM!"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382"> GCD?LCM!</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>哈哈哈哈哈懵逼钨丝做的我一本满足，爽歪歪，推公式好塔马有趣儿</p><p>咳咳，题目是：<br>$$<br>F(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n]<br>$$</p><p>$$<br>S(n)=\sum_{i=1}^nF(n)<br>$$</p><p>t组，每组给你一个n，求S(n)。</p><p>t&lt;=1e5,n&lt;=1e6</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$<br>F(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n]<br>$$</p><p>$$<br>=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n-1]-\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p><code>由于对于后半部分来说，i，j=n时显然不符合，因此可直接降为n-1</code><br>$$<br>=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n-1]-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$<br><code>将前半部分转化成F(n-1)，故修改i，j的上限，而i，j=n时一定满足要求，因此要补上2n-1</code><br>$$<br>=\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)\ge n-1]+(2n-1)-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p>$$<br>=F(n-1)+(2n-1)-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p><code>令后半部分为T(n-1),则：</code><br>$$<br>F(n)=F(n-1)+(2n-1)-T(n-1)<br>$$<br>接下来分析T(n)<br>$$<br>T(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n]<br>$$<br>令d=gcd(i,j)，又由于lcm(i,j)=ij*(gcd(i,j))，令i=id，j=jd<br>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}<br>[ijd+d==n][gcd(i,j)==1]<br>$$</p><p>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}<br>[j=\frac{\frac{n}{d}-1}{i}][gcd(i,j)==1]<br>$$</p><p>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}<br>[gcd(i,\frac{\frac{n}{d}-1}{i})==1]<br>$$</p><p>由于$\ i = \frac{n}{d}$ 时，条件显然不成立，因此修改i的上限<br>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor-1}<br>[gcd(i,\frac{\frac{n}{d}-1}{i})==1]<br>$$<br>令后半部分为$ G(\frac{n}{d}-1) $<br>$$<br>T(n)=\sum_{d|n}G(\frac{n}{d}-1)<br>$$<br>接下来分析G(n)<br>$$<br>G(n)=\sum_{i=1}^n[gcd(i,\frac{n}{i})==1]<br>$$<br>要满足后半部分，我们打表（或者根据思考（？？？））发现<br>$$<br>G(n)=2^k,k为n的质因子个数<br>$$<br>那么到这里，基本上要推的就都推完了，</p><p>差一个总和。</p><p>由于：<br>$$<br>F(n)=F(n-1)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>=F(n-2)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>=F(n-3)+(2(n-2)-1)-T(n-3)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>……<br>$$</p><p>$$<br>=F(1)+\sum_{i=1}^n(2i-1)-\sum_{i=0}^{n-1}T(i)<br>$$</p><p>故：<br>$$<br>S(n)=\sum_{i=1}^n(F(1)+\sum_{j=1}^i(2j-1)-\sum_{j=0}^{i-1}T(j))<br>$$</p><p>$$<br>S(n)=nF(1)+\sum_{i=1}^ni^2-\sum_{i=1}^n\sum_{j=0}^{i-1}T(i)<br>$$</p><p>$$<br>=n+\frac{n(n+1)(2n+1)}{6}-\sum_{i=1}^n\sum_{j=0}^{i-1}T(i)<br>$$</p><p>我们一步一步来：</p><ol><li>预处理，先筛出所有质数，然后是1~1e6的质因子个数，然后求得G(n)，再求得T(n)，然后对T(n)求一次前缀和得到每个sum[i]，再对每个sum[i]求前缀和ans[i]=sum[i-1]+ans[i-1]。</li><li>没有2了，对于每个输入的n直接用刚刚最后那个公式带进去算就好了：</li></ol><p>$$<br>S(n)=n+\frac{n(n+1)(2n+1)}{6}-ans[n]<br>$$</p><p>哦，别忘了取模。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">258280327</span>;</span><br><span class="line"><span class="comment">/** 对于μ函数的线筛 */</span></span><br><span class="line"><span class="keyword">int</span> prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll sum[N]=&#123;<span class="number">0</span>&#125;,ans[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll liu;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">PowerMod</span><span class="params">(ll x,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    res=res*x;</span><br><span class="line">    res=res%MOD;</span><br><span class="line">   &#125;</span><br><span class="line">   x=x*x;</span><br><span class="line">   x=x%MOD;</span><br><span class="line">   n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i++) <span class="comment">//素数筛</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)prim[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prim[j]&lt;N;j++)</span><br><span class="line">            vis[i*prim[j]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=N;n++) <span class="comment">//求质因子个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=n;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;prim[i]*prim[i]&lt;=tmp; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp%prim[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p[n]++;</span><br><span class="line">                <span class="keyword">while</span>(tmp%prim[i]==<span class="number">0</span>) tmp/=prim[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">            p[n]++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)  <span class="comment">//求2^k</span></span><br><span class="line">        p[i]=PowerMod(<span class="number">2</span>,p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=N;d++)  <span class="comment">//  求T(n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d&lt;=N;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[k*d]=(sum[k*d]+p[k<span class="number">-1</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="comment">//求sum[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=(sum[i]+sum[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="comment">//求ans[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]=(sum[i<span class="number">-1</span>]+ans[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*(n+<span class="number">1</span>)%MOD*(<span class="number">2</span>*n+<span class="number">1</span>)%MOD*liu%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    liu=PowerMod(<span class="number">6</span>,MOD<span class="number">-2</span>);</span><br><span class="line">    Solve(<span class="number">1000000</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(cal(n)+n-ans[n]+MOD)%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;GCD-LCM&quot;&gt;&lt;a href=&quot;#GCD-LCM&quot; class=&quot;headerlink&quot; title=&quot; GCD?LCM!&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>带劲and和（连通块+&amp;结论）</title>
    <link href="http://github.com/xxq1999/2018/08/20/%E5%B8%A6%E5%8A%B2and%E5%92%8C%EF%BC%88%E8%BF%9E%E9%80%9A%E5%9D%97+&amp;%E7%BB%93%E8%AE%BA%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/20/带劲and和（连通块+&amp;结论）/</id>
    <published>2018-08-19T17:42:00.000Z</published>
    <updated>2020-09-16T04:56:02.824Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="带劲的and和"><a href="#带劲的and和" class="headerlink" title="带劲的and和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6411">带劲的and和</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>度度熊有一张n个点m条边的<strong>无向图</strong>，第i个点的点权为vi。<br>如果图上存在一条<strong>路径</strong>使得点i可以走到点j，则称i,j是<strong>带劲</strong>的，记f(i,j)=1；否则f(i,j)=0。显然有f(i,j)=f(j,i)。<br>度度熊想知道求出：<br>$\sum_{i=1}^{n−1}\sum_{j=i+1}^nf(i,j)×max(v_i,v_j)×(v_i&amp;v_j)$<br>其中&amp;是C++中的and位运算符，如1&amp;3=1, 2&amp;3=2。<br>请将答案对109+7取模后输出。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先处理连通块。</p><p>这里我用的是并查集，也可以用tarjan，然后对于每个连通块里的元素，我们按照从小到大排序。</p><p>由于比如 9 8 7 这部分时，默认我们已经知道9是最大的元素，那么一定是9*(9&amp;8+9&amp;7),由于与运算是只有两位上的数字均为1时才能有贡献，那么也就是说，我们不需要对于每两个数字都计算&amp;运算，而可以对每一个数字的二进制位进行处理，当第i位上为1时，count[i]++，只有count[i]上的数&gt;=2时，才算对于这个有了贡献，并且我们是用同一的9去进行与运算，在count位&gt;=2时，也只有满足当9上的第i位也为1时才算数。</p><p>因此从小到达排序之后，从第一个元素开始，在它前面的元素一定比它小，因此我们只要对于这个元素上为1的位进行查询，看它的count是否大于等于2，然后确定是否产生贡献，ans+了后再把当前元素的这一位的count[i]++即可。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">///找跟根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=id[x])</span><br><span class="line">    &#123;</span><br><span class="line">        id[x]=id[id[x]];</span><br><span class="line">        x=id[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pr=Find(p);</span><br><span class="line">    <span class="keyword">int</span> qr=Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pr==qr) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[pr]&lt;=sz[qr])</span><br><span class="line">    &#123;</span><br><span class="line">        sz[qr]+=sz[pr];id[pr]=qr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz[pr]+=sz[qr];id[qr]=pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;fa[<span class="number">100010</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            un(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[Find(i)].push_back(val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            len=fa[i].size();</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sort(fa[i].begin(),fa[i].end());</span><br><span class="line">                <span class="keyword">int</span> wei[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> tmp=fa[i][j];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">30</span>&amp;&amp;tmp&gt;<span class="number">0</span>;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans=(ans+<span class="number">1l</span>l*wei[k]*fa[i][j]%MOD*(<span class="number">1</span>&lt;&lt;k)%MOD)%MOD;</span><br><span class="line">                            wei[k]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;带劲的and和&quot;&gt;&lt;a href=&quot;#带劲的and和&quot; class=&quot;headerlink&quot; title=&quot;带劲的and和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http:/
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Mophues(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/20/Mophues(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/20/Mophues(莫比乌斯反演)/</id>
    <published>2018-08-19T17:09:00.000Z</published>
    <updated>2020-09-16T04:55:49.654Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Mophues"><a href="#Mophues" class="headerlink" title="  Mophues"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4746">  Mophues</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>若a的质因子个数&lt;=P，则称a为p的一个lucky number。</p><p>给你n，m，P，求在n，m范围内的i，j，gcd(i,j)是P的lucky number，这样的i，j有几对？</p><p>n，m，P&lt;=5e5。多组不超过5000组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意就是让我们求：<br>$$<br>\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j)),其中f(x)表示x的质因子个数比p小<br>$$<br>反演过程就不具体写了，我们可以轻松得到结果：<br>$$<br>\sum_{t=1}^{min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d|t}f(d)μ(\frac{t}{d})<br>$$<br>经过计算我们发现，5e5内的数字最大的质因数个数为18，那么对于大于18的p我们就可以降为18。</p><p>首先对5e5内的数预处理出它们的质因子个数。</p><p>然后枚举d，用sum[i][j]表示当t=i时，质因子个数为j的数的μ之和。</p><p>再对sum[i][j]求t=i时质因子个数小于等于j的μ之和。</p><p>然后对每一个t的sum求一个前缀和。</p><p>就可以分块做了。</p><p>注意ans和sum还是要开longlong。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/** 对于μ函数的线筛 */</span></span><br><span class="line"><span class="keyword">int</span> mu[N],prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll sum[N][<span class="number">21</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        vis[prim[j]*i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int MAX=0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=N;n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=n;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;prim[i]*prim[i]&lt;=tmp; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp%prim[i]==<span class="number">0</span>) p[n]++,tmp/=prim[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">            p[n]++;  <span class="comment">//这个不可以缺少</span></span><br><span class="line">        <span class="comment">//MAX=max(MAX,p[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=N;d++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d&lt;=N;k++)</span><br><span class="line">            sum[k*d][p[d]]+=mu[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=N;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">            sum[t][i]+=sum[t][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">19</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=N;t++)</span><br><span class="line">            sum[t][i]+=sum[t<span class="number">-1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,u,v;</span><br><span class="line">    get_mu(<span class="number">500000l</span>l);</span><br><span class="line">    Solve(<span class="number">500000l</span>l);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,P;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;P);</span><br><span class="line">        <span class="keyword">if</span>(P&gt;<span class="number">18</span>) P=<span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=MIN;l=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=min(n/(n/l),m/(m/l));</span><br><span class="line">            ans+=<span class="number">1l</span>l*(n/l)*(m/l)*(sum[r][P]-sum[l<span class="number">-1</span>][P]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Mophues&quot;&gt;&lt;a href=&quot;#Mophues&quot; class=&quot;headerlink&quot; title=&quot;  Mophues&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>CA Loves GCD(DP)</title>
    <link href="http://github.com/xxq1999/2018/08/19/CA-Loves-GCD(DP)/"/>
    <id>http://github.com/xxq1999/2018/08/19/CA-Loves-GCD(DP)/</id>
    <published>2018-08-19T15:09:00.000Z</published>
    <updated>2020-09-16T04:55:37.517Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="CA-Loves-GCD"><a href="#CA-Loves-GCD" class="headerlink" title="CA Loves GCD"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5656">CA Loves GCD</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个数，从里面任取几个（至少1个），计算它们的gcd，问你所有可能的取法的gcd之和。</p><p>对结果模1e8+7（注意是8）</p><p>n&lt;=1000</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dp[i][j]表示取前i个数时gcd为j的种数。</p><p>取第i个时：dp[i][gcd(a[i],j)] += dp[i-1][j] ；</p><p>不取第i个时：dp[i][j] += dp[i-1][j]；</p><p>对1000内的任意两个数的gcd作预处理，i从0开始。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> gcd[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="comment">/*int ggcd(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return b == 0 ? a : ggcd(b, a%b);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            gcd[i][j]=__gcd(i,j);</span><br><span class="line">            gcd[j][i]=gcd[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> MAX=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            MAX=max(MAX,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=MAX;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">                dp[i][gcd[a[i]][j]]=(dp[i][gcd[a[i]][j]]+dp[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">            ans=(ans+<span class="number">1l</span>l*dp[n][i]*i)%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;CA-Loves-GCD&quot;&gt;&lt;a href=&quot;#CA-Loves-GCD&quot; class=&quot;headerlink&quot; title=&quot;CA Loves GCD&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="http://github.com/xxq1999/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Hillan and the girl(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/19/Hillan-and-the-girl(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/19/Hillan-and-the-girl(莫比乌斯反演)/</id>
    <published>2018-08-19T10:09:00.000Z</published>
    <updated>2020-09-18T06:23:23.457Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Hillan-and-the-girl"><a href="#Hillan-and-the-girl" class="headerlink" title="Hillan and the girl"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5663">Hillan and the girl</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于1&lt;=n,m&lt;=1e7，T&lt;=1e4，求：<br>$$<br>\sum_{i=1}^{n}\sum_{j=1}^{m}f(gcd(i,j)),其中f(x)=1，当且仅当x为平方数<br>$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>来，让我们来反演一波：<br>$$<br>\sum_{d=1}^{mim(n,m)}f(d)\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)==d]<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)==1]<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{t|gcd(i,j)}μ(t)<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dt}\rfloor}\sum_{t=1}^{min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}μ(t)<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{t=1}^{min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}μ(t){\lfloor\frac{n}{dt}\rfloor}{\lfloor\frac{m}{dt}\rfloor}<br>$$</p><p>令dt=T，则：<br>$$<br>\sum_{T=1}^{min(n,m)}{\lfloor\frac{n}{T}\rfloor}{\lfloor\frac{m}{T}\rfloor\sum_{d|T}f(d)}μ(\frac{T}{d})<br>$$<br>由于$d=x^2$<br>$$<br>\sum_{T=1}^{min(n,m)}{\lfloor\frac{n}{T}\rfloor}{\lfloor\frac{m}{T}\rfloor\sum_{x=1}^{min(\sqrt{n},\sqrt{m})}\sum_{x^2|T}}μ(\frac{T}{x^2})<br>$$<br>对于T的前半部分，我们可以用分块，复杂度为$\sqrt{n}$，对于后半部分，就可以预处理出来。</p><p>枚举x，以及每一个$x^2$的倍数$k·x^2$，处理出每一个T的对应的值，然后再求前缀和。</p><p>预处理部分的复杂度为O(n)，求的时候的复杂度为$O(T\sqrt{n})$。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prim[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d*d&lt;=n;d++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d*d&lt;=n;k++)</span><br><span class="line">            sum[k*d*d]+=mu[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_mu(<span class="number">10000000</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=MIN;l=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=min(n/(n/l),m/(m/l));</span><br><span class="line">            ans+=<span class="number">1l</span>l*(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1l</span>l*n*m-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Hillan-and-the-girl&quot;&gt;&lt;a href=&quot;#Hillan-and-the-girl&quot; class=&quot;headerlink&quot; title=&quot;Hill
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>はなび</title>
    <link href="http://github.com/xxq1999/2018/08/19/%E5%B0%8F%E5%81%B7%E5%AE%B6%E6%97%8F/"/>
    <id>http://github.com/xxq1999/2018/08/19/小偷家族/</id>
    <published>2018-08-18T18:19:00.000Z</published>
    <updated>2020-12-19T06:40:57.024Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><img src="https://xheartbeat.top/mdpicture/海边.jpg" alt="海边"><p>我发现日本的电影或者是电视剧，总是生活的样子，不会把片子的色调调的明亮而饱和，不会把每个人脸上的斑点、皱纹、坑坑洼洼悄悄隐藏，而让坐在荧幕前面的我们只看到光滑的皮肤和胶原蛋白。</p><p>是走在大街上能看到的，二十多岁小姑娘，三四十岁的工厂的妇女，建筑工地上的工人，和蔼的老婆婆，还有那怯生生的孩子。</p><p>是贫穷的屋子里面拥挤的住着五口人，角角落落塞得满满当当。</p><p>是即使辛苦艰难，其中偷偷夹带着的小幸福。</p><p>尽管我从一开始就知道，他们并不是”一家人“。</p><p>尽管我想，要是一直在一起就好啦。</p><p>柴田在废弃的车子中找到不高兴的祥太，告诉他由理是他”妹妹“，你要叫我”爸爸“（祥太一直叫不出口），瘸着腿在路上和祥太玩闹；</p><p>信代和由理泡着澡，由理看见信代手臂上的伤疤，和妈妈用熨斗烫伤自己的伤疤一样，心疼的不停轻轻抚摸着信代受伤的地方，信代说谢谢你，已经一点都不疼啦；</p><p>洗完澡把由理来时的旧衣服烧了，信代紧紧的抱着由理，悲伤的好像要把由理揉进自己的怀抱里。对由理说才不是由理的错，如果有人说爱你才打你，那才不是真的，如果爱你的话，就会像我这样，这样抱着你；</p><p>大家一起看烟花，可是只听得见烟花的声音，却看不到烟花；</p><p>小卖铺的爷爷早就知道祥太总是把东西偷偷顺走，只是当看到由理也学着祥太的样子偷窃，他学着他们偷东西前的手势，告诉祥太，以后不要叫你妹妹这样了，然后送了他们两个果冻，祥太问要继续偷吗，柴田说超市里放着的东西不属于任何人，除非倒闭了；</p><p>大家一起去海边的时候，奶奶对信代说”你真漂亮，脸蛋“，后来信代也跑去和大家玩，然后奶奶一个人坐在沙滩上面，把沙子洒在自己长满老年斑的小腿上，看着这一瞬间的”家人们“，无声的说”谢谢你们“；</p><p>信代为了保住由理，丢了工作，和柴田在家里吃着面，她走去厨房，雷雨前的最后一丝阳光透过窗户落进来，信代穿着透明凉快的衣服，汗水浸湿了头发，浸湿了脸庞，浸湿了胳膊，柴田看呆了，信代亲了柴田，然后终于打雷了，大雨来了，屋子里都是热乎乎，热乎乎的味道。</p><p>但是总会被打破的。</p><p>奶奶在从海边回来后的某天安静的离开了，柴田想打救护车，信代却说，你敢叫救护车吗。殡仪馆火化这么贵。我们哪有钱。由理也想和奶奶一直在一起吧。那我们就一直陪着奶奶吧。于是在自家挖坑把奶奶埋葬了。</p><p>亚纪一直伤心。柴田对祥太说，我们一直是五个人，从来没有奶奶。</p><p>信代取了奶奶的银行卡，找到了奶奶藏起来的钱，和柴田开心的大笑。</p><p>柴田带着祥太砸车偷包，祥太开始不愿意这样做了。</p><p>便利店的爷爷也去世了。祥太带着由理去超市，叫由理在外面等着。由理却跑进来想和哥哥一起偷。祥太看见还这么小的妹妹，笨拙的学着自己，把一包零食塞进自己的衣服里，塑料包装发出响声。他看了一会，在店员面前抢了一带柚子，转身就跑。然后被店员追上，从桥上跳下去。他终于认识到，这样的生活，已经不能再继续下去了。他是故意的呀。</p><p>大家被发现了。想要抛下在医院的祥太逃跑，还是没有成功。</p><p>”你们并不是一家人啊。“</p><p>”奶奶的尸体呢？抛尸可是犯罪啊。“</p><p>”为什么要诱拐孩子呢？“</p><p>”柴田你啊，祥太是你的本名把？“</p><p>”叫孩子偷窃，内心不会愧疚吗？“</p><p>”听说那两个人是杀了前夫呢。“</p><p>”奶奶一直有从你父母那里拿钱哦。“</p><p>”是因为自己生不出孩子，才嫉妒别人，才会诱拐孩子的吧。”</p><p>”树理（由理）的画颜色真好看呀，终于能回家了呢。“</p><p>“祥太你呀，以后就能去学校上学啦。”</p><p>”他们是怎么称呼你的呢？妈妈？母亲？“</p><p>……</p><p>解散了，这样的羁绊。</p><p>道德的制高点，大概看不见渺小的尘埃。</p><p>总会有些疑惑，比如为什么信代失业，柴田却理所当然的说你可以重拾老本行；奶奶死的时候，信代和柴田没有一点难过的样子，没过多久就拿了奶奶的养老金窃喜；为什么明明从前给了祥太这般的慈爱和体贴，却还是决定抛弃他，偷偷溜走。</p><p>柴田追赶着公交车，大声呼喊祥太的名字，车上的祥太却只是向前看，无动于衷。但是末了却转过头，轻声的说了一声”爸爸“。祥太对柴田的爱的认可，是真的，希望自己能够追寻另一种人生，也是真的。</p><p>只是柴田永远听不见这句”爸爸“，就像奶奶在海边说的”谢谢“，就像亚纪一直在从父母那里拿钱的时候，以为奶奶并不是喜欢她，才收留她的，是因为钱，她永远不知道奶奶一分钱没花。我想起她问柴田，维系两个人之间的东西到底是什么？是钱啊。</p><p>是利益吗？让这个家庭组合在一起？</p><p>我想是的，私利是让他们走在一起的原因，是让他们一起生活的原因，是让他们选择彼此的原因。这并不影响我对你的关心。只是这样的选择，比起自己原本的人生，好了太多了。</p><p>私欲是真的，背叛是真的，爱也是真的。</p><p>无法讨论人性，因为无情之中又饱含着万千真情。</p><p>世界并不是完美的乌托邦，也并非地狱的修罗场。</p><p>每个人都有每个人的活法。</p><p>也许我根本没有看懂这部电影，很多人都说看不懂。只是很喜欢这样的电影。我想起自己看《人间失格》电影的时候，开头，一条弹幕：</p><p>”你不需要看懂这部电影，你只要知道，有人这样活着就好了。“</p><blockquote><p>他呈现的不是道德的是非，而是道德的困境。</p><p>他帮你撕掉人们身上的标签，让你看见那一个一个人。那些和你一样，有血有肉，有夜里开着灯等他们回家的亲人。</p><p>他尽力展现生活的复杂，让你看到算计，也看到算计背后的温情，让你了解，体谅，让你珍惜”有点肮脏的世界，忽然变得美好了起来的瞬间。“</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;img src=&quot;https://xheartbeat.top/mdpicture/海边.jpg&quot; alt=&quot;海边&quot;&gt;

&lt;p&gt;我发现日本的电影或者是电视剧，总是生活的样子，不会
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>整数划分(裸五边形定理)</title>
    <link href="http://github.com/xxq1999/2018/08/17/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86(%E8%A3%B8%E4%BA%94%E8%BE%B9%E5%BD%A2%E5%AE%9A%E7%90%86)/"/>
    <id>http://github.com/xxq1999/2018/08/17/整数划分(裸五边形定理)/</id>
    <published>2018-08-16T16:01:00.000Z</published>
    <updated>2020-09-18T06:20:47.031Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="不可重复的数字划分（基础dp）"><a href="#不可重复的数字划分（基础dp）" class="headerlink" title="不可重复的数字划分（基础dp）"></a><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1201">不可重复的数字划分</a>（基础dp）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">350</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  int n,m,cas=1;</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">   <span class="comment">// five();</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*(j+<span class="number">1</span>)&lt;=i*<span class="number">2</span>;j++)</span><br><span class="line">            dp[i][j]=(dp[i-j][j<span class="number">-1</span>]+dp[i-j][j])%MOD;</span><br><span class="line">            <span class="comment">//1.i-j的数，j-1个划分，每个划分数+1，再加上1的划分；2.i-j的数。j个划分，每个划分数+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">350</span>&amp;&amp;dp[n][i]!=<span class="number">0</span>;i++)</span><br><span class="line">            ans=(ans+dp[n][i])%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1259-整数划分-V2"><a href="#1259-整数划分-V2" class="headerlink" title="1259 整数划分 V2"></a><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1259">1259 整数划分 V2</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重复的划分，五边形定理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q[<span class="number">405</span>],f[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">five</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">400</span>;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LL temp=(i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        q[i]=(<span class="number">3</span>*temp*temp-temp)/<span class="number">2</span>;</span><br><span class="line">        q[i+<span class="number">1</span>]=(<span class="number">3</span>*temp*temp+temp)/<span class="number">2</span>;</span><br><span class="line">       <span class="comment">// printf(&quot;%lld,&quot;,q[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,c=<span class="number">1</span>;j&lt;=<span class="number">400</span>;j+=<span class="number">2</span>,c*=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-q[j]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            f[i]=(f[i]+f[i-q[j]]*c+MOD)%MOD;</span><br><span class="line">            <span class="keyword">if</span>(i-q[j+<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            f[i]=(f[i]+f[i-q[j+<span class="number">1</span>]]*c+MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,cas=<span class="number">1</span>;</span><br><span class="line">    LL a;</span><br><span class="line">    five();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;不可重复的数字划分（基础dp）&quot;&gt;&lt;a href=&quot;#不可重复的数字划分（基础dp）&quot; class=&quot;headerlink&quot; title=&quot;不可重复的数字划分（基础
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="http://github.com/xxq1999/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Little Bishops（棋盘禁区排列）</title>
    <link href="http://github.com/xxq1999/2018/08/17/Little-Bishops%EF%BC%88%E6%A3%8B%E7%9B%98%E7%A6%81%E5%8C%BA%E6%8E%92%E5%88%97%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/17/Little-Bishops（棋盘禁区排列）/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2020-09-16T04:54:59.437Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1>[Little Bishops](https://vjudge.net/problem/UVA-861)</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在国际棋盘中，象的走法是斜对角线，也就是说两个象不能容于一条斜对角线。国际象棋有黑白两色格子相交组成。给你n*n的棋盘和k个象，问你在满足任意两个象互不相斥的情况下，摆放的最大种数？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用棋盘禁区排列这一思想。</p><p>首先我们可以看到，在棋盘中，黑色的格子和白色的格子上的象绝对不会相斥，所以我们可以根据$R_k(C)=R_i(C_1)*R_{k-i}(C-C_1)$得，Ans就是在黑色棋盘上放i个象的种类乘以在白色棋盘上放k-i个象的种数。</p><p>为了将黑白棋盘分开，比如要建立一个方便的白色棋盘，斜着看显然不舒服，那么我们就：</p><p>先把黑色格子删去，然后我们斜+45度看这个棋盘，把一斜看做一行，一斜中的格子数就是一行的格子数，同样的，斜-45度就是列中的格子数。又因为每行互换位置并不影响最终结果，因此我们可以把原本对称的棋盘行，进行格数从小到大排序，得到最终的棋盘。</p><p>注意，由于黑白棋盘不一样，对于一个n*n的棋盘来说，斜+45度看一共有2n-1个斜行，因此我们这里让白色棋盘占n行，黑色占n-1行，然后用另外的一个数组来存每行中有多少格子（列），基本的构造棋盘就完成了。</p><p>对于构造出来的棋盘（如白色），分析一下：</p><p>设mp[i][j]表示前i行放j个棋子的种数。那么有<br>$$<br>mp[i][j]=mp[i-1][j]+mp[i-1][j-1]·(c[i]-(j-1))<br>$$<br>相当于=前i-1行放了j个棋子，这一行不放的种数，加上前i-1行放了j-1个棋子乘以这一行只能在（格子数-已经被j-1个象占了的格子数量）个格子。</p><p>对两个棋盘都进行这样的操作即可。</p><p>最后的答案就是$\sum_{i=0}^{k}R_i(C_{white})·R_{k-i}(C_{black})$</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> mp1[<span class="number">10</span>][<span class="number">70</span>],mp2[<span class="number">10</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> c1[<span class="number">10</span>],c2[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>||k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp1,<span class="number">0</span>,<span class="keyword">sizeof</span>(mp1));</span><br><span class="line">        <span class="built_in">memset</span>(mp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(mp2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//白色棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) c1[i]=i;</span><br><span class="line">            <span class="keyword">else</span> c1[i]=c1[i<span class="number">-1</span>]; <span class="comment">//printf(&quot;i:%d\n&quot;,c1[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="comment">//黑色棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) c2[i]=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c2[i]=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            mp1[i][<span class="number">0</span>]=mp2[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            mp1[i][j]=mp1[i<span class="number">-1</span>][j]+mp1[i<span class="number">-1</span>][j<span class="number">-1</span>]*(c1[i]-j+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            mp2[i][j]=mp2[i<span class="number">-1</span>][j]+mp2[i<span class="number">-1</span>][j<span class="number">-1</span>]*(c2[i]-j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">            ans+=<span class="number">1l</span>l*mp1[n][i]*mp2[n<span class="number">-1</span>][k-i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1&gt;[Little Bishops](https://vjudge.net/problem/UVA-861)&lt;/h1&gt;

&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; c
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排列组合" scheme="http://github.com/xxq1999/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Werewolf（缩点）</title>
    <link href="http://github.com/xxq1999/2018/08/16/Werewolf/"/>
    <id>http://github.com/xxq1999/2018/08/16/Werewolf/</id>
    <published>2018-08-16T15:17:00.000Z</published>
    <updated>2020-09-16T04:54:34.932Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Werewolf"><a href="#Werewolf" class="headerlink" title="Werewolf"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6370">Werewolf</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>狼人杀游戏，规定村民不能说假话，狼人可能说假话。</p><p>每一个人可以指认别人（除了自己）是村民或者是狼人。</p><p>根据这些指证，我们可以得出：</p><p>1、x号必为村民；</p><p>2、x号必为狼人；</p><p>3、x号可能是村民也可能是狼人。</p><p>问必为村民的人数和必为狼人的人数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题解的代码比较妙啊……</p><p>首先我们肯定能分析出不可能有必为村民的情况，因为所有人都可能是狼人这样的情况是成立的。</p><p>然后，我们又能发现，只有在环中，只存在一个狼人指证，和至少1个村民指证，那么才能确认其中的某一个人是狼人；</p><p>我们再通过这些确认的狼人，推出其他指证这些狼人为平民的人必为狼人。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[id]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(g[id].v==<span class="number">1</span>) <span class="comment">//我指证别人是村民</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[g[id].to]) <span class="comment">//指证的人没有被访问过，就要先让他过一下</span></span><br><span class="line">        &#123;</span><br><span class="line">            solve(g[id].to);</span><br><span class="line">            <span class="keyword">if</span>(ans[g[id].to]==<span class="number">-1</span>) ans[id]=<span class="number">-1</span>; <span class="comment">//我指证的是铁狼，那么我说了谎，我也是狼</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans[g[id].to]==id) ans[id]=<span class="number">-1</span>; <span class="comment">//我指证的人指证回了我，说明有个环，环中有一个狼人指证，那么我就是那个铁狼。</span></span><br><span class="line">            <span class="keyword">else</span> ans[id]=ans[g[id].to]; <span class="comment">//我也指向我指证的人的指证</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[g[id].to]==<span class="number">0</span>) ans[id]=N; <span class="comment">//如果有全为村民的环，这里体现为，我最终指证回了一开始的那个人，结果呢，他居然还是没有得到指证的指证的指证……的对象，说明不能确认他，也就是说是全村民环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//访问过啦，但是也不是全是村民</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[id]=ans[g[id].to]; <span class="comment">//我继续指证</span></span><br><span class="line">            <span class="keyword">if</span>(ans[id]==id) ans[id]=<span class="number">-1</span>; <span class="comment">//如果……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//我指证别人是狼！但是啥都不一定，所以我指证指证。(- -|||)天呐我在说什么。。。</span></span><br><span class="line">        ans[id]=g[id].to; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,x;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i].to);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;w&#x27;</span>) g[i].v=<span class="number">0</span>;<span class="comment">//狼人</span></span><br><span class="line">            <span class="keyword">else</span> g[i].v=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="number">0</span>)</span><br><span class="line">                solve(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="number">-1</span>)cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Werewolf&quot;&gt;&lt;a href=&quot;#Werewolf&quot; class=&quot;headerlink&quot; title=&quot;Werewolf&quot;&gt;&lt;/a&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>

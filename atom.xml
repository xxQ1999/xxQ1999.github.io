<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeartBeat</title>
  
  <subtitle>飞光飞光，劝你一杯酒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/xxq1999/"/>
  <updated>2018-07-29T14:17:34.217Z</updated>
  <id>http://github.com/xxq1999/</id>
  
  <author>
    <name>XXQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拉格朗日插值法</title>
    <link href="http://github.com/xxq1999/2018/07/29/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
    <id>http://github.com/xxq1999/2018/07/29/拉格朗日插值/</id>
    <published>2018-07-29T14:17:34.217Z</published>
    <updated>2018-07-29T14:17:34.217Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>可以求给定式子的前n项和。</p><p>感觉可以求给定式子的前n项和。</p><p>如：求3x^5+4x^3-5x+8;</p><p>式子中最高项次数为5，则需要先计算出6个数字。</p><p>板子的使用：</p><p>先调用polysum::init(m); 这里的m要和D一起改，m&lt;D;</p><p>然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。</p><p>模板（<a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1258" target="_blank" rel="noopener">求n^k的前n项和</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">先调用polysum::init(m); 这里的m要和D一起改，m&lt;D;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">namespace</span> polysum &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> D=<span class="number">51000</span>;</span><br><span class="line">ll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][<span class="number">2</span>],C[D];</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span></span>&#123;ll res=<span class="number">1</span>;a%=mod;assert(b&gt;=<span class="number">0</span>);<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">calcn</span><span class="params">(<span class="keyword">int</span> d,ll *a,ll n)</span> </span>&#123; <span class="comment">// a[0].. a[d]  a[n]</span></span><br><span class="line"><span class="keyword">if</span> (n&lt;=d) <span class="keyword">return</span> a[n];</span><br><span class="line">p1[<span class="number">0</span>]=p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">rep(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">ll t=(n-i+mod)%mod;</span><br><span class="line">p1[i+<span class="number">1</span>]=p1[i]*t%mod;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">ll t=(n-d+i+mod)%mod;</span><br><span class="line">p2[i+<span class="number">1</span>]=p2[i]*t%mod;</span><br><span class="line">         &#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">rep(i,<span class="number">0</span>,d+<span class="number">1</span>) &#123;</span><br><span class="line">ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;</span><br><span class="line"><span class="keyword">if</span> ((d-i)&amp;<span class="number">1</span>) ans=(ans-t+mod)%mod;</span><br><span class="line"><span class="keyword">else</span> ans=(ans+t)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">f[<span class="number">0</span>]=f[<span class="number">1</span>]=g[<span class="number">0</span>]=g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">rep(i,<span class="number">2</span>,M+<span class="number">5</span>) f[i]=f[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">g[M+<span class="number">4</span>]=powmod(f[M+<span class="number">4</span>],mod<span class="number">-2</span>);</span><br><span class="line">per(i,<span class="number">1</span>,M+<span class="number">4</span>) g[i]=g[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">polysum</span><span class="params">(ll m,ll *a,ll n)</span> </span>&#123; <span class="comment">// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]</span></span><br><span class="line">ll b[D];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) b[i]=a[i];</span><br><span class="line">b[m+<span class="number">1</span>]=calcn(m,b,m+<span class="number">1</span>);</span><br><span class="line">rep(i,<span class="number">1</span>,m+<span class="number">2</span>) b[i]=(b[i<span class="number">-1</span>]+b[i])%mod;</span><br><span class="line"><span class="keyword">return</span> calcn(m+<span class="number">1</span>,b,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpolysum</span><span class="params">(ll R,ll n,ll *a,ll m)</span> </span>&#123; <span class="comment">// a[0].. a[m] \sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i</span></span><br><span class="line"><span class="keyword">if</span> (R==<span class="number">1</span>) <span class="keyword">return</span> polysum(n,a,m);</span><br><span class="line">a[m+<span class="number">1</span>]=calcn(m,a,m+<span class="number">1</span>);</span><br><span class="line">ll r=powmod(R,mod<span class="number">-2</span>),p3=<span class="number">0</span>,p4=<span class="number">0</span>,c,ans;</span><br><span class="line">h[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;h[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">rep(i,<span class="number">1</span>,m+<span class="number">2</span>) &#123;</span><br><span class="line">h[i][<span class="number">0</span>]=(h[i<span class="number">-1</span>][<span class="number">0</span>]+a[i<span class="number">-1</span>])*r%mod;</span><br><span class="line">h[i][<span class="number">1</span>]=h[i<span class="number">-1</span>][<span class="number">1</span>]*r%mod;</span><br><span class="line">&#125;</span><br><span class="line">rep(i,<span class="number">0</span>,m+<span class="number">2</span>) &#123;</span><br><span class="line">ll t=g[i]*g[m+<span class="number">1</span>-i]%mod;</span><br><span class="line"><span class="keyword">if</span> (i&amp;<span class="number">1</span>) p3=((p3-h[i][<span class="number">0</span>]*t)%mod+mod)%mod,p4=((p4-h[i][<span class="number">1</span>]*t)%mod+mod)%mod;</span><br><span class="line"><span class="keyword">else</span> p3=(p3+h[i][<span class="number">0</span>]*t)%mod,p4=(p4+h[i][<span class="number">1</span>]*t)%mod;</span><br><span class="line">&#125;</span><br><span class="line">c=powmod(p4,mod<span class="number">-2</span>)*(mod-p3)%mod;</span><br><span class="line">rep(i,<span class="number">0</span>,m+<span class="number">2</span>) h[i][<span class="number">0</span>]=(h[i][<span class="number">0</span>]+h[i][<span class="number">1</span>]*c)%mod;</span><br><span class="line">rep(i,<span class="number">0</span>,m+<span class="number">2</span>) C[i]=h[i][<span class="number">0</span>];</span><br><span class="line">ans=(calcn(m,C,n)*powmod(R,n)-c)%mod;</span><br><span class="line"><span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// polysum::init();</span></span><br><span class="line"><span class="function">ll <span class="title">pow2</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">a=a*a%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    ll b[<span class="number">51000</span>];</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    polysum::init(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=k+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=pow2(i,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,polysum::polysum(k,b,n+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;可以求给定式子的前n项和。&lt;/p&gt;
&lt;p&gt;感觉可以求给定式子的前n项和。&lt;/p&gt;
&lt;p&gt;如：求3x^5+4x^3-5x+8;&lt;/p&gt;
&lt;p&gt;式子中最高项次数为5，则需要先计算
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HDU 6315 Naive Operations(线段树)</title>
    <link href="http://github.com/xxq1999/2018/07/29/HDU%206315%20Naive%20Operations/"/>
    <id>http://github.com/xxq1999/2018/07/29/HDU 6315 Naive Operations/</id>
    <published>2018-07-29T13:57:21.832Z</published>
    <updated>2018-07-29T13:57:21.833Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6315" target="_blank" rel="noopener">HDU 6315 Naive Operations</a></p><p>n个数，q个询问</p><p>起始a、b数组都是n个元素，a数组全是0，b是1~n的全排列</p><p>add l r  ：a中【l，r】都加1</p><p>query l r ：询问∑floor(ai/bi) (i : l~r)</p><p>思路：</p><p>区间更新的线段树，维护区间最小值min（bi-ai%bi） 当min=0时sum++。</p><p>具体看代码注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l,r;<span class="comment">//区间[l,r]</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> add;<span class="comment">//区间的延时标记</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;<span class="comment">//区间和</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mn; <span class="comment">//区间最小值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bi; <span class="comment">//对应bi</span></span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];<span class="comment">//一定要开到4倍多的空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].sum = tree[index&lt;&lt;<span class="number">1</span>].sum+tree[index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">    tree[index].mn = min(tree[index&lt;&lt;<span class="number">1</span>].mn,tree[index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//说明该区间之前更新过</span></span><br><span class="line">    <span class="comment">//要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新</span></span><br><span class="line">    <span class="keyword">if</span>(tree[index].add)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index&lt;&lt;<span class="number">1</span>].mn -= tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mn -= tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;<span class="number">1</span>].add += tree[index].add;</span><br><span class="line">        tree[index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add += tree[index].add;</span><br><span class="line">        tree[index].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span> <span class="comment">//测试数据 输出具体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"l:%d r:%d bi:%lld min:%lld sum:%lld lazy:%d\n"</span>,l,r,tree[index].bi,tree[index].mn,tree[index].sum,tree[index].add);</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l==tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    print(l,mid,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    print(mid+<span class="number">1</span>,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    tree[index].add = <span class="number">0</span>;<span class="comment">//刚开始一定要清0</span></span><br><span class="line">    tree[index].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;tree[index].bi);</span><br><span class="line">        tree[index].mn = tree[index].bi;</span><br><span class="line">        tree[index].sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,mid,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[index].l&amp;&amp;r&gt;=tree[index].r&amp;&amp;tree[index].mn&gt;<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].mn--;</span><br><span class="line">        tree[index].add++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l==tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].mn--;</span><br><span class="line">        tree[index].add++;</span><br><span class="line">        <span class="keyword">if</span>(tree[index].mn&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[index].sum++;</span><br><span class="line">            tree[index].mn=tree[index].bi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l+tree[index].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) updata(l,r,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l&gt;mid) updata(l,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        updata(l,mid,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        updata(mid+<span class="number">1</span>,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushup(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == tree[index].l &amp;&amp; r == tree[index].r)</span><br><span class="line">        <span class="keyword">return</span> tree[index].sum;</span><br><span class="line"></span><br><span class="line">    pushdown(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l+tree[index].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) ans = query(l,r,index&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) ans = query(l,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans = query(l,mid,index&lt;&lt;<span class="number">1</span>)+query(mid+<span class="number">1</span>,r,index&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(index);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,x,y,z;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,s,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] ==<span class="string">'q'</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(x,y,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            updata(x,y,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//    print(1,n,1);</span></span><br><span class="line">     <span class="comment">//   printf("m:%d\n",m);</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 12</span></span><br><span class="line"><span class="comment">1 5 2 4 3</span></span><br><span class="line"><span class="comment">add 1 4</span></span><br><span class="line"><span class="comment">query 1 4</span></span><br><span class="line"><span class="comment">add 2 5</span></span><br><span class="line"><span class="comment">query 2 5</span></span><br><span class="line"><span class="comment">add 3 5</span></span><br><span class="line"><span class="comment">query 1 5</span></span><br><span class="line"><span class="comment">add 2 4</span></span><br><span class="line"><span class="comment">query 1 4</span></span><br><span class="line"><span class="comment">add 2 5</span></span><br><span class="line"><span class="comment">query 2 5</span></span><br><span class="line"><span class="comment">add 2 2</span></span><br><span class="line"><span class="comment">query 1 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="线段树" scheme="http://github.com/xxq1999/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>太菜辣</title>
    <link href="http://github.com/xxq1999/2018/07/29/%E5%A4%AA%E8%8F%9C%E8%BE%A3/"/>
    <id>http://github.com/xxq1999/2018/07/29/太菜辣/</id>
    <published>2018-07-28T16:53:02.418Z</published>
    <updated>2018-07-28T18:15:36.789Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2>动态规划</h2><p>​    基础<br>        线性dp、区间dp，主要就是状态方程的设计和状态的转移<br>        背包dp，及其扩展 《背包九讲》是很好的学习资料<br>        用dp递推概率、期望（dp求期望一般分为两种。一种是dp状态保存的是概率，则期望=概率*花费。另一种是dp状态直接保存期望，这样一般都是逆推的。）<br>        树形dp（有些会套个背包dp，有些需要多次树形dp）<br>        状态压缩dp<br>        数位dp<br>        RMQ、二维RMQ<br>    进阶<br>        dp优化<br>            使用数据结构优化，如线段树、树状数组、单调队列、单调栈、维护前缀和 …<br>            斜率优化（具有单调性可直接用单调队列或者二分，不具单调性要用平衡二叉树动态维护凸壳）<br>            四边形不等式优化<br>        插头dp</p><h2>数据结构</h2><p>​    基础<br>        <del>队列、栈</del><br>        <del>树、图的存储、遍历 邻接表和邻接矩阵</del><br>        <del>单调队列、单调栈</del><br>        <del>线段树</del>、<del>树状数组</del><br>        <del>并查集</del>、带权并查集<br>        <del>堆、优先队列</del><br>        <del>平衡二叉树</del><br>            Treap<br>            Spaly必须会<br>            [红黑树]<br>            [AVL树]<br>        <del>Hash散列表</del><br>    进阶<br>        分块数组（分块的思想很强大）<br>        二维线段树（就是线段树套线段树，其实还有个[矩形树]）、二维树状数组（就是树状数组套树状数组）<br>        树链剖分<br>        树套树，如线段树套平衡二叉树、树状数组套平衡二叉树 …<br>        Link-Cut-Tree（解决一类动态树的问题，可以说是树的剖分+Splay）<br>        可持久化数据结构，如主席树、可持久化线段树、可持久化字典树、可持久化并查集、可持久化Treap …</p><h2>搜索</h2><p>​    基础<br>        <del>深搜</del><br>        <del>广搜</del><br>        记忆化搜索（也可以放到dp分类里）<br>        <del>使用优先队列的广搜</del><br>        模拟退火、爬山算法<br>    进阶<br>        搜索剪枝<br>        双向广搜<br>        A<em>、IDA</em><br>        舞蹈链</p><h2>图论</h2><p>​    基础<br>        <del>最短路（Dijkstra、Spfa、Floyd）</del><br>        <del>最小生成树（Prim、Kruskal）</del><br>        <del>拓扑排序</del><br>        二分图最大匹配（匈牙利算法）<br>            二分图的最小顶点覆盖<br>            <del>DAG图的最小路径覆盖</del><br>            二分图的最大独立集<br>        二分图最优匹配（KM算法）<br>        二分图多重匹配<br>        网络流<br>            <del>最大流（Dinic</del>、Sap）<br>            最小费用最大流<br>            带上下界的最大流<br>        <del>有向图强连通分量的Tarjan算法</del><br>        最近公共祖先 Tarjan算法实现与RMQ实现各有千秋<br>        差分约束系统<br>        欧拉回路<br>        构造哈密顿回路<br>        最大团<br>        无向图全局最小割（StoerWagner）<br>    进阶<br>        次小生成树<br>        最优比率生成树<br>        [度限制生成树]<br>        [第k小生成树]<br>        次短路、第k短路<br>        网络流 胡伯涛的《最小割模型在信息学竞赛中的应用》是很好的学习资料<br>            最大权闭合图<br>            最大密度子图<br>            二分图最小点权覆盖集<br>            二分图最大点权独立集<br>            区间k覆盖的模型<br>            平面图网络流<br>        无向图的割点和桥、边双联通分量、点双联通分量<br>        2-SAT<br>        最小树形图<br>        一般图匹配<br>        生成树计数、最小生成树计数</p><h2>数学</h2><p>​    基础<br>        数论<br>            <del>欧几里得算法、扩展欧几里得算法</del><br>            <del>乘法逆元</del><br>            中国剩余定理<br>            欧拉函数<br>            欧拉定理<br>            <del>Miller_Rabin大素数判定</del><br>            <del>Pollard_rho大整数拆分</del><br>        线性代数<br>            <del>矩阵乘法&amp;快速幂</del><br>            <del>高斯消元</del><br>        组合数学<br>            容斥原理<br>            鸽巢原理<br>            <del>[母函数]</del><br>            [稳定婚姻问题]<br>        概率统计<br>        群论<br>            置换群<br>            BurnSide引理<br>            Polya定理<br>    进阶<br>        莫比乌斯反演<br>        BSGS<br>        FFT<br>        ……<br>        数学的进阶内容太多了</p><h2>字符串</h2><p>​    基础<br>        <del>KMP、扩展KMP</del><br>        <del>字典树</del><br>        最长回文子串的Manacher算法<br>        字符串最小/最大表示法<br>        许多字符串问题可以用dp甚至贪心求解<br>    进阶<br>        <del>AC自动机、Trie图</del><br>        回文树<br>        后缀数组、后缀自动机、后缀树<br>        序列自动机</p><h2>计算几何</h2><p>​    基础<br>        向量的点积、叉积<br>        极角排序<br>        Graham扫描法<br>        二维最近点对<br>        最小覆盖圆<br>        圆面积并<br>        ……<br>        计算几何的题目各种各样<br>    进阶<br>        半平面交<br>        旋转卡壳<br>        三维凸包<br>        ……<br>        计算几何的题目各种各样</p><h2>杂</h2><p>​    博弈<br>        一些经典的博弈、SG函数、必胜必败态搜索<br>    STL<br>        vector、set/mutiset、map、queue、stack、deque、string、rope…<br>    排序<br>        虽然都用sort但是堆排序的原理还是要知道的<br>    分治<br>        普通的分治<br>        CDQ分治<br>        整体二分<br>        树分治<br>    二分、三分<br>    2-points<br>    01分数规划<br>    构造<br>    树的同构（树的hash）<br>    <del>莫队算法</del>、[树上莫队]<br>    找规律、打表</p><p>带[]的感觉没必要学</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2&gt;动态规划&lt;/h2&gt;

&lt;p&gt;​    基础&lt;br&gt;        线性dp、区间dp，主要就是状态方程的设计和状态的转移&lt;br&gt;        背包dp，及其扩展 《背包九
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>组合数学（QAQ）</title>
    <link href="http://github.com/xxq1999/2018/07/27/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://github.com/xxq1999/2018/07/27/组合数学/</id>
    <published>2018-07-26T16:06:26.940Z</published>
    <updated>2018-07-28T18:17:37.136Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>$C_n^r=C_{n-1}^r+C_{n-1}^{r-1}$ 对于第n个元素，不取时，相当于前n-1个元素中取r个，取时，是前n-1个元素中取r-1个。</p><p>像个杨辉三角：</p><p>C(0,0)</p><p>C(1,0)   C(1,1)</p><p>C(2,0)   C(2,1)   C(2,2)</p><p>C(3,0)   C(3,1)   C(3,2)   C(3,3)</p><p>…..        …..        …..</p><p>如果要求解C(n,r)，可以先求解出C(n-1,r) 和 C(n-1,r-1)；再运用公式相加即可。很明显，这是一个与<a href="http://www.cnblogs.com/hapjin/p/5571352.html" target="_blank" rel="noopener">Fib数列</a>类似的递归计算。只不过求Fib(n)时，只有一个参数，而这里有二个参数而已。（还是直接求把。。还有用dp的方法）</p><h2 id="Cayley公式："><a href="#Cayley公式：" class="headerlink" title="Cayley公式："></a>Cayley公式：</h2><blockquote><p>一个完全图K_n有$n^{n-2}$棵生成树，即n个有标号1~n的顶点的树的个数为：$n^{n-2}$</p></blockquote><p>证明：你画个图</p><blockquote><p>给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n&gt;2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。</p></blockquote><p>简化为：n个数字可重复的排列到n-2个位置上去。</p><h2 id="不全相异的排列"><a href="#不全相异的排列" class="headerlink" title="不全相异的排列"></a>不全相异的排列</h2><p>n个元素组成的多重集，$a_i$重复$n_i$次，$n=∑_{i=1}^kn_i$,从n个元素中选取r个排列，求不同的排列数。</p><p>若r=n ,为：$\frac{n!}{n_1!n_2!…n_k!}$</p><h2 id="重复排列和重复组合"><a href="#重复排列和重复组合" class="headerlink" title="重复排列和重复组合"></a>重复排列和重复组合</h2><p>排列：在n个不同物体中可重复选取r个排列：$n^r$</p><p>组合：…… 组合：$C_{n+r-1}^r$</p><p>证明组合：对于1~n的x集合中选取r个元素，然后对应的构造r个y集合中的元素，对应关系为：$y_i=x_i+i-1$，</p><p>故……</p><h2 id="圆周排列"><a href="#圆周排列" class="headerlink" title="圆周排列"></a>圆周排列</h2><blockquote><p>a、b、c、d，普通排列：24，圆周排列：6 = 24/4 也就说；普通数量/个数 = （n-1）！</p></blockquote><h2>生成全排列</h2><h3 id="序数法："><a href="#序数法：" class="headerlink" title="序数法："></a>序数法：</h3><p>任何  $m=a_{n-1}(n-1)!+a_{n-2}(n-2)!+a_{n-3}(n-3)!+……+a_2<em>2!+a_1</em>1!$ ①</p><p>其中a1 = m%2， a2=(m/2)%3 , a3=(m/2/3)%4 ……直到m/……=0；</p><p>那么！a集合（$a_{n-1}~a_1$）共有n！种排列对不对！那么怎样把1,2，……n的一个排列和①联系起来呢？</p><blockquote><p>某一个n阶排列的序号是m，那么将m转换为阶乘进制数后，阶乘进制数的第i位就是在i右面比i小的元素个数。例如4阶排列中（从0开始计数的）第19个排列的序号是19，将19转换成阶乘进制数是3010，那么，第一位是0，表明1的右面没有比1小的元素，而第二位是1，则2的右面有一个元素小于2，第三位是0，即3的右面没有比它小的元素，第四位是3，4的右面有3个元素小于它。显然，这个排列是4 2 1 3。</p></blockquote><h3 id="字典序法："><a href="#字典序法：" class="headerlink" title="字典序法："></a>字典序法：</h3><blockquote><p>很简单就是1234 、 1243、 1324、 1342、……这样的全排列生成顺序</p></blockquote><p>方法是：eg：上一个排列数为：3421 (p.s.以下的i j k都是下标) 1~n</p><ol><li>求$ i = max ( j|a_j-1&lt;a_j ) = 2$</li><li>求$ j = max(k|a_i-1&lt;a_k)= 2$</li><li>交换$a_i-1$ 和 $a_j$ ，得：4321</li><li>将$a_ia_{i+1}a_{i+2}……a_n$逆序：得4123。</li></ol><p><a href="http://poj.org/problem?id=1833" target="_blank" rel="noopener">Poj 1833</a> 可以使用stl中的next_permutation(op1,op2)自动生成字典序的下一个全排列。</p><p>op1是放排列的数组首地址a，op2是排列的长度a+n。</p><p>到最后一个排列时返回为false。</p><p>但是这一题卡输出，用stl的<iterator>中的</iterator></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(a,a+n<span class="number">-1</span>,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>参考用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1300</span>];</span><br><span class="line">    <span class="keyword">int</span> m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            next_permutation(a,a+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        copy(a,a+n<span class="number">-1</span>,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻位互换法"><a href="#邻位互换法" class="headerlink" title="邻位互换法"></a>邻位互换法</h3><p>计蒜客构造题 <a href="https://nanti.jisuanke.com/t/28877" target="_blank" rel="noopener">[bellring]</a></p><blockquote><p>仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？</p></blockquote><p>n=1;        1</p><p>n=2;        12 , 21</p><p>n=3;        123, 132, 312, 321, 231, 213</p><p>……</p><p>用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">本算法的思想也是希望以（12…n）作为n个元素1，2，…，n的第一个排列，</span></span><br><span class="line"><span class="comment">然后按照某种方法，由一个排列（p）＝（p1p2…pn）直接生成下一个排列，</span></span><br><span class="line"><span class="comment">直到全部排列生成完毕为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以n＝4为例，开始在排列1234的各数上方加一个左箭头“←”，</span></span><br><span class="line"><span class="comment">当一个数上方箭头所指的一侧，相邻的数比该数小时，便称该数处于活动状态。</span></span><br><span class="line"><span class="comment">从排列（p）＝（p1p2…pn）生成下一个排列的算法如下：</span></span><br><span class="line"><span class="comment">（1）若排列（p）＝（p1p2…pn）中无一数处于活动状态，则停止，否则转（2）；</span></span><br><span class="line"><span class="comment">（2）求所有处于活动状态的数中的最大者，设为k，</span></span><br><span class="line"><span class="comment">k和它的箭头所指的一侧的相邻数互换位置，转（3）；</span></span><br><span class="line"><span class="comment">（3）令比k大的所有数的箭头改变方向，转（1）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> DIR&#123;LEFT=<span class="number">-1</span>,RIGHT=<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：判断下标i所指p中元素是否处于活动状态</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dirin,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *iin,待判定元素的下标</span></span><br><span class="line"><span class="comment"> *Nin,待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：true 表示待判定元素为活动状态，</span></span><br><span class="line"><span class="comment"> *false 表示待判定元素处于非活动状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsActive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,<span class="keyword">const</span> DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i+dir[i] &lt; <span class="number">0</span> || i+dir[i] &gt;= N)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(p[i+dir[i]] &lt; p[i])<span class="comment">//箭头所指一侧相邻的数比该数小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：找到p中处于活动状态的数中的最大者</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dir in,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *Nin,待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：上述最大者的下标，-1表示调用参数有误,N表示没有活动者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxActive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,<span class="keyword">const</span> DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">if</span>(IsActive(p,dir,i,N) &amp;&amp; (p[i] &gt; p[k]))</span><br><span class="line">k = i;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：交换下标i所指元素与其箭头方向所指元素,原位交换</span></span><br><span class="line"><span class="comment"> *输入参数：pinout,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dir inout,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *iin,待交换元素的下标</span></span><br><span class="line"><span class="comment"> *返回值：true 表示交换成功</span></span><br><span class="line"><span class="comment"> *false 表示交换失败，失败原因为调用参数有误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> *p, DIR *dir, <span class="keyword">int</span> *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> || dir == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换相邻的元素；</span></span><br><span class="line"><span class="keyword">char</span> temp = p[*i];</span><br><span class="line">p[*i] = p[*i+dir[*i]];</span><br><span class="line">p[*i+dir[*i]] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素相关的箭头也得交换</span></span><br><span class="line">DIR T = dir[*i];</span><br><span class="line">dir[*i] = dir[*i+T];</span><br><span class="line">dir[*i+T] = T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*i = *i + T;<span class="comment">//使*i依旧是未交换前*i所指元素的下标</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：上述算法思路第三步，修改所以比k大的元素的箭头方向，原位修改</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dirinout,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *kin,p中处于活动状态的最大者的下标，由MaxActive函数求出</span></span><br><span class="line"><span class="comment"> *Nin,缓冲区p的长度,也是待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：true 表示函数执行成功</span></span><br><span class="line"><span class="comment"> *false 表示函数执行失败，失败原因为调用参数有误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModifyDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> || dir == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;p[k])</span><br><span class="line">dir[i] = (dir[i] == LEFT ? RIGHT : LEFT);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span> [N+<span class="number">1</span>];</span><br><span class="line">DIR *dir = <span class="keyword">new</span> DIR [N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="string">'1'</span>+i;</span><br><span class="line">dir[i] = LEFT;</span><br><span class="line">&#125;</span><br><span class="line">p[N]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(p)<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p[<span class="built_in">strlen</span>(p)<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">k = MaxActive(p,dir,N);</span><br><span class="line"><span class="keyword">if</span>(k == N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">Swap(p,dir,&amp;k);</span><br><span class="line">ModifyDir(p,dir,k,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(p)<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p[<span class="built_in">strlen</span>(p)<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"><span class="keyword">delete</span> []dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>a_{n}=\frac{4n-2}{n+1}a_{n-1}<br>$$</p><p>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, … …</p><p>该递推关系的解是：<br>$$<br>a_{n}=\frac{C_{2n}^{n}}{n+1}   (n=1,2,3,…)<br>$$<br>eg. 出栈的种数与卡特兰数：</p><p><strong>① 对于出栈序列中的每一个数字，在它后面的、比它小的所有数字，一定是按递减顺序排列的。</strong></p><p><strong>② 给定一个入栈顺序：1  2  3 …. n，一共有多少种合法的出栈顺序？</strong></p><p>答案是 卡特兰数。即一共有：$h(n)=\frac{C_{2n}^{n}}{n+1}   $ 种合法的出栈顺序。</p><p>如果仅仅只需要求出一共有多少种合法的出栈顺序，其实就是求出组合 C(2n,n)就可以了。</p><h2 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h2><blockquote><p>定义：对于序列$a_0,a_1,a_2 … $构造一个函数：</p></blockquote><p>$$<br>G(x)=a_0+a_1x+a_2x^2+…<br>$$</p><blockquote><p>则，函数G(x)就是序列$a_0,a_1,a_2…$的母函数。</p></blockquote><p>比如说一个普通型母函数的应用：</p><p>有质量为1,2,3的砝码各一枚：</p><p>（1）可以称出多少种不同的质量？</p><p>解：1个1g砝码可以用1+x表示，1表示不用，x表示用1g砝码</p><p>​    1个2g砝码可用$1+x^2$表示……</p><p>​    1个3g砝码$1+x^3$……</p><p>​    则其母函数$G(x)=(1+x)(1+x^2)(1+x^3)=1+x+x^2+2x^3+x^4+x^5+x^6$</p><p>​    x上的指数表示质量，x前的系数表示搭配种类。</p><p>​    故可以称出6种。</p><p>（2）若砝码有无穷个？</p><p>解：以2g砝码为例，那么2g砝码可以组成：$(1+x^2+x^4+x^6……)$</p><p>因此：$G(x)=(1+x+x^2+x^3+……)(1+x^2+x^4+x^6+……)(1+x^3+x^6+x^9+……)$</p><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个比较快速</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">K对应具体问题中物品的种类数。</span></span><br><span class="line"><span class="comment">v[i]表示该乘积表达式第i个因子的权重，对应于具体问题的每个物品的价值或者权重。</span></span><br><span class="line"><span class="comment">n1[i]表示该乘积表达式第i个因子的起始系数，对应于具体问题中的每个物品的最少个数，即最少要取多少个。</span></span><br><span class="line"><span class="comment">n2[i]表示该乘积表达式第i个因子的终止系数，对应于具体问题中的每个物品的最多个数，即最多要取多少个。</span></span><br><span class="line"><span class="comment">对于表达式(1+x+x^2)(x^8+x^10)(x^5+x^10+x^15+x^20)，v[3]=&#123;1,2,5&#125;，n1[3]=&#123;0,4,1&#125;，n2[3]=&#123;2,5,4&#125;。</span></span><br><span class="line"><span class="comment">解题的关键是要确定v、n1、n2数组的值。</span></span><br><span class="line"><span class="comment">通常n1都为0，但有时候不是这样。</span></span><br><span class="line"><span class="comment">n2有时候是无限大。</span></span><br><span class="line"><span class="comment">P是可能的最大指数。</span></span><br><span class="line"><span class="comment">如果n2为无穷大，那么第二层循环条件j&lt;=n2[i]可以去掉。</span></span><br><span class="line"><span class="comment">a[i],i为指数，内容为系数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化a，因为有last，所以这里无需初始化其他位</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> last2=min(last+n[i]*v[i],P);<span class="comment">//计算下一次的last</span></span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//只清空b[0..last2]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n1[i];j&lt;=n2[i]&amp;&amp;j*v[i]&lt;=last2;j++)<span class="comment">//这里是last2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=last&amp;&amp;k+j*v[i]&lt;=last2;k++)<span class="comment">//这里一个是last，一个是last2</span></span><br><span class="line">b[k+j*v[i]]+=a[k];</span><br><span class="line"><span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//b赋值给a，只赋值0..last2</span></span><br><span class="line">last=last2;<span class="comment">//更新last</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2082" target="_blank" rel="noopener">HDU2082</a></p><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100</span>],n[<span class="number">100</span>],a[<span class="number">100</span>],b[<span class="number">100</span>],last,last2,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n[i]);</span><br><span class="line">            v[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">1</span>;last=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化a，因为有last，所以这里无需初始化其他位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> last2=min(last+n[i]*v[i],<span class="number">50</span>);<span class="comment">//计算下一次的last</span></span><br><span class="line">            <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//只清空b[0..last2]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n[i]&amp;&amp;j*v[i]&lt;=last2; j++) <span class="comment">//这里是last2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=last&amp;&amp;k+j*v[i]&lt;=last2; k++) <span class="comment">//这里一个是last，一个是last2</span></span><br><span class="line">                    b[k+j*v[i]]+=a[k];</span><br><span class="line">            <span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//b赋值给a，只赋值0..last2</span></span><br><span class="line">            last=last2;<span class="comment">//更新last</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i])   ans+=a[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>//大整数分解模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt;m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">10000019</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> times = <span class="number">50</span>;<span class="comment">//测试50次</span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"><span class="comment">//求a*b%m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = (ans + a) % m;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a = (a + a) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pow</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"><span class="comment">//a^b % m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)ans = mul(a, ans, m);</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a = mul(a, a, m);</span><br><span class="line">    &#125;</span><br><span class="line">    ans %= m;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n, <span class="keyword">int</span> repeat)</span><span class="comment">//n是测试的大数，repeat是测试重复次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span> || n == <span class="number">3</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//偶数和1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将n-1分解成2^s*d</span></span><br><span class="line">    ll d = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(d &amp; <span class="number">1</span>)) ++s, d &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//srand((unsigned)time(NULL));在最开始调用即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; i++)<span class="comment">//重复repeat次</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll a = rand() % (n - <span class="number">3</span>) + <span class="number">2</span>;<span class="comment">//取一个随机数,[2,n-1)</span></span><br><span class="line">        ll x = <span class="built_in">pow</span>(a, d, n);</span><br><span class="line">        ll y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            y = mul(x, x, n);</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">1</span> &amp;&amp; x != <span class="number">1</span> &amp;&amp; x != (n - <span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//费马小定理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll n, ll c)</span><span class="comment">//找到n的一个因子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x = rand() % (n - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    ll y = x, i = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x = (mul(x, x, n) + c) + n;<span class="comment">//不断调整x2</span></span><br><span class="line">        ll d = gcd(y - x, n);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> &lt; d &amp;&amp; d &lt; n)</span><br><span class="line">            <span class="keyword">return</span> d;<span class="comment">//找到因子</span></span><br><span class="line">        <span class="keyword">if</span>(y == x)</span><br><span class="line">            <span class="keyword">return</span> n;<span class="comment">//找到循环，返回n，重新来</span></span><br><span class="line">        <span class="keyword">if</span>(i == k)<span class="comment">//一个优化</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(ll n, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Miller_Rabin(n, times))<span class="comment">//如果是素数，就加入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//factor[index++]=n;</span></span><br><span class="line">        m[n]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll p = n;</span><br><span class="line">    <span class="keyword">while</span>(p &gt;= n)</span><br><span class="line">        p = pollard_rho(p, c--);<span class="comment">//不断找因子，知道找到为止，返回n说明没找到</span></span><br><span class="line"></span><br><span class="line">    Find(p, c);</span><br><span class="line">    Find(n / p, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        m.clear();</span><br><span class="line">        Find(n, rand() % (n - <span class="number">1</span>) + <span class="number">1</span>);<span class="comment">//这是自己设置的一个数</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" = "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;ll ,<span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end();)</span><br><span class="line">        &#123;it-&gt;first&lt;&lt;<span class="string">" ^ "</span>&lt;&lt;it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>((++it) != m.end())</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;<span class="string">" * "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ferrrs图像"><a href="#Ferrrs图像" class="headerlink" title="Ferrrs图像"></a>Ferrrs图像</h2><blockquote><p>一个自上而下的n层各自组成的图像，$m_i$为第i层的格子数。当$m_i≥m{i+1}$，即上层的格子数不少于下层的格子数时，称之为Ferrers图像。</p></blockquote><p>绕$y=-x$旋转得到的图像仍然是Ferrers图像，这样两个称为一对共轭Ferrers图像。</p><p>整数的拆分也可以用这个图像来表示。</p><p>可根据图像证明定理：整数n拆分成k个数的和的拆分数，与数n拆分成最大数为k的拆分数相等。</p><p>eg：24=5+5+5+4+3+2 的图像 共轭图像的话，24=6+6+5+4+3，</p><p>可以看出，24拆分成6个数的最大数=24拆分成最大数为6的拆分数</p><p>……</p><h2 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h2><p>在不全相异的排列那一p里面，r=n可以容易求出，但是当r一般情况的时候就复杂了。</p><p>对于给定的数列$a_0,a_1,a_2,…,a_n,…，$通常称为形式幂级数，即：<br>$$<br>Σ_{n=0}^∞\frac{a_n}{n!}x^n=a_0+a_1x+\frac{a_2}{2!}x^2+\frac{a_3}{3!}x^3+…+\frac{a_n}{n!}x^n+…<br>$$<br>为数列$a_0,a_1,a_2,…,a_n,…$的指数型母函数，这里规定0！=1。</p><p>这样，对于一个多重集，其中$a_i$重复了$n_i$次，$n=∑_{i=1}^nn_i$，从n个元素中取r个元素排列，不同的排列数对应的指数型母函数：<br>$$<br>G(x)=(1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^{n_1}}{n_1!})(1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^{n_2}}{n_2!})+…+(1+\frac{x}{1!}+\frac{x^2}{2!}+…+\frac{x^{n_k}}{n_k!})<br>$$<br>例题：有1,2,3,4,个数字组成的五位数中，要求数1出现次数不超过2次，但不能不出现；2不超过1次；3最多3次，可以不出现；4出现次数为偶数。求满足上述条件的数的个数。</p><p>解：$C_r$对应的指数型母函数为<br>$$<br>G(x)=(\frac{x}{1!}+\frac{x^2}{2!})(1+\frac{x}{1!})(1+\frac{x}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!})(1+\frac{x^2}{2!}+\frac{x^4}{4!})<br>$$<br>解得x上指数为5的系数为215。</p><p>p.s.4的偶数次之所以到$x^4$是因为再多也不满足条件啊。</p><h2 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h2><h2 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h2><h2 id="斯特林数-Stiring"><a href="#斯特林数-Stiring" class="headerlink" title="斯特林数 Stiring"></a>斯特林数 Stiring</h2><p>###第一类斯特林数</p><blockquote><p>有正负，其绝对值是包含n个元素的集合分作k个环排列的方法数目</p></blockquote><p>递推公式：</p><p>​                            S（n，0）= 0</p><p>​                            S（1，1） = 1</p><p>​                            S（n+1，k）= S（n，k-1) + nS（n，k）</p><p>第三个式子是这样的，n+1个元素分成k个环，可以理解为前n个元素分成k-1个环，第n+1个自成一个环的种类数量，加上前n个元素分成k个环，第n+1个元素插入到第i个元素左边。</p><h3 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3><blockquote><p>将包含n个元素的集合划分为正好k个非空子集方法的数目</p></blockquote><p>递推公式：</p><p>​                            S（n，k）= 0（n&lt;k ||k==0）</p><p>​                            S（n，n） = S（n，1） = 1 </p><p>​                            S（n，k）= S（n-1，k-1) + kS（n-1，k）</p><p>第三个式子是这样的，n个元素分成k集合，可以理解为前n-1个元素分成k-1个集合，第n个自成一个集合的种类数量，加上前n-1个元素分成k个环，第n个元素在k个集合中选择放到里面去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;组合&quot;&gt;&lt;a href=&quot;#组合&quot; class=&quot;headerlink&quot; title=&quot;组合&quot;&gt;&lt;/a&gt;组合&lt;/h2&gt;&lt;p&gt;$C_n^r=C_{n-1}^r+C_{
      
    
    </summary>
    
    
      <category term="数学" scheme="http://github.com/xxq1999/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计蒜客暑期</title>
    <link href="http://github.com/xxq1999/2018/07/08/%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%9A%91%E6%9C%9F/"/>
    <id>http://github.com/xxq1999/2018/07/08/计蒜客暑期/</id>
    <published>2018-07-08T07:20:48.063Z</published>
    <updated>2018-07-27T17:00:40.897Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>7.7</p><p>A. 思维题，重点在于当剩余的n&lt;k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那n=1，当然ok。</p><p>B. dijkstra最短路一下</p><p>D. Dp，结束后想了一下，dp[i]表示第i层停下来的所有怨气，dp[i]=min(dp[i],dp[j] + val(j-&gt;i)) ,（j&lt;i）i之前电梯停在j层，然后从j直接到i 的话，加上这一部分的怨气就好了val，而valij的怨气就是i的前缀和加上若每一层都停的怨气，再减去了j层停下来的人消失的这部分怨气。</p><p><img src="\source\mdpicture\20180712A.jpg" alt="20180712A"></p><p>F. 飞行航道 水</p><p>J. 找单词，八方找，正反找。看了题解 好像是先判断了一下回文减少了一下长度？</p><p>7.10</p><p>B.  最少按下的按钮次数</p><p>用bfs，时间小于0，变成0，大于3600，变为3600。vis[i]记录时间为i的最少步骤数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,sum;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>],vis[<span class="number">3610</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    node temp,tp;</span><br><span class="line">    temp.val=<span class="number">0</span>;</span><br><span class="line">    temp.step=<span class="number">0</span>;</span><br><span class="line">    q.push(temp);</span><br><span class="line">    vis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=temp.val+a[i];</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>) cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur&gt;<span class="number">3600</span>) cur=<span class="number">3600</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[cur]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[cur]=temp.step+<span class="number">1</span>;</span><br><span class="line">                tp.step=temp.step+<span class="number">1</span>;</span><br><span class="line">                tp.val=cur;</span><br><span class="line">                q.push(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=sum;i&lt;=<span class="number">3600</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,vis[i],i-sum);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>G. 水</p><p>I. 计算组成n的最小的两个斐波那契数a b，其中按b小来排，且a&lt;b</p><p><img src="\source\mdpicture\180710I.jpg" alt="I"></p><p>由上可知，先计算出最大的两个相邻数相加小于n的地方，设为x，y（x&lt;y），然后xa+yb=n,从b=1开始求满足条件的a，且a&lt;b。</p><p>J. 把迷宫设置大，然后从中间模拟</p><p>7.12</p><p>B. 最小路径覆盖，网络流，最大流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">3000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,cap,nxt;</span><br><span class="line">&#125;e[M];;<span class="comment">//邻接表要开边数的两倍</span></span><br><span class="line"><span class="keyword">int</span> src,des,dis[N],head[N],ecnt;  <span class="comment">//memset dis,head-1 ecnt=0,src=0,des=2*n+1;</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[ecnt].v=v;</span><br><span class="line">    e[ecnt].cap=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt++;</span><br><span class="line">    e[ecnt].v=u;</span><br><span class="line">    e[ecnt].cap=<span class="number">0</span>;</span><br><span class="line">    e[ecnt].nxt=head[v];</span><br><span class="line">    head[v]=ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(src);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[src]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap&gt;<span class="number">0</span>&amp;&amp;dis[v]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[des]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==des) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[i].cap&gt;<span class="number">0</span>&amp;&amp;dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;(t=Dfs(v,min(a,e[i].cap))))</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].cap-=t;</span><br><span class="line">            e[i^<span class="number">1</span>].cap+=t;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t=Dfs(src,inf)) ans+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,u,v;</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">    src=<span class="number">0</span>;des=<span class="number">2</span>*num+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        Addedge(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=num+<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i++)</span><br><span class="line">        Addedge(i,<span class="number">2</span>*num+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line">        <span class="keyword">while</span>(u--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">            Addedge(i,num+v+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=num+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num-Dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>E. 求次短路是否等于最短路长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN (10000 + 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (5000*5000*2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">    edge(<span class="keyword">int</span> tv = <span class="number">0</span>, <span class="keyword">int</span> tc = <span class="number">0</span>):</span><br><span class="line">        to(tv), cost(tc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> N, R;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; graph[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];     <span class="comment">//最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist2[MAXN];    <span class="comment">//次短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dist, dist+N, INF);</span><br><span class="line">    fill(dist2, dist2+N, INF);</span><br><span class="line">    <span class="comment">//从小到大的优先队列</span></span><br><span class="line">    <span class="comment">//使用pair而不用edge结构体</span></span><br><span class="line">    <span class="comment">//是因为这样我们不需要重载运算符</span></span><br><span class="line">    <span class="comment">//pair是以first为主关键字进行排序</span></span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; Q;</span><br><span class="line">    <span class="comment">//初始化源点信息</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push(P(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//同时求解最短路和次短路</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        P p = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="comment">//first为s-&gt;to的距离，second为edge结构体的to</span></span><br><span class="line">        <span class="keyword">int</span> v = p.second, d = p.first;</span><br><span class="line">        <span class="comment">//当取出的值不是当前最短距离或次短距离，就舍弃他</span></span><br><span class="line">        <span class="keyword">if</span>(dist2[v] &lt; d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; graph[v].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = graph[v][i];</span><br><span class="line">            <span class="keyword">int</span> d2 = d + e.cost;</span><br><span class="line">            <span class="keyword">if</span>(dist[e.to] &gt; d2)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(dist[e.to], d2);</span><br><span class="line">                Q.push(P(dist[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dist2[e.to] &gt; d2 &amp;&amp; dist[v] &lt; d2)</span><br><span class="line">            &#123;</span><br><span class="line">                dist2[e.to] = d2;</span><br><span class="line">                Q.push(P(dist2[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A, B, D,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;R,&amp;K);</span><br><span class="line">    <span class="keyword">while</span>(K--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;D);</span><br><span class="line">        graph[A<span class="number">-1</span>].push_back(edge(B<span class="number">-1</span>, D));</span><br><span class="line">        graph[B<span class="number">-1</span>].push_back(edge(A<span class="number">-1</span>, D));</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">if</span>(dist2[N<span class="number">-1</span>]==dist[N<span class="number">-1</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F. 求大数因子个数，用大数分解求出质因数</p><p>…… 机房。记得传回来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;7.7&lt;/p&gt;
&lt;p&gt;A. 思维题，重点在于当剩余的n&amp;lt;k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>飞行员配对(最大流模板)</title>
    <link href="http://github.com/xxq1999/2018/05/11/2018-05-11-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9(%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/05/11/2018-05-11-飞行员配对(最大流模板)/</id>
    <published>2018-05-11T14:44:22.000Z</published>
    <updated>2018-05-11T14:44:54.819Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];        <span class="comment">//残留网络，初始为原图</span></span><br><span class="line"><span class="keyword">int</span> flow[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> nodeNum;            <span class="comment">//节点总数量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[<span class="number">201</span>],p,q,v,i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">        pre[i]=<span class="number">-1</span>;</span><br><span class="line">    que[<span class="number">0</span>]=s;</span><br><span class="line">    pre[s]=s;</span><br><span class="line">    p=<span class="number">0</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;q)</span><br><span class="line">    &#123;</span><br><span class="line">        v=que[p++];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> (pre[i]==<span class="number">-1</span>&amp;&amp;(flow[v][i]&lt;g[v][i]||flow[i][v]&gt;<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=v;</span><br><span class="line">                que[q++]=i;</span><br><span class="line">                <span class="keyword">if</span> (i==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改残留矩阵和增广路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=t,v,MIN=INF;</span><br><span class="line">    <span class="keyword">while</span> (i!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i]&lt;g[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(MIN&gt;g[v][i]-flow[v][i])</span><br><span class="line">                MIN=g[v][i]-flow[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flow[i][v]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(MIN&gt;flow[i][v])</span><br><span class="line">                MIN=flow[i][v];</span><br><span class="line">        &#125;</span><br><span class="line">        i=v;</span><br><span class="line">    &#125;</span><br><span class="line">    i=t;</span><br><span class="line">    <span class="keyword">while</span> (i!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i]&lt;g[v][i])</span><br><span class="line">            flow[v][i]+=MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flow[i][v]&gt;<span class="number">0</span>)</span><br><span class="line">            flow[i][v]-= MIN;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 从节点s到节点t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s,t))</span><br><span class="line">        track_back(s,t);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (i!=s)res+=flow[s][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,b,e,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;nodeNum);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;b,&amp;e))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>&amp;&amp;e==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        g[e][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        g[i][nodeNum+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=nodeNum;i++)</span><br><span class="line">        g[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max_flow(<span class="number">0</span>,nodeNum+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;看！代码&quot;&gt;&lt;a href=&quot;#看！代码&quot; class=&quot;headerlink&quot; title=&quot;看！代码&quot;&gt;&lt;/a&gt;看！代码&lt;/h2&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://github.com/xxq1999/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>我依赖成瘾了的你</title>
    <link href="http://github.com/xxq1999/2018/04/24/2018-04-24-%E6%88%91%E4%BE%9D%E8%B5%96%E6%88%90%E7%98%BE%E4%BA%86%E7%9A%84%E4%BD%A0/"/>
    <id>http://github.com/xxq1999/2018/04/24/2018-04-24-我依赖成瘾了的你/</id>
    <published>2018-04-24T13:36:44.000Z</published>
    <updated>2018-04-24T15:02:34.399Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Please give the password. "/> <label for="pass"> Please give the password. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      NEED PASSWORD./文章已加密
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>网络流 【待续】</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-网络流/</id>
    <published>2018-04-23T11:26:23.000Z</published>
    <updated>2018-05-13T07:20:14.748Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：</p><p><img src="\mdpicture\水管流量.jpg" alt="水管流量最大该是多少呢"></p><h2 id="网络流的定义"><a href="#网络流的定义" class="headerlink" title="网络流的定义"></a>网络流的定义</h2><p>在有向图G=（V,E）中：</p><p>1、有唯一的一个源点S（入度为0：出发点）</p><p>2、有唯一的一个汇点（出度为0：结束点）</p><p>3、图中的每条弧（u,v）都有一个非负的容量c（u,v）</p><p>满足上述条件的图G称为网络流图。</p><p>记为：G=（V,E,C）</p><a id="more"></a><h3 id="可行流"><a href="#可行流" class="headerlink" title="可行流"></a>可行流</h3><p>每条管道中可以通过的流量。</p><p><img src="\mdpicture\可行流.JPG" alt="可行流"></p><h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>在所有的可行流中，流量最大的一个流。（最大流可能不止一个）</p><p>解决最大流的问题常用到Ford-Fulkerson方法（在此方法下，存在着若干种不同时间复杂度下的实现）</p><h4 id="Ford-Fulkerson和Edmonds-Karp"><a href="#Ford-Fulkerson和Edmonds-Karp" class="headerlink" title="Ford-Fulkerson和Edmonds-Karp"></a>Ford-Fulkerson和Edmonds-Karp</h4><p>1、残存网络</p><p>第一个图是流网络，边上的12/16,12指的是流量，16是容量。</p><p>第二个图是残存网络，可能会存在一对相反的边，如刚刚12/16在残存网络中，体现为 v1-&gt;s = 12，s-&gt;v1 = 16-12。与流网络中对应的边代表的是该边的残余容量，流网络中不存在的边是一条反向的已有流量边，这部分流量<strong>可以通过回流减少</strong>。（残存网络中值为0的边不画出）</p><p><img src="\mdpicture\残余网络.JPG" alt="残存网络和流网络对比"></p><p>2、增广路径</p><p>假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量&lt;容量，注意，是严格的&lt;,而不是&lt;=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。</p><p>3、方法</p><p>我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。<strong>当找不到增广路的时候，当前的流量就是最大流</strong>，这个结论非常重要。</p><!--而Ford-Fulkerson方法和Edmonds-Karp的区别就是在寻找增广路时，前者是随便找一条，dfs深搜，后者找一条节点数最少的，bfs广搜--><p>寻找增广路的时候我们可以简单的从源点开始做bfs，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。</p><p>4、代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[MAX][MAX];  <span class="comment">//残留网络容量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAX];  <span class="comment">//保存增广路径上的点的前驱顶点</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ford_Fulkerson</span><span class="params">(<span class="keyword">int</span> src,<span class="keyword">int</span> des,<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//src：源点 des：汇点 n：顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> i,_min,total=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!Augmenting_Path(src,des,n))<span class="keyword">return</span> total; <span class="comment">//如果找不到增广路就返回，在具体实现时替换函数名</span></span><br><span class="line">         _min=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">         i=des;</span><br><span class="line">         <span class="keyword">while</span>(i!=src)&#123;   <span class="comment">//通过pre数组查找增广路径上的边，求出残留容量的最小值</span></span><br><span class="line">             <span class="keyword">if</span>(_min&gt;c[pre[i]][i])_min=c[pre[i]][i];</span><br><span class="line">             i=pre[i];</span><br><span class="line">         &#125;</span><br><span class="line">         i=des;</span><br><span class="line">         <span class="keyword">while</span>(i!=src)&#123;    <span class="comment">//再次遍历，更新增广路径上边的流值</span></span><br><span class="line">             c[pre[i]][i]-=_min;</span><br><span class="line">             c[i][pre[i]]+=_min;</span><br><span class="line">             i=pre[i];</span><br><span class="line">         &#125;</span><br><span class="line">         total+=_min;     <span class="comment">//每次加上更新的值</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==t)</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">Edge &amp;e=g[u][i];</span><br><span class="line"><span class="keyword">int</span> v=e.to;</span><br><span class="line"><span class="keyword">if</span>(!used[v]&amp;&amp;e.cap&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=dfs(v,t,min(e.cap,f));</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap-=d;</span><br><span class="line">g[e.to][e.rev].cap+=d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,f;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">f=INF;</span><br><span class="line"><span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line"><span class="keyword">int</span> d=dfs(s,t,f);</span><br><span class="line"><span class="keyword">if</span>(d&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">res+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">--*</span><br><span class="line">    Ford-fulkerson最短扩充路</span><br><span class="line">    调用前输入残余矩阵 g[][]</span><br><span class="line">    直接调用max_flow(源点, 汇点) 返回最大流</span><br><span class="line">    </span><br><span class="line">    注意初始化：nodeNum（节点总数量）</span><br><span class="line">    注意节点标号： <span class="number">0</span> - (nodeNum<span class="number">-1</span>)</span><br><span class="line">*/</span><br><span class="line"><span class="comment">//pku1273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];        <span class="comment">//残留网络，初始为原图</span></span><br><span class="line"><span class="keyword">int</span> flow[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> nodeNum;            <span class="comment">//节点总数量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[<span class="number">201</span>], p, q, v, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">        pre[i] = <span class="number">-1</span>;  </span><br><span class="line">    que[<span class="number">0</span>] = s;</span><br><span class="line">    pre[s] = s;</span><br><span class="line">    p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q)</span><br><span class="line">    &#123;</span><br><span class="line">        v = que[p++];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">            <span class="keyword">if</span> (pre[i] == <span class="number">-1</span> &amp;&amp; (flow[v][i] &lt; g[v][i] || flow[i][v] &gt; <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i] = v;</span><br><span class="line">                que[q++] = i;</span><br><span class="line">                <span class="keyword">if</span> (i == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改残留矩阵和增广路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = t, v, min = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i] &lt; g[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; g[v][i] - flow[v][i])</span><br><span class="line">                min = g[v][i] - flow[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (flow[i][v] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; flow[i][v])</span><br><span class="line">                    min = flow[i][v];</span><br><span class="line">            &#125;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">    i = t;</span><br><span class="line">    <span class="keyword">while</span> (i != s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i] &lt; g[v][i])</span><br><span class="line">            flow[v][i] += min;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (flow[i][v] &gt; <span class="number">0</span>)</span><br><span class="line">                flow[i][v] -= min;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 从节点s到节点t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t))</span><br><span class="line">        track_back(s, t);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (i != s) res += flow[s][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, b, e, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;nodeNum)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(flow, <span class="number">0</span>, <span class="keyword">sizeof</span>(flow));</span><br><span class="line">        <span class="keyword">while</span> (m--)  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;b, &amp;e, &amp;c), g[b - <span class="number">1</span>][e - <span class="number">1</span>] += c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max_flow(<span class="number">0</span>, nodeNum<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><p>就是从图G(V,E)中去除一些边，使得图G中源点S到终点T不连通。如果去除的这些边的权和最小，就是最小割。这个权和可以证明等于网络的最大流量！因此，最大流等价于最小割。求解最大流问题，也可以转化为最小割。求最大流和求最小割集是两类不同的算法。求解最小割集普遍采用<strong>Stoer-Wagner</strong>算法。</p><h4 id="Stoer-Wagner"><a href="#Stoer-Wagner" class="headerlink" title="Stoer-Wagner"></a>Stoer-Wagner</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cut</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) node[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; now; i++) &#123;</span><br><span class="line">            k = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; now; j++) <span class="keyword">if</span>(!vis[node[j]]) &#123;</span><br><span class="line">                dis[node[j]] += G[node[pre]][node[j]];</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">-1</span> || dis[node[k]] &lt; dis[node[j]]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[node[k]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == now - <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(ret, dis[node[k]]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; now; j++) &#123;</span><br><span class="line">                    G[node[pre]][node[j]] += G[node[j]][node[k]];</span><br><span class="line">                    G[node[j]][node[pre]] = G[node[pre]][node[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                node[k] = node[--now];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;\mdpicture\水管流量.jpg&quot; alt=&quot;水管流量最大该是多少呢&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络流的定义&quot;&gt;&lt;a href=&quot;#网络流的定义&quot; class=&quot;headerlink&quot; title=&quot;网络流的定义&quot;&gt;&lt;/a&gt;网络流的定义&lt;/h2&gt;&lt;p&gt;在有向图G=（V,E）中：&lt;/p&gt;
&lt;p&gt;1、有唯一的一个源点S（入度为0：出发点）&lt;/p&gt;
&lt;p&gt;2、有唯一的一个汇点（出度为0：结束点）&lt;/p&gt;
&lt;p&gt;3、图中的每条弧（u,v）都有一个非负的容量c（u,v）&lt;/p&gt;
&lt;p&gt;满足上述条件的图G称为网络流图。&lt;/p&gt;
&lt;p&gt;记为：G=（V,E,C）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://github.com/xxq1999/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Clever King (最大权闭合子图模板)</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-Clever-King-(%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-Clever-King-(最大权闭合子图模板)/</id>
    <published>2018-04-23T08:42:22.000Z</published>
    <updated>2018-04-24T14:58:39.644Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Clever-King"><a href="#Clever-King" class="headerlink" title="Clever King"></a><a href="https://nanti.jisuanke.com/t/26172" target="_blank" rel="noopener">Clever King</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>T组数据，有n个产品，m个矿坑。接下来n个数字happiness[i]表示第i个产品的幸福指数，接下来m个数字，ori[i]表示第i个矿坑的开发费用。接下来n行，每行先输入两个数字n1，n2，分别表示第i号产品需要开发的矿坑，和需要的原材料产品。（矿坑开发后材料无限，产品生产后幸福指数一定会增加，不管是作为产品本身还是原材料），要求 幸福指数 - 费用  的最大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最大权闭合子图模板。<a href="https://blog.csdn.net/jingmiaa/article/details/52814814" target="_blank" rel="noopener">【关于网络流】</a>（ND）</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个子图（点集）， 如果它的所有的出边都在这个子图当中，那么它就是闭合子图。<br>点权和最大的闭合子图就是最大闭合子图。</p><p>简单说就是有一些点，每个点有一些点权（正负都有），要选一个点，就必须要选它所连向的点。</p><p>有可能连成一条链，像这样：x-&gt;y-&gt;z-&gt;…</p><p>求合法的点集的最大的点权和。</p><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>设s为源点，t为汇点。</p><p>使s连向所有的正权点（非负权点），边权为点权。</p><p>使所有非负权点（负权点）连向t，边权为点权的绝对值。</p><p>若需要选y才能选x，连一条由x到y的边，边权是∞。</p><p><strong>最大点权和 = 正权点和 - 最小割</strong></p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">505</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,flow;</span><br><span class="line">&#125;e[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn],co[maxn],d[maxn],Final[maxn],tot,s,t;</span><br><span class="line"><span class="comment">// s源点 t终点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].to=y,e[tot].next=Final[x],e[tot].flow=z,Final[x]=tot;</span><br><span class="line">    e[++tot].to=x,e[tot].next=Final[y],e[tot].flow=<span class="number">0</span>,Final[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span> <span class="comment">//模板 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> use=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[x];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(e[i].flow&gt;<span class="number">0</span>&amp;&amp;d[e[i].to]+<span class="number">1</span>==d[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=dg(e[i].to,min(flow-use,e[i].flow));</span><br><span class="line">            use+=c;</span><br><span class="line">            e[i].flow-=c;</span><br><span class="line">            e[i^<span class="number">1</span>].flow+=c;</span><br><span class="line">            <span class="keyword">if</span>(flow==use) <span class="keyword">return</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[x]=Final[x];</span><br><span class="line">    <span class="keyword">if</span>(!(--co[d[x]])) d[<span class="number">0</span>]=t;</span><br><span class="line">    ++co[++d[x]];</span><br><span class="line">    <span class="keyword">return</span> use;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n1,n2,temp,n,m;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=<span class="number">0</span>;tot=<span class="number">1</span>;s=t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cur,<span class="number">0</span>,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="built_in">memset</span>(co,<span class="number">0</span>,<span class="keyword">sizeof</span>(co));</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(Final,<span class="number">0</span>,<span class="keyword">sizeof</span>(Final));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        ans=n+m;s=ans+<span class="number">1</span>;t=ans+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//s和正权相连</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            sum+=temp;</span><br><span class="line">            link(s,i,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)  <span class="comment">//t和负权相连</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            link(i+n,t,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n1,&amp;n2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n1;j++)  <span class="comment">//i个点需要j的话，就把i-&gt;j，边权是inf</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                link(i,temp+n,<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                link(i,temp,<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        co[<span class="number">0</span>]=t;</span><br><span class="line">        <span class="keyword">for</span>(;d[<span class="number">0</span>]&lt;t;) sum-=dg(s,<span class="number">1</span>&lt;&lt;<span class="number">30</span>); <span class="comment">//最小割</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Clever-King&quot;&gt;&lt;a href=&quot;#Clever-King&quot; class=&quot;headerlink&quot; title=&quot;Clever King&quot;&gt;&lt;/a&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="最大权闭合子图" scheme="http://github.com/xxq1999/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Goldbach （Miller Rabin模板+埃氏筛模板)</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-Goldbach-%EF%BC%88Miller-Rabin%E6%A8%A1%E6%9D%BF+%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-Goldbach-（Miller-Rabin模板+埃氏筛模板)/</id>
    <published>2018-04-23T07:53:22.000Z</published>
    <updated>2018-04-23T08:40:14.158Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Goldbach"><a href="#Goldbach" class="headerlink" title="Goldbach"></a><a href="https://nanti.jisuanke.com/t/25985" target="_blank" rel="noopener">Goldbach</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>哥德巴赫猜想：输入一个T（100），输入一个偶数n（2&lt;n&lt;2^63），输出任意一组素数a，b，使得a+b=n。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>a和b必定为一大一小，从小的入手，用埃氏筛筛出1e6内的所有素数prim[]（猜想到小的那个素数一定不超过1e6），然后遍历prim[]，算出n-prim[i]，用基于概率的素数测试算法MillerRabin判断它是不是素数即可。</p><p><a href="https://blog.csdn.net/sunshine_cfbsl/article/details/52425798" target="_blank" rel="noopener">【Miller Rabin素数判定】</a></p><p>这里注意，由于2^63次过大，在相乘得过程中会超longlong，因此要改用unsigned long long。</p><blockquote><p>做题的时候，遇到范围是2^63，取模2^64的这种题目。遇到这种限制条件时就要想到用unsigned long long类型。这样，如果ull类型的整数溢出了，就相当于取模2^64了。因为ull的范围是[0,2^64-1]。而ll的范围是[-2^63,2^63-1]，因为有符号的第63位表示“正负”而不表示数值。</p></blockquote><p><strong>附一个公式：(1+a1)(1+a2)(1+a3)……(1+an-1)(1+an) = 1+sum{ai}+sum{ai·aj}+sum{ai·aj·ak}+……+sum{a1·a2·…·an}</strong></p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">typedef</span> ULL ULL;</span><br><span class="line">ULL n, x[MAXN];</span><br><span class="line"></span><br><span class="line">ULL pri[MAX+<span class="number">5</span>],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)pri[num++]=i;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;num&amp;&amp;i*pri[j]&lt;MAX;j++)</span><br><span class="line">            vis[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">multi</span><span class="params">(ULL a, ULL b, ULL p)</span> </span>&#123;</span><br><span class="line">    ULL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1L</span>L) ans = (ans+a)%p;</span><br><span class="line">        a = (a+a)%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">qpow</span><span class="params">(ULL a, ULL b, ULL p)</span> </span>&#123;</span><br><span class="line">    ULL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1L</span>L) ans = multi(ans, a, p);</span><br><span class="line">        a = multi(a, a, p);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ULL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">20</span>, i, t = <span class="number">0</span>;</span><br><span class="line">    ULL u = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(u &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s--) &#123;</span><br><span class="line">        ULL a = rand()%(n<span class="number">-2</span>)+<span class="number">2</span>;</span><br><span class="line">        x[<span class="number">0</span>] = qpow(a, u, n);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            x[i] = multi(x[i<span class="number">-1</span>], x[i<span class="number">-1</span>], n);</span><br><span class="line">            <span class="keyword">if</span>(x[i] == <span class="number">1</span> &amp;&amp; x[i<span class="number">-1</span>] != <span class="number">1</span> &amp;&amp; x[i<span class="number">-1</span>] != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x[t] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ULL n,temp;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Miller_Rabin(n-pri[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,pri[i],n-pri[i]);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Goldbach&quot;&gt;&lt;a href=&quot;#Goldbach&quot; class=&quot;headerlink&quot; title=&quot;Goldbach&quot;&gt;&lt;/a&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="素数" scheme="http://github.com/xxq1999/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ACM-ICPC &amp; U</title>
    <link href="http://github.com/xxq1999/2018/04/19/2018-04-19-ACM-ICPC-&amp;-U/"/>
    <id>http://github.com/xxq1999/2018/04/19/2018-04-19-ACM-ICPC-&amp;-U/</id>
    <published>2018-04-19T13:50:24.000Z</published>
    <updated>2018-04-19T14:35:16.091Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32574246&auto=0&height=66"></iframe><p><img src="\mdpicture\ACM.jpg" arc="ACM-ICPC :) "></p><p>world final的直播，窝在图书馆的角落看了一下午，这种感觉真的很棒，真的让我有一种ACM即是力量的冲动。看着这么多的队伍们提交，Pending的进度条一点一点增加，然后高亮，切到队伍的镜头，一阵紧张，最后AC后的欢呼和击掌，然后匆匆进入下一题。</p><p>代码的力量是什么呢？</p><p>ACM的力量是什么呢？</p><p>让我明明笨拙到坚持不下去，却又不舍得放弃它。</p><p>大概是等待pending的期待的心情，WA了之后自言自语的不服，TLE绞尽脑汁优化的苦恼，或者是看着队友疯狂输出的感叹，大家叽里呱啦实在是很吵闹的讨论 …… 以及最后出现的世界上最好看的单词Accept的欣喜若狂。</p><p>真是充满着魔力的一切。</p><p><img src="\mdpicture\键盘上的秘密.jpg" arc="键盘上的星星点点"></p><hr><p><img src="\mdpicture\西装和狗毛.jpg" arc="西装领带，狗毛"></p><blockquote><p>四月十九号，倒计时：三天。</p></blockquote><hr><p><img src="\mdpicture\JJ圣所.jpg" arc="丹宁执着"></p><blockquote><p>许下演唱会的心愿。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;8
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>木棒切割（二分+DP+滚动数组优化）</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-%E6%9C%A8%E6%A3%92%E5%88%87%E5%89%B2%EF%BC%88%E4%BA%8C%E5%88%86+DP+%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-木棒切割（二分+DP+滚动数组优化）/</id>
    <published>2018-04-18T13:55:24.000Z</published>
    <updated>2018-04-18T14:21:08.279Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="木棒切割"><a href="#木棒切割" class="headerlink" title="木棒切割"></a><a href="https://vjudge.net/problem/HYSBZ-1044" target="_blank" rel="noopener">木棒切割</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个木棒，最多能切m下，接下来n行，给出n个木棒的长度，求出切割后最大长度的最小值，并求出有多少种切割方式，取模10007</p><p>n&lt;=50000，0&lt;=m&lt;=min(n-1,1000)，1&lt;=Li&lt;=1000</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分答案，low=0，high=sum[n]。</p><p>得到最小值ans。</p><p>接下来用DP，求出切割种数。</p><p><strong>dp[i][j]表示前i个木棒切割j下的种数，设sum[i] 是前i个木棒的长度和 ，那么dp[i][j]=求和{ dp[k][j-1] }，满足条件：k&lt;i &amp;&amp; sum[i] - sum[k]&lt;=ans</strong> 。</p><p>但是写完之后，我们发现，诶，这个时间复杂度……O(n^2 * m)，这不超时有鬼……</p><p>于是我们可以进行下面的优化：</p><h3 id="1、空间"><a href="#1、空间" class="headerlink" title="1、空间"></a>1、空间</h3><p>由于当前的dp[][j]只与dp[][j-1]有关，所以呢，我们可以用滚动数组，用dp[][now]代替dp[i][j]，用dp[][pre]代替dp[][j-1]，其中pre=now^1。</p><p>这样空间就小啦~</p><h3 id="2、时间"><a href="#2、时间" class="headerlink" title="2、时间"></a>2、时间</h3><p>这个好难理解啊我觉得……大概是太笨了哼唧</p><p>对于dp[i][now],其实是dp[Mink][pre]……dp[i-1][Mink]的和！！Mink 就是满足 k&lt;i &amp;&amp; sum[i]-sum[k]&lt;=ans的最小的k。那么，对于从 1 到 n 枚举的 i ，相对应的 Mink 也一定是非递减的（因为 Sum[i] 是递增的）。我们记录下 dp[1][pre]…dp[i-1][pre] 的和 S ，Mink 初始设为 1，每次对于 i 将 Mink 向后推移，推移的同时将被舍弃的 p 对应的 dp[p][pre] 从 S 中减去。那么 dp[i][Now] 就是 S 的值。</p><p>时间复杂度O(nm)。</p><p>接下来请欣赏代码——</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">10007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50010</span>],sum[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> <span class="comment">//看看有没有单比mid还大的 或者分割不了的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(s&gt;mid) cnt++,s=a[i];</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mid) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">//二分答案</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=sum[n];</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) ans=mid,r=mid<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">50010</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//滚动数组，前i块切j下的数量</span></span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,pre=<span class="number">1</span>,s,Mink; <span class="comment">//mink 最小的满足k&lt;j &amp;&amp; s[i]-s[k]&lt;=ans 的</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="comment">//切i下</span></span><br><span class="line">    &#123;</span><br><span class="line">         s=<span class="number">0</span>,Mink=<span class="number">1</span>; </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="comment">//前j块</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="comment">//如果一下不割</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span>(sum[j]&lt;=ans) dp[j][now]=<span class="number">1</span>; <span class="comment">//如果这块东西比要求的要小，就前j块割0下是1钟</span></span><br><span class="line">                 <span class="keyword">else</span> dp[j][now]=<span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//s=sum&#123;dp[k][j-1]&#125; k&lt;j&amp;&amp;s[i]-s[k]&lt;=ans ，sum也相当于减去那些不满足条件的，</span></span><br><span class="line">                 <span class="comment">//因为这东西肯定单调非递减，所以一直找到最小的满足的k就好</span></span><br><span class="line">                 <span class="keyword">while</span>(Mink&lt;j&amp;&amp;(sum[j]-sum[Mink])&gt;ans) <span class="comment">//找到最小的满足条件的k</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     s-=dp[Mink][pre]; <span class="comment">//减去前mink块不符合条件的 切了i-1下的</span></span><br><span class="line">                     s=(s+MOD)%MOD;</span><br><span class="line">                     Mink++;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dp[j][now]=s%MOD; <span class="comment">//别忘了取模</span></span><br><span class="line">             &#125;</span><br><span class="line">             s=(s+dp[j][pre])%MOD; <span class="comment">// s加上前j块割i-1下的</span></span><br><span class="line">         &#125;</span><br><span class="line">         res=(res+dp[n][now])%MOD; <span class="comment">//总数相当于总数加上n块割i下的</span></span><br><span class="line">         now^=<span class="number">1</span>; <span class="comment">//滚动数组</span></span><br><span class="line">         pre=now^<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;木棒切割&quot;&gt;&lt;a href=&quot;#木棒切割&quot; class=&quot;headerlink&quot; title=&quot;木棒切割&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分" scheme="http://github.com/xxq1999/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
      <category term="滚动数组" scheme="http://github.com/xxq1999/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Buy a ticket (最短路SPFA)</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-Buy-a-ticket-(%E6%9C%80%E7%9F%AD%E8%B7%AFSPFA)/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-Buy-a-ticket-(最短路SPFA)/</id>
    <published>2018-04-18T08:27:33.000Z</published>
    <updated>2018-04-18T08:49:55.281Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Buy-a-ticket"><a href="#Buy-a-ticket" class="headerlink" title="Buy a ticket"></a>Buy a ticket</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个城市，m条无向路，每条路有vi的权值（&gt;0），每个城市有ai的音乐会花费。</p><p>某人想去看音乐会，如果她在i城，他要去j城看演出，那么要花费的钱相当于来回的路费加上j城的演唱会的钱（也可以在自家看演出）。求的是，每个城市的人看一场音乐会的最少花费。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很熟悉的思路，定义一个超级原点，将超级原点和每个城市连起来，路的权值设为该城市的音乐会花费，同时加其他的路的权值设为原来的两倍（来回的花费），那么从原点到每个城市的最小花费就是每个城市的人看音乐会的最小花费。（最短路）</p><p>开头用dijkstra写，看了一下复杂度肯定会T，o(n^2)的样子，然后交了一发。后来换用SPFA，队列啥的，还是T，然后看了一下过的人的代码，发现他们用优先队列优化，将花费大的放在了前面。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to; <span class="comment">//目的</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val; <span class="comment">//花费</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;   </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;k.val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Next[<span class="number">200005</span>]; <span class="comment">//路</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">200005</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//在Q里的情况</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[<span class="number">200005</span>];  <span class="comment">//距离原点的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis)); </span><br><span class="line">    priority_queue&lt;Node&gt; Q; <span class="comment">//修改成优先队列，默认路径花费大的放前面，是的</span></span><br><span class="line">    Node temp;</span><br><span class="line">    temp.to=<span class="number">0</span>;temp.val=<span class="number">0</span>;</span><br><span class="line">    Q.push(temp);  <span class="comment">//把原点先入队</span></span><br><span class="line">    vis[<span class="number">0</span>]=<span class="number">1</span>;dis[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//原点到原点当然是0啦  </span></span><br><span class="line">    <span class="keyword">int</span> now,a;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        now=temp.to;</span><br><span class="line">        vis[now]=<span class="number">0</span>;  <span class="comment">//出队的点vis更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Next[now].size();i++)  <span class="comment">//遍历连接的城市</span></span><br><span class="line">        &#123;</span><br><span class="line">            a=Next[now][i].to;  </span><br><span class="line">            <span class="keyword">if</span>(dis[a]&gt;(dis[now]+Next[now][i].val)) <span class="comment">//如果从原点到这个城市的距离比中间接这个城市跳转要远</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[a]=dis[now]+Next[now][i].val;</span><br><span class="line">                <span class="keyword">if</span>(vis[a]==<span class="number">0</span>) <span class="comment">//如果a不在队列里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[a]=<span class="number">1</span>;temp.to=a;temp.val=dis[a];</span><br><span class="line">                    Q.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ori,to;</span><br><span class="line">    node temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;ori,&amp;to,&amp;temp.val);</span><br><span class="line">        temp.to=to;</span><br><span class="line">        temp.val*=<span class="number">2</span>;</span><br><span class="line">        Next[ori].push_back(temp);</span><br><span class="line">        temp.to=ori;</span><br><span class="line">        Next[to].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;dis[i+<span class="number">1</span>]);</span><br><span class="line">        temp.to=i+<span class="number">1</span>;temp.val=dis[i+<span class="number">1</span>];</span><br><span class="line">        Next[<span class="number">0</span>].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,dis[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Buy-a-ticket&quot;&gt;&lt;a href=&quot;#Buy-a-ticket&quot; class=&quot;headerlink&quot; title=&quot;Buy a ticket&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="最短路" scheme="http://github.com/xxq1999/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论" scheme="http://github.com/xxq1999/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Cashback (DP 区间最小值)</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-Cashback-(DP-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%B0%8F%E5%80%BC)/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-Cashback-(DP-区间最小值)/</id>
    <published>2018-04-18T07:57:23.000Z</published>
    <updated>2018-04-18T08:19:57.357Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Cashback"><a href="#Cashback" class="headerlink" title="Cashback"></a>Cashback</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>输入n和c。接下来给出长度为n的数组A。你可以将数组A划分成任意个子数组，假设其中一个子数组的长度为k，那么可以减去这个子数组内前k/c个（向下取整）小的数。要使划分后数组内的元素和最小，问最小的和为多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>预感到是DP，但是没有什么L用……</p><p>分析一下：如果其中一个子数组的长度k&lt; c，那么这个数组就一个也不能减少；如果长度k=c，那么就刚好减少一个；如果长度在c&lt; k&lt; 2c之间，并没有任何贡献，还是只能少一个。也就是说，长度正好为c的数组是优秀的。那么长度为2c的数组呢？我们假设[0,c-1]内，最小的数字为min1，第二小的是min2，[c,2c-1]内，最小的数字为min3，那么，如果min2&lt; min3，对于划分（2个长度为c）来说，消去的数字是min1+min3，而对于划分（1个长度为2c），消去的数字就是min1+min2，显然是两个c长度的划算。如果min2&gt;=min3，对于划分成（2个长度为c）来说，消去的数字就是min1+min3，对于划分（一个长度为2c），消去的数字为min1+min3，两者是相等的。因此综上而言，将数组划分成长度为c的小数组更划算一些。</p><p>那么就用到dp了，dp[i]指 前i个数字的最小和。</p><p>对于一个数字a[i]来说，（i&gt;c）dp[i] 要么是接受前一个数字的dp再加上自己的大小，要么就是重新进入一个长度是c的数组，起始index为i-c+1，dp[i]=dp[i-c] (前i-c的最小和）+sum[i]-sum[i-c] （这一段新的长度为c的数组的总和）- min{a[i-c+1], … , a[i] }（这一段长度是c的区间里的最小值），即：</p><p><strong>dp[i] = min(dp[i-1]+a[i] , dp[i-c] + sum[i] - sum[i-c] -  min{a[i-c+1], … , a[i] } )</strong></p><p>对于区间最小值min，用一个multiset维护就好了。multiset里只放当前i为最后一个数字的c个数字。而multiset中的.begin() 会返回容器中最小的数的指针。如果去掉最前面一个放进来的数字呢？. erase( .find(a[i-c+1]))就好了。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX],a[MAX]; <span class="comment">//dp[i]指前i个元素相加的最小和</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX]; <span class="comment">//前i个元素和</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;s; <span class="comment">//s用来维护长度为c的区间内的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">dp[i]=sum[i]=sum[i<span class="number">-1</span>]+a[i]; </span><br><span class="line"><span class="comment">//初始化dp值，显然长度不足c的dp值为前i个数之和，其他的默认初始值为前i个数之和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)</span><br><span class="line">        s.insert(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s.insert(a[i]);</span><br><span class="line">        dp[i]=min(dp[i<span class="number">-1</span>]+a[i],dp[i-c]+sum[i]-sum[i-c]-*s.begin());</span><br><span class="line">        <span class="comment">//前一个数加上自己的和，前一个c区间及之前的最小和加上这个新的c区间的总和，减去这个区间的最小值</span></span><br><span class="line">        s.erase(s.find(a[i-c+<span class="number">1</span>]));<span class="comment">//删去下一步到了区间外的数字</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Cashback&quot;&gt;&lt;a href=&quot;#Cashback&quot; class=&quot;headerlink&quot; title=&quot;Cashback&quot;&gt;&lt;/a&gt;Cashback&lt;/h1
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CodeForces" scheme="http://github.com/xxq1999/tags/CodeForces/"/>
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>二数(就没啥)</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-%E4%BA%8C%E6%95%B0(%E5%B0%B1%E6%B2%A1%E5%95%A5)/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-二数(就没啥)/</id>
    <published>2018-04-15T12:22:44.000Z</published>
    <updated>2018-04-15T12:41:19.305Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="二数"><a href="#二数" class="headerlink" title="二数"></a><a href="https://www.nowcoder.com/acm/contest/91/I" target="_blank" rel="noopener">二数</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个T&lt;=100,一个n, 1&lt;=n&lt;=10^100000-1 </p><p>二数：十进制下每一位都是偶数的数</p><p>求离n最近的二数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用字符串存。</p><p>思考可以得到，对于n要么向小了变，要么向大了变。</p><p>遍历，对于遇到的第一个奇数k，</p><p>1、变小：k– </p><p>​      然后其他所有的数字都变成‘8’</p><p>2、变大：k++</p><p>​     然后其他所有数字变成’0‘</p><p>对于k==’9’的情况，直接取变小就好了，因为变小的代价肯定小于变大的代价。</p><p>然后比较谁更近的话，从高位开始一位一位的比较差值大小就好了……</p><p>输出的时候去掉前导0，就好了……</p><p>（代码依旧丑，其实很多地方可以改进，但我也懒得……）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,len,flag;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="built_in">string</span> s,sm,sb;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        len=s.size(),flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>&amp;&amp;(s[<span class="number">0</span>]==<span class="string">'1'</span>||s[<span class="number">0</span>]==<span class="string">'0'</span>)) &#123; <span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>; &#125; <span class="comment">//1 0特判一下</span></span><br><span class="line">        sm=sb=s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="comment">//向下,</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((sm[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) sm[i]--,flag=<span class="number">1</span>; <span class="comment">//第一个数变小</span></span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//后面的数变大</span></span><br><span class="line">                    <span class="keyword">if</span>(sm[i]==<span class="string">'9'</span>) sm[i]=<span class="string">'8'</span>; <span class="comment">//9变8</span></span><br><span class="line">                    <span class="keyword">else</span> sm[i]=<span class="string">'8'</span>; <span class="comment">//其他数字变8</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">                sm[i]=<span class="string">'8'</span>; <span class="comment">//其他数字变8</span></span><br><span class="line">        &#125;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="comment">//向上</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((sb[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sb[i]==<span class="string">'9'</span>&amp;&amp;flag==<span class="number">0</span>) <span class="comment">//9同sm</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sb=sm;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)  sb[i]++,flag=<span class="number">1</span>;<span class="comment">//第一个变大</span></span><br><span class="line">                <span class="keyword">else</span> sb[i]=<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) sb[i]=<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line"></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]-sm[i])&lt;(sb[i]-s[i])) <span class="comment">//前者小</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]-sm[i])&gt;(sb[i]-s[i])) <span class="comment">//后者小</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>) s=sb;</span><br><span class="line">        <span class="keyword">else</span> s=sm;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) &#123; flag=<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]); &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;二数&quot;&gt;&lt;a href=&quot;#二数&quot; class=&quot;headerlink&quot; title=&quot;二数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>K序列（DP）</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-K%E5%BA%8F%E5%88%97%EF%BC%88DP%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-K序列（DP）/</id>
    <published>2018-04-15T12:03:55.000Z</published>
    <updated>2018-04-15T12:41:38.349Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="K序列"><a href="#K序列" class="headerlink" title="K序列"></a><a href="https://www.nowcoder.com/acm/contest/91/L" target="_blank" rel="noopener">K序列</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个数组 a，长度为 n，若某个子序列中的和为 K 的倍数，那么这个序列被称为“K 序列”。对数组 a 求出最长的子序列的长度，满足这个序列是 K 序列。 </p><p>输入一个n，k，接下来输入n个整数，表示A[1]~A[n] ,1&lt;=n&lt;=1e5,1&lt;=a[i]&lt;=1e9,1&lt;=nK&lt;=1e7。输出最长子序列的长度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又一道DP。</p><p>dp[i][j] : 表示前i个数中，对k取模余数为j的最长的子序列长度</p><p>dp[i][j] =max (dp[i-1][j],dp[i-1][(k-a[i]%k+j)%k]+1) </p><p>解释一下，指的是上一层（前i-1个数字）余数一样的，和上一层再加上a[i]（前i个数字）[余数]+1。</p><p>这里有个条件是要判断一下这个取模的余数是否已经存在了，不然就不能比较。</p><p>讲的不太清楚，看代码吧。</p><p>（这里用二维 vector存dp）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;dp(n+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        dp[i].resize(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%k==j) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][(j-a[i]%k+k)%k]!=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][(j-a[i]%k+k)%k]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;K序列&quot;&gt;&lt;a href=&quot;#K序列&quot; class=&quot;headerlink&quot; title=&quot;K序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcod
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>1+2=3?(奇怪的斐波那契规律题)</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-1+2=3(%E5%A5%87%E6%80%AA%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E8%A7%84%E5%BE%8B%E9%A2%98)/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-1+2=3(奇怪的斐波那契规律题)/</id>
    <published>2018-04-15T11:58:34.000Z</published>
    <updated>2018-04-15T12:46:45.926Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="1-2-3？"><a href="#1-2-3？" class="headerlink" title="1+2=3？"></a><a href="https://www.nowcoder.com/acm/contest/91/F" target="_blank" rel="noopener">1+2=3？</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个T，接下来T行，每行一个N，输出满足 x异或2x== 3x 的第N个数字。</p><p>T&lt;=100,N&lt;=1e12</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>打了表，<a href="http://oeis.org/?language=english" target="_blank" rel="noopener">整数数列百科全书</a>中找到符合规律的数列，观察二进制形式后发现：</p><p><img src="\mdpicture\FB.jpg" alt="规律"></p><p>斐波那契数列：</p><p>1 2 3 5 8 13 21 34 55 ……</p><p>题中若N=60，则60= 55 + 5 （第9项+第4项）</p><p>则第60个满足条件的数为：1(9)00001(4)000 = 264 (4、9号位数为1，其他都是0)</p><p>由于1e12小于斐波那契的第59项，故开一个59大的数组，里面存斐波那契数，然后对于每一个N寻找最少的组成它的斐波那契数，找到他是第x项，那么ans+2^x即可。</p><p>（问题是我的代码怎么这么丑= =）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;fei; <span class="comment">//算斐波那契 1 2 3 5这样的</span></span><br><span class="line">    fei.push_back(<span class="number">1</span>);fei.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(fei[fei.size()<span class="number">-1</span>]&lt;(<span class="number">1e12</span>+<span class="number">5</span>)) fei.push_back(fei[fei.size()<span class="number">-1</span>]+fei[fei.size()<span class="number">-2</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        temp=n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> weishu[<span class="number">100</span>],x=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)</span><br><span class="line">            weishu[i]=x,x*=<span class="number">2</span>; <span class="comment">//计算2的i次</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">57</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=fei[i]) <span class="comment">//找能组成他的斐波那契数，直接算</span></span><br><span class="line">                temp-=fei[i],ans+=weishu[i];</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;1-2-3？&quot;&gt;&lt;a href=&quot;#1-2-3？&quot; class=&quot;headerlink&quot; title=&quot;1+2=3？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="http://github.com/xxq1999/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
      <category term="规律" scheme="http://github.com/xxq1999/tags/%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>归途</title>
    <link href="http://github.com/xxq1999/2018/04/05/%E5%BD%92%E9%80%94/"/>
    <id>http://github.com/xxq1999/2018/04/05/归途/</id>
    <published>2018-04-05T07:20:41.640Z</published>
    <updated>2018-04-05T07:57:54.405Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="\mdpicture\拉杆箱会飞吗.jpg" alt="如果拉杆箱会飞"></p><p>回家，带着我的拉杆箱。</p><p>拉杆箱好沉啊，下着雨，要撑伞。红色的卫衣，薄荷绿的伞。</p><p><br></p><h2 id="城隍百味"><a href="#城隍百味" class="headerlink" title="城隍百味"></a>城隍百味</h2><p><img src="\mdpicture\城隍百味.jpg" alt="城隍庙地铁站"></p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>和小可爱在一起。</p><p>“我要吃三色杯！”</p><p>“上口爱！”</p><p>“给我尝一口！”</p><p>“好冷呐哥！”</p><p>“我要吃炸鱿鱼！”</p><p>“好脆呀！”</p><p>“别扯呀别扯！”</p><p>“我没我咬不动！”</p><p>“看你满嘴！”</p><p>“哼！”</p><p>“老板来三根肉串！”</p><p>“还吃……”</p><p>“臭豆腐要吗！”</p><p>“……要！”</p><p>“来一口！”</p><p>“哇呜是香菜！！TOT “</p><p>“很香！”</p><p>“哦这个味道！”</p><p>“这才是真正的臭豆腐！”</p><p>“霉的很完美！”</p><p>“……”</p><p><br></p><p><img src="\mdpicture\臭豆腐.jpg" alt="城隍庙臭豆腐"></p><p><br></p><h3 id="遇"><a href="#遇" class="headerlink" title="遇"></a>遇</h3><p>老地方，又遇见了一个乞讨的老爷爷，但是好像没有人愿意给他钱。</p><p>以前也遇到过一次，等饮料的时候，他伸出破烂的碗，看着我，上下颠一颠，几块钱硬币在碗里面当啷响。</p><p>我犹豫着响掏出一点碎钱，被小可爱制止了。</p><p>貌似有些残酷的冲老爷爷摆摆手，然后拿了饮料转身离开，给他一个背影。</p><p>后来我们往下走，在风很大的路口遇见了一个卖报纸的老婆婆，忘记了多少钱一份，两块还是三块？只记得小可爱二话不说就买了一份。报纸还是过期的，早就不知道哪儿去了。</p><p>记得他当时这样说：</p><p>“如果我们刚才给了那个乞丐钱，那对这个辛苦卖报的老婆婆是不是不公平？”</p><p><br></p><h2 id="归途"><a href="#归途" class="headerlink" title="归途"></a>归途</h2><blockquote><p>不断更新着的一切</p><p>高楼 大厦</p><p>人</p></blockquote><p><img src="\mdpicture\高樓.jpg" alt="萬達新樓"></p><p><br></p><blockquote><p>清明时节雨 纷纷</p></blockquote><p><img src="\mdpicture\我.jpg" alt="潮湿的"></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;\mdpicture\拉杆箱会飞吗.jpg&quot; alt=&quot;如果拉杆箱会飞&quot;&gt;&lt;/p&gt;
&lt;p&gt;回家，带着我的拉杆箱。&lt;/p&gt;
&lt;p&gt;拉杆箱好沉啊，下着雨，要撑
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Missing Leslie</title>
    <link href="http://github.com/xxq1999/2018/04/01/2018-04-01-Missing-Leslie/"/>
    <id>http://github.com/xxq1999/2018/04/01/2018-04-01-Missing-Leslie/</id>
    <published>2018-04-01T14:40:00.000Z</published>
    <updated>2018-04-02T05:08:20.276Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="\mdpicture\Leslie1.jpg" alt="春天该很好，你若尚在场"></p><blockquote><p>春天该很好，你若尚在场。</p></blockquote><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;\mdpicture\Leslie1.jpg&quot; alt=&quot;春天该很好，你若尚在场&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;春天该很好，你若尚在场。&lt;/
      
    
    </summary>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>CF 957C Three-level Laser (二分)</title>
    <link href="http://github.com/xxq1999/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(%E4%BA%8C%E5%88%86)/"/>
    <id>http://github.com/xxq1999/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(二分)/</id>
    <published>2018-04-01T14:24:00.000Z</published>
    <updated>2018-07-28T18:05:34.236Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Three-level-Laser"><a href="#Three-level-Laser" class="headerlink" title="Three-level Laser"></a><a href="http://codeforces.com/contest/957/problem/C" target="_blank" rel="noopener">Three-level Laser</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>输入一个n，m，n代表接下来有n个数字（从小到大），</p><p>接下来从n个数字中选3个数字i，j，k（i&lt;j&lt;k），</p><p>使得k-j/k-i 最大，且（k-i）&lt;=m。(n&lt;1e5)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开头直接写，j=1开始遍历，要让值最大，i=j-1,（必定），k为可允许内最大的值。</p><p>用for找k，会T，于是改用二分，输出用.15f（精度限制，double到.6）。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,U;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;U);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1=a[i],t2=a[i+<span class="number">1</span>],up=U+t1;</span><br><span class="line">        <span class="keyword">int</span> k=upper_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,up)-a<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i+<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res=max(res,(a[k]-t2*<span class="number">1.0</span>)/(a[k]-t1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Three-level-Laser&quot;&gt;&lt;a href=&quot;#Three-level-Laser&quot; class=&quot;headerlink&quot; title=&quot;Three-le
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CodeForces" scheme="http://github.com/xxq1999/tags/CodeForces/"/>
    
      <category term="二分" scheme="http://github.com/xxq1999/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
</feed>

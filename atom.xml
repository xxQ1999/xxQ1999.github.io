<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>まだまだだね</title>
  
  <subtitle>飞光飞光，劝你一杯酒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/xxq1999/"/>
  <updated>2018-12-13T13:31:59.123Z</updated>
  <id>http://github.com/xxq1999/</id>
  
  <author>
    <name>XXQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>承诺</title>
    <link href="http://github.com/xxq1999/2018/12/13/%E6%89%BF%E8%AF%BA/"/>
    <id>http://github.com/xxq1999/2018/12/13/承诺/</id>
    <published>2018-12-13T13:31:59.121Z</published>
    <updated>2018-12-13T13:31:59.123Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 记得 "/> <label for="pass"> 记得 </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/PELJmLlhVdem5aIgH53AcF5I8L9a7a/xEeE1stWEYGd4js3wTVc5719EIxR7tOYfSaDD7HnGR7zt3p8AkWRTgcK0OPYbYArfzbprK8OMPrwakJPWRCYquWYlSD8ncOfl5T4dFn9Qzw+UrHnolRewnABXwHr0K0kV24WtbJOp8yKgWYSB4MTa/KjOdUG1I8syxxTttDHaJSofiiIbcsC3+iMF5XUamVp0AC7QceErbGftM4IzIHnbhsP8n+ZJj/7lwA2k8QTb39cu3rcBAqpZjICGSpfdpB4NfNvRKJZ1J8HLqPWmEB9X/MxcB8VgxMl/0iWtNug647w== </div>]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How many integers can you find（容斥裸）</title>
    <link href="http://github.com/xxq1999/2018/09/08/How-many-integers-can-you-find%EF%BC%88%E5%AE%B9%E6%96%A5%E8%A3%B8%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/09/08/How-many-integers-can-you-find（容斥裸）/</id>
    <published>2018-09-08T02:41:14.073Z</published>
    <updated>2018-09-08T02:41:14.073Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="How-many-integers-can-you-find"><a href="#How-many-integers-can-you-find" class="headerlink" title="How many integers can you find"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1796" target="_blank" rel="noopener">How many integers can you find</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个n，一个长度为m的集合，集合里面有m个元素，问小于n的所有能被集合中任意元素整除的数字有多少。</p><p>n&lt;2^31,m&lt;=10</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//欧几里得算法，求最大公约数。</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> GCD(b, a % b); <span class="comment">//辗转相除。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//求最小公倍数。</span></span><br><span class="line">    <span class="keyword">return</span> a / GCD(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//深度优先搜索实现容斥原理。</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> Cnt_Manifold; <span class="comment">//遍历到的数的数量（数集的数量）。</span></span><br><span class="line">    <span class="keyword">int</span> Least_Common_Multiple; <span class="comment">//遍历到的Cnt_Manifold个数的最小公倍数。</span></span><br><span class="line">    Result = <span class="number">0</span>; <span class="comment">//记录每次深度搜索的结果。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123; <span class="comment">//i的二进制位代表此次遍历查找的是那几个数</span></span><br><span class="line">        Cnt_Manifold = <span class="number">0</span>;</span><br><span class="line">        Least_Common_Multiple = <span class="number">1</span>; <span class="comment">//1与任何数的最小公倍数还是那个数本身，所以初值赋为1.</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123; <span class="comment">//筛选出要找的数并求出他们的最小公倍数。</span></span><br><span class="line">                Cnt_Manifold++;</span><br><span class="line">                Least_Common_Multiple = LCM(Least_Common_Multiple, p[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (Cnt_Manifold &amp; <span class="number">1</span>) &#123; <span class="comment">//奇数个为正偶数个为负，其作用相当于(-1)^(n - 1).</span></span><br><span class="line">            Result += n / Least_Common_Multiple;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Result -= n / Least_Common_Multiple;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp; <span class="comment">//去除了0的情况</span></span><br><span class="line">            <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">                p[cnt++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m = cnt;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Solve(n - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;How-many-integers-can-you-find&quot;&gt;&lt;a href=&quot;#How-many-integers-can-you-find&quot; class=&quot;h
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="容斥" scheme="http://github.com/xxq1999/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>GCD?LCM!(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/20/GCDLCM!(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/20/GCDLCM!(莫比乌斯反演)/</id>
    <published>2018-08-20T15:17:51.129Z</published>
    <updated>2018-08-20T15:17:51.129Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="GCD-LCM"><a href="#GCD-LCM" class="headerlink" title=" GCD?LCM!"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382" target="_blank" rel="noopener"> GCD?LCM!</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>哈哈哈哈哈懵逼钨丝做的我一本满足，爽歪歪，推公式好塔马有趣儿</p><p>咳咳，题目是：</p><p>咳咳，题目是：<br>$$<br>F(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n]<br>$$</p><p>$$<br>S(n)=\sum_{i=1}^nF(n)<br>$$</p><p>t组，每组给你一个n，求S(n)。</p><p>t&lt;=1e5,n&lt;=1e6</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$$<br>F(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n]<br>$$</p><p>$$<br>=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n-1]-\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p><code>由于对于后半部分来说，i，j=n时显然不符合，因此可直接降为n-1</code><br>$$<br>=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\ge n-1]-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$<br><code>将前半部分转化成F(n-1)，故修改i，j的上限，而i，j=n时一定满足要求，因此要补上2n-1</code><br>$$<br>=\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)\ge n-1]+(2n-1)-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p>$$<br>=F(n-1)+(2n-1)-\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]<br>$$</p><p><code>令后半部分为T(n-1),则：</code><br>$$<br>F(n)=F(n-1)+(2n-1)-T(n-1)<br>$$<br>接下来分析T(n)<br>$$<br>T(n)=\sum_{i=1}^n\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n]<br>$$<br>令d=gcd(i,j)，又由于lcm(i,j)=ij*(gcd(i,j))，令i=id，j=jd<br>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}<br>[ijd+d==n][gcd(i,j)==1]<br>$$</p><p>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}<br>[j=\frac{\frac{n}{d}-1}{i}][gcd(i,j)==1]<br>$$</p><p>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}<br>[gcd(i,\frac{\frac{n}{d}-1}{i})==1]<br>$$</p><p>由于$\ i = \frac{n}{d}$ 时，条件显然不成立，因此修改i的上限<br>$$<br>=\sum_{d|n}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor-1}<br>[gcd(i,\frac{\frac{n}{d}-1}{i})==1]<br>$$<br>令后半部分为$ G(\frac{n}{d}-1) $<br>$$<br>T(n)=\sum_{d|n}G(\frac{n}{d}-1)<br>$$<br>接下来分析G(n)<br>$$<br>G(n)=\sum_{i=1}^n[gcd(i,\frac{n}{i})==1]<br>$$<br>要满足后半部分，我们打表（或者根据思考（？？？））发现<br>$$<br>G(n)=2^k,k为n的质因子个数<br>$$<br>那么到这里，基本上要推的就都推完了，</p><p>差一个总和。</p><p>由于：<br>$$<br>F(n)=F(n-1)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>=F(n-2)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>=F(n-3)+(2(n-2)-1)-T(n-3)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)<br>$$</p><p>$$<br>……<br>$$</p><p>$$<br>=F(1)+\sum_{i=1}^n(2i-1)-\sum_{i=0}^{n-1}T(i)<br>$$</p><p>故：<br>$$<br>S(n)=\sum_{i=1}^n(F(1)+\sum_{j=1}^i(2j-1)-\sum_{j=0}^{i-1}T(j))<br>$$</p><p>$$<br>S(n)=nF(1)+\sum_{i=1}^ni^2-\sum_{i=1}^n\sum_{j=0}^{i-1}T(i)<br>$$</p><p>$$<br>=n+\frac{n(n+1)(2n+1)}{6}-\sum_{i=1}^n\sum_{j=0}^{i-1}T(i)<br>$$</p><p>我们一步一步来：</p><ol><li>预处理，先筛出所有质数，然后是1~1e6的质因子个数，然后求得G(n)，再求得T(n)，然后对T(n)求一次前缀和得到每个sum[i]，再对每个sum[i]求前缀和ans[i]=sum[i-1]+ans[i-1]。</li><li>没有2了，对于每个输入的n直接用刚刚最后那个公式带进去算就好了：</li></ol><p>$$<br>S(n)=n+\frac{n(n+1)(2n+1)}{6}-ans[n]<br>$$</p><p>哦，别忘了取模。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">258280327</span>;</span><br><span class="line"><span class="comment">/** 对于μ函数的线筛 */</span></span><br><span class="line"><span class="keyword">int</span> prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll sum[N]=&#123;<span class="number">0</span>&#125;,ans[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll liu;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">PowerMod</span><span class="params">(ll x,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    res=res*x;</span><br><span class="line">    res=res%MOD;</span><br><span class="line">   &#125;</span><br><span class="line">   x=x*x;</span><br><span class="line">   x=x%MOD;</span><br><span class="line">   n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i++) <span class="comment">//素数筛</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)prim[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prim[j]&lt;N;j++)</span><br><span class="line">            vis[i*prim[j]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=N;n++) <span class="comment">//求质因子个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=n;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;prim[i]*prim[i]&lt;=tmp; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp%prim[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p[n]++;</span><br><span class="line">                <span class="keyword">while</span>(tmp%prim[i]==<span class="number">0</span>) tmp/=prim[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">            p[n]++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)  <span class="comment">//求2^k</span></span><br><span class="line">        p[i]=PowerMod(<span class="number">2</span>,p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=N;d++)  <span class="comment">//  求T(n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d&lt;=N;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[k*d]=(sum[k*d]+p[k<span class="number">-1</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="comment">//求sum[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=(sum[i]+sum[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="comment">//求ans[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[i]=(sum[i<span class="number">-1</span>]+ans[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n*(n+<span class="number">1</span>)%MOD*(<span class="number">2</span>*n+<span class="number">1</span>)%MOD*liu%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    liu=PowerMod(<span class="number">6</span>,MOD<span class="number">-2</span>);</span><br><span class="line">    Solve(<span class="number">1000000</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(cal(n)+n-ans[n]+MOD)%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;GCD-LCM&quot;&gt;&lt;a href=&quot;#GCD-LCM&quot; class=&quot;headerlink&quot; title=&quot; GCD?LCM!&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Mophues(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/20/Mophues(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/20/Mophues(莫比乌斯反演)/</id>
    <published>2018-08-19T17:39:30.679Z</published>
    <updated>2018-08-19T17:39:30.679Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Mophues"><a href="#Mophues" class="headerlink" title="  Mophues"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4746" target="_blank" rel="noopener">  Mophues</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>若a的质因子个数&lt;=P，则称a为p的一个lucky number。</p><p>给你n，m，P，求在n，m范围内的i，j，gcd(i,j)是P的lucky number，这样的i，j有几对？</p><p>n，m，P&lt;=5e5。多组不超过5000组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意就是让我们求：<br>$$<br>\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j)),其中f(x)表示x的质因子个数比p小<br>$$<br>反演过程就不具体写了，我们可以轻松得到结果：<br>$$<br>\sum_{t=1}^{min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d|t}f(d)μ(\frac{t}{d})<br>$$<br>经过计算我们发现，5e5内的数字最大的质因数个数为18，那么对于大于18的p我们就可以降为18。</p><p>首先对5e5内的数预处理出它们的质因子个数。</p><p>然后枚举d，用sum[i][j]表示当t=i时，质因子个数为j的数的μ之和。</p><p>再对sum[i][j]求t=i时质因子个数小于等于j的μ之和。</p><p>然后对每一个t的sum求一个前缀和。</p><p>就可以分块做了。</p><p>注意ans和sum还是要开longlong。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">/** 对于μ函数的线筛 */</span></span><br><span class="line"><span class="keyword">int</span> mu[N],prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll p[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ll sum[N][<span class="number">21</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        vis[prim[j]*i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(ll N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int MAX=0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=N;n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=n;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;prim[i]*prim[i]&lt;=tmp; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp%prim[i]==<span class="number">0</span>) p[n]++,tmp/=prim[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)</span><br><span class="line">            p[n]++;  <span class="comment">//这个不可以缺少</span></span><br><span class="line">        <span class="comment">//MAX=max(MAX,p[n]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d&lt;=N;d++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d&lt;=N;k++)</span><br><span class="line">            sum[k*d][p[d]]+=mu[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=N;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">            sum[t][i]+=sum[t][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">19</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=N;t++)</span><br><span class="line">            sum[t][i]+=sum[t<span class="number">-1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,u,v;</span><br><span class="line">    get_mu(<span class="number">500000l</span>l);</span><br><span class="line">    Solve(<span class="number">500000l</span>l);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m,P;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;P);</span><br><span class="line">        <span class="keyword">if</span>(P&gt;<span class="number">18</span>) P=<span class="number">18</span>;</span><br><span class="line">        <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=MIN;l=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=min(n/(n/l),m/(m/l));</span><br><span class="line">            ans+=<span class="number">1l</span>l*(n/l)*(m/l)*(sum[r][P]-sum[l<span class="number">-1</span>][P]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Mophues&quot;&gt;&lt;a href=&quot;#Mophues&quot; class=&quot;headerlink&quot; title=&quot;  Mophues&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>带劲and和（连通块+&amp;结论）</title>
    <link href="http://github.com/xxq1999/2018/08/19/%E5%B8%A6%E5%8A%B2and%E5%92%8C%EF%BC%88%E8%BF%9E%E9%80%9A%E5%9D%97+&amp;%E7%BB%93%E8%AE%BA%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/19/带劲and和（连通块+&amp;结论）/</id>
    <published>2018-08-19T15:56:35.391Z</published>
    <updated>2018-08-19T17:42:04.462Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="带劲的and和"><a href="#带劲的and和" class="headerlink" title="带劲的and和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6411" target="_blank" rel="noopener">带劲的and和</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>度度熊有一张n个点m条边的<strong>无向图</strong>，第i个点的点权为vi。<br>如果图上存在一条<strong>路径</strong>使得点i可以走到点j，则称i,j是<strong>带劲</strong>的，记f(i,j)=1；否则f(i,j)=0。显然有f(i,j)=f(j,i)。<br>度度熊想知道求出：<br>$\sum_{i=1}^{n−1}\sum_{j=i+1}^nf(i,j)×max(v_i,v_j)×(v_i\&amp;v_j)$<br>其中&amp;是C++中的and位运算符，如1&amp;3=1, 2&amp;3=2。<br>请将答案对109+7取模后输出。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先处理连通块。</p><p>这里我用的是并查集，也可以用tarjan，然后对于每个连通块里的元素，我们按照从小到大排序。</p><p>由于比如 9 8 7 这部分时，默认我们已经知道9是最大的元素，那么一定是9*(9&amp;8+9&amp;7),由于与运算是只有两位上的数字均为1时才能有贡献，那么也就是说，我们不需要对于每两个数字都计算&amp;运算，而可以对每一个数字的二进制位进行处理，当第i位上为1时，count[i]++，只有count[i]上的数&gt;=2时，才算对于这个有了贡献，并且我们是用同一的9去进行与运算，在count位&gt;=2时，也只有满足当9上的第i位也为1时才算数。</p><p>因此从小到达排序之后，从第一个元素开始，在它前面的元素一定比它小，因此我们只要对于这个元素上为1的位进行查询，看它的count是否大于等于2，然后确定是否产生贡献，ans+了后再把当前元素的这一位的count[i]++即可。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">///找跟根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=id[x])</span><br><span class="line">    &#123;</span><br><span class="line">        id[x]=id[id[x]];</span><br><span class="line">        x=id[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pr=Find(p);</span><br><span class="line">    <span class="keyword">int</span> qr=Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pr==qr) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[pr]&lt;=sz[qr])</span><br><span class="line">    &#123;</span><br><span class="line">        sz[qr]+=sz[pr];id[pr]=qr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz[pr]+=sz[qr];id[qr]=pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;fa[<span class="number">100010</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;val[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            un(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[Find(i)].push_back(val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            len=fa[i].size();</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sort(fa[i].begin(),fa[i].end());</span><br><span class="line">                <span class="keyword">int</span> wei[<span class="number">32</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> tmp=fa[i][j];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">30</span>&amp;&amp;tmp&gt;<span class="number">0</span>;k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ans=(ans+<span class="number">1l</span>l*wei[k]*fa[i][j]%MOD*(<span class="number">1</span>&lt;&lt;k)%MOD)%MOD;</span><br><span class="line">                            wei[k]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;带劲的and和&quot;&gt;&lt;a href=&quot;#带劲的and和&quot; class=&quot;headerlink&quot; title=&quot;带劲的and和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http:/
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CA Loves GCD(DP)</title>
    <link href="http://github.com/xxq1999/2018/08/19/CA-Loves-GCD(DP)/"/>
    <id>http://github.com/xxq1999/2018/08/19/CA-Loves-GCD(DP)/</id>
    <published>2018-08-19T15:48:10.566Z</published>
    <updated>2018-08-19T15:48:10.566Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="CA-Loves-GCD"><a href="#CA-Loves-GCD" class="headerlink" title="CA Loves GCD"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5656" target="_blank" rel="noopener">CA Loves GCD</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个数，从里面任取几个（至少1个），计算它们的gcd，问你所有可能的取法的gcd之和。</p><p>对结果模1e8+7（注意是8）</p><p>n&lt;=1000</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>dp[i][j]表示取前i个数时gcd为j的种数。</p><p>取第i个时：dp[i][gcd(a[i],j)] += dp[i-1][j] ；</p><p>不取第i个时：dp[i][j] += dp[i-1][j]；</p><p>对1000内的任意两个数的gcd作预处理，i从0开始。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> gcd[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="comment">/*int ggcd(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return b == 0 ? a : ggcd(b, a%b);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            gcd[i][j]=__gcd(i,j);</span><br><span class="line">            gcd[j][i]=gcd[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> MAX=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            MAX=max(MAX,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=MAX;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">                dp[i][gcd[a[i]][j]]=(dp[i][gcd[a[i]][j]]+dp[i<span class="number">-1</span>][j])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">            ans=(ans+<span class="number">1l</span>l*dp[n][i]*i)%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;CA-Loves-GCD&quot;&gt;&lt;a href=&quot;#CA-Loves-GCD&quot; class=&quot;headerlink&quot; title=&quot;CA Loves GCD&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="http://github.com/xxq1999/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Hillan and the girl(莫比乌斯反演)</title>
    <link href="http://github.com/xxq1999/2018/08/19/Hillan-and-the-girl(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94)/"/>
    <id>http://github.com/xxq1999/2018/08/19/Hillan-and-the-girl(莫比乌斯反演)/</id>
    <published>2018-08-19T10:08:57.948Z</published>
    <updated>2018-08-19T10:08:57.948Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5663" target="_blank" rel="noopener"> Hillan and the girl</a> </h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>对于1&lt;=n,m&lt;=1e7，T&lt;=1e4，求：<br>$$<br>\sum_{i=1}^{n}\sum_{j=1}^{m}f(gcd(i,j)),其中f(x)=1，当且仅当x为平方数<br>$$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>来，让我们来反演一波：<br>$$<br>\sum_{d=1}^{mim(n,m)}f(d)\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)==d]<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)==1]<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{t|gcd(i,j)}μ(t)<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dt}\rfloor}\sum_{t=1}^{min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}μ(t)<br>$$</p><p>$$<br>\sum_{d=1}^{min(n,m)}f(d)\sum_{t=1}^{min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}μ(t){\lfloor\frac{n}{dt}\rfloor}{\lfloor\frac{m}{dt}\rfloor}<br>$$</p><p>令dt=T，则：<br>$$<br>\sum_{T=1}^{min(n,m)}{\lfloor\frac{n}{T}\rfloor}{\lfloor\frac{m}{T}\rfloor\sum_{d|T}f(d)}μ(\frac{T}{d})<br>$$<br>由于$d=x^2$<br>$$<br>\sum_{T=1}^{min(n,m)}{\lfloor\frac{n}{T}\rfloor}{\lfloor\frac{m}{T}\rfloor\sum_{x=1}^{min(\sqrt{n},\sqrt{m})}\sum_{x^2|T}}μ(\frac{T}{x^2})<br>$$<br>对于T的前半部分，我们可以用分块，复杂度为$\sqrt{n}$，对于后半部分，就可以预处理出来。</p><p>枚举x，以及每一个$x^2$的倍数$k·x^2$，处理出每一个T的对应的值，然后再求前缀和。</p><p>预处理部分的复杂度为O(n)，求的时候的复杂度为$O(T\sqrt{n})$。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],prim[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prim[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[i*prim[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>;d*d&lt;=n;d++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k*d*d&lt;=n;k++)</span><br><span class="line">            sum[k*d*d]+=mu[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_mu(<span class="number">10000000</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=MIN;l=r+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r=min(n/(n/l),m/(m/l));</span><br><span class="line">            ans+=<span class="number">1l</span>l*(sum[r]-sum[l<span class="number">-1</span>])*(n/l)*(m/l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="number">1l</span>l*n*m-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5663&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Little Bishops（棋盘禁区排列）</title>
    <link href="http://github.com/xxq1999/2018/08/16/Little-Bishops%EF%BC%88%E6%A3%8B%E7%9B%98%E7%A6%81%E5%8C%BA%E6%8E%92%E5%88%97%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/16/Little-Bishops（棋盘禁区排列）/</id>
    <published>2018-08-16T15:08:09.844Z</published>
    <updated>2018-08-16T16:00:25.777Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1><a href="https://vjudge.net/problem/UVA-861" target="_blank" rel="noopener">Little Bishops</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在国际棋盘中，象的走法是斜对角线，也就是说两个象不能容于一条斜对角线。国际象棋有黑白两色格子相交组成。给你n*n的棋盘和k个象，问你在满足任意两个象互不相斥的情况下，摆放的最大种数？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用棋盘禁区排列这一思想。</p><p>首先我们可以看到，在棋盘中，黑色的格子和白色的格子上的象绝对不会相斥，所以我们可以根据$R_k(C)=R_i(C_1)*R_{k-i}(C-C_1)$得，Ans就是在黑色棋盘上放i个象的种类乘以在白色棋盘上放k-i个象的种数。</p><p>为了将黑白棋盘分开，比如要建立一个方便的白色棋盘，斜着看显然不舒服，那么我们就：</p><p>先把黑色格子删去，然后我们斜+45度看这个棋盘，把一斜看做一行，一斜中的格子数就是一行的格子数，同样的，斜-45度就是列中的格子数。又因为每行互换位置并不影响最终结果，因此我们可以把原本对称的棋盘行，进行格数从小到大排序，得到最终的棋盘。</p><p>注意，由于黑白棋盘不一样，对于一个n*n的棋盘来说，斜+45度看一共有2n-1个斜行，因此我们这里让白色棋盘占n行，黑色占n-1行，然后用另外的一个数组来存每行中有多少格子（列），基本的构造棋盘就完成了。</p><p>对于构造出来的棋盘（如白色），分析一下：</p><p>设mp[i][j]表示前i行放j个棋子的种数。那么有<br>$$<br>mp[i][j]=mp[i-1][j]+mp[i-1][j-1]·(c[i]-(j-1))<br>$$<br>相当于=前i-1行放了j个棋子，这一行不放的种数，加上前i-1行放了j-1个棋子乘以这一行只能在（格子数-已经被j-1个象占了的格子数量）个格子。</p><p>对两个棋盘都进行这样的操作即可。</p><p>最后的答案就是$\sum_{i=0}^{k}R_i(C_{white})·R_{k-i}(C_{black})$</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> mp1[<span class="number">10</span>][<span class="number">70</span>],mp2[<span class="number">10</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> c1[<span class="number">10</span>],c2[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>||k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mp1,<span class="number">0</span>,<span class="keyword">sizeof</span>(mp1));</span><br><span class="line">        <span class="built_in">memset</span>(mp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(mp2));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//白色棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) c1[i]=i;</span><br><span class="line">            <span class="keyword">else</span> c1[i]=c1[i<span class="number">-1</span>]; <span class="comment">//printf("i:%d\n",c1[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="comment">//黑色棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) c2[i]=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c2[i]=i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            mp1[i][<span class="number">0</span>]=mp2[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            mp1[i][j]=mp1[i<span class="number">-1</span>][j]+mp1[i<span class="number">-1</span>][j<span class="number">-1</span>]*(c1[i]-j+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">            mp2[i][j]=mp2[i<span class="number">-1</span>][j]+mp2[i<span class="number">-1</span>][j<span class="number">-1</span>]*(c2[i]-j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">            ans+=<span class="number">1l</span>l*mp1[n][i]*mp2[n<span class="number">-1</span>][k-i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1&gt;&lt;a href=&quot;https://vjudge.net/problem/UVA-861&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Little Bis
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排列组合" scheme="http://github.com/xxq1999/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>容斥与鸽巢定理</title>
    <link href="http://github.com/xxq1999/2018/08/16/%E5%AE%B9%E6%96%A5%E4%B8%8E%E9%B8%BD%E5%B7%A2%E5%AE%9A%E7%90%86/"/>
    <id>http://github.com/xxq1999/2018/08/16/容斥与鸽巢定理/</id>
    <published>2018-08-16T15:08:08.477Z</published>
    <updated>2018-08-31T04:44:11.425Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$<br>|A_1∪A_2∪…∪A_n|=\sum_{i=1}^n|A_i|-\sum_{i=1}^n\sum_{j&gt;i}|A_i∩A_j|+\sum_{i=1}^n\sum_{j&gt;i}\sum_{k&gt;j}|A_i∩A_j∩A_k|+…<br>$$</p><p>$$<br>+(-1)^{n-1}|A_1∩A_2∩…∩A_n|<br>$$</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h3><p><a href="http://xheartbeat.top/2018/08/14/%E9%94%99%E6%8E%92%EF%BC%88%E5%85%AC%E5%BC%8F+%E4%B8%89%E7%A7%8D%E7%94%9F%E6%88%90%EF%BC%89/" target="_blank" rel="noopener">【已写】</a></p><h3 id="棋盘多项式与有禁区的排列"><a href="#棋盘多项式与有禁区的排列" class="headerlink" title="棋盘多项式与有禁区的排列"></a>棋盘多项式与有禁区的排列</h3><h4 id="布棋问题"><a href="#布棋问题" class="headerlink" title="布棋问题"></a>布棋问题</h4><p>一个n*m棋盘上放k个棋子，其中任意两个棋子不能位于同一行或者同一列上。问种数。</p><p><strong>布棋方案数</strong> $R_k(C)$ <strong>:</strong> k个棋子依照上述规则放在棋盘C中的方案数</p><p><strong>棋盘多项式：</strong> 棋盘C中放不限定数量的棋子,$R(C)=\sum_{k=0}^∞R_k(C)x^k$（有点母函数的味道），由于k&lt;=C(格子数)，因此这个多项式也是有限的。</p><p><strong>放置：</strong> $R_k(C)=R_{k-1}(C_x)+R_k(C_e)$</p><pre><code>C表示这个棋盘，$C_x$表示放在棋盘C除去这个格子所在的行和列之后的棋盘，$C_e$表示棋盘C删去这个格子后的棋盘。那么这个公式的意思就是，在棋盘C上放k个棋子的种数，等于（第k个棋子放在一个格子上，前k-1个数量的格子放在除了这个格子所在的行和列的地方），加上，（k个棋子放在除了这个格子的其他地方）。</code></pre><p><strong>棋盘多项式性质：</strong></p><ol><li>$R(C)=xR(C_x)+R(C_e)$</li><li>若C由两个互不干扰的棋盘组成，有$R(C)=R(C_1)·R(C_2)$</li></ol><p><img src="\mdpicture\禁区棋盘排列实例.jpg" height="635" width="413" alt="棋盘排列构造多项式，利棋盘多项式的性质，如图"></p><h4 id="有禁区的排列"><a href="#有禁区的排列" class="headerlink" title="有禁区的排列"></a>有禁区的排列</h4><p><strong>排列数定理：</strong><br>$$<br>n！-r_1(n-1)!+r_2(n-2)!-…±r_n<br>$$<br>$r_i$表示有$r_i$个棋子布置到禁区的方案数。（<strong><em>仅适用n·n的棋盘</em></strong>）</p><p><strong>&lt; 例题 &gt;</strong> 有1,2,3,4号工人，A,B,C,D四个人物，1号不做B，2号不做B、C，3号不做C、D，4号不做D，问有多少种分配方式？</p><p>【解】先构造一个4*4的棋盘，然后画出这个棋盘的禁区，对于这个禁区计算它的棋盘多项式，得$R(C)=1+6x+10x^2+4x^3$，因此用容斥的思想，得到：<br>$$<br>4!- 6·(4-1)!+10·(4-2)!-4·(4-3)! +0(4-4)!= 4<br>$$</p><p><img src="\mdpicture\禁区棋盘例题.jpg" height="123" width="296" alt="例题棋盘禁区如图所示，构造的多项式原理同上图"></p><h1 id="鸽巢定理"><a href="#鸽巢定理" class="headerlink" title="鸽巢定理"></a>鸽巢定理</h1><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>n+1只鸽子飞回n个鸽巢，至少有一个鸽笼含有不少于2只的格子。</strong></p><p><strong>数学描述：</strong></p><p><strong>m($1\le m$)个元素分成n个组，那么总有一个组至少含有元素个数$\lceil\frac{m}{n}\rceil$</strong></p><h2 id="小应用"><a href="#小应用" class="headerlink" title="小应用"></a>小应用</h2><ol><li><p><strong>对于正整数序列，$a_1，a_2，…，a_m$，至少存在整数k和l, $1\le k&lt;l\le m$，使得$a_k+a_{k+1}+…+a_l$是m的倍数。</strong></p><p>【证明】对每个元素$a_i$构造一个前缀和sum[i]，则有两种可能性：</p><p>(1) 若有一个sum[i]是m的倍数，则证毕；</p><p>(2) 若没有一个sum[i]为m的倍数，则令$r_h\equiv S_h mod\ m $ 。    </p><p>其中，h=1,2,…,m，我们已知上面所有的项都非m的倍数，故余数r[i]的范围在[1,m-1]，共m个数，根据鸽巢定理，m个余数在[1,m-1]共m-1的范围内至少存在一对$r_h$,$r_k$，满足$r_k=r_h$,则sum[k]和sum[h]满足：<br>$$<br>S_k\equiv S_h mod \ m<br>$$<br>设h&gt;k的话，得到<br>$$<br>S_h-S_k=(a_1+a_2+…+a_h)-(a_1+a_2+…+a_k)<br>=a_{k+1}+…+a_h\equiv 0\ mod \ m<br>$$<br>证毕。</p></li><li><p><strong>中国剩余定理</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;容斥&quot;&gt;&lt;a href=&quot;#容斥&quot; class=&quot;headerlink&quot; title=&quot;容斥&quot;&gt;&lt;/a&gt;容斥&lt;/h1&gt;&lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习" scheme="http://github.com/xxq1999/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Halloween treats（鸽巢定理）</title>
    <link href="http://github.com/xxq1999/2018/08/16/Halloween-treats%EF%BC%88%E9%B8%BD%E5%B7%A2%E5%AE%9A%E7%90%86%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/16/Halloween-treats（鸽巢定理）/</id>
    <published>2018-08-16T15:08:07.121Z</published>
    <updated>2018-08-16T15:07:21.510Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Halloween-treats"><a href="#Halloween-treats" class="headerlink" title="Halloween treats"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1808" target="_blank" rel="noopener">Halloween treats</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有c个小朋友，n户家庭，n户家庭中每户分别有$a_i$个糖果，小朋友们可以向任意户家庭讨糖果，最终的糖果被小朋友平均分，问你向哪几户人家讨糖果可以使得平均分成立？（任意输出即可）</p><p>如果没有输出“no sweets”。</p><p>1&lt;=c&lt;=n&lt;=100000</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>鸽巢定理的应用。</p><p>对于正整数序列，$a_1，a_2，…，a_m$，至少存在整数k和l,1&lt;=k&lt;l&lt;=m，使得$a_k+a_{k+1}+…+a_l$是m的倍数。（证明见容斥和鸽巢定理介绍）</p><p>因此对每个数i求前缀，第一，如果前缀本身就能被c整除，那么输出1~i，否则，sum[i]%=c；第二，如果有任意两个sum[i],sum[j]对c取模后相等，则证明$a_{i+1}到a_j$的数之和是c的倍数。输出这几个数即可。</p><p>注意，这个定理的条件是c不大于n。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;same[c+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">            <span class="keyword">if</span>(sum[i]%c==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                same[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">                same[<span class="number">0</span>].push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[i]%=c;</span><br><span class="line">            same[sum[i]].push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(same[sum[i]].size()==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=sum[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"no sweets"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=same[flag][<span class="number">0</span>],b=same[flag][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a+<span class="number">1</span>;i&lt;b;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Halloween-treats&quot;&gt;&lt;a href=&quot;#Halloween-treats&quot; class=&quot;headerlink&quot; title=&quot;Halloween 
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排列组合" scheme="http://github.com/xxq1999/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>整数划分(裸五边形定理)</title>
    <link href="http://github.com/xxq1999/2018/08/15/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86(%E8%A3%B8%E4%BA%94%E8%BE%B9%E5%BD%A2%E5%AE%9A%E7%90%86)/"/>
    <id>http://github.com/xxq1999/2018/08/15/整数划分(裸五边形定理)/</id>
    <published>2018-08-15T15:26:09.573Z</published>
    <updated>2018-08-16T16:00:59.180Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="不可重复的数字划分（基础dp）"><a href="#不可重复的数字划分（基础dp）" class="headerlink" title="不可重复的数字划分（基础dp）"></a><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1201" target="_blank" rel="noopener">不可重复的数字划分</a>（基础dp）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">350</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  int n,m,cas=1;</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">   <span class="comment">// five();</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*(j+<span class="number">1</span>)&lt;=i*<span class="number">2</span>;j++)</span><br><span class="line">            dp[i][j]=(dp[i-j][j<span class="number">-1</span>]+dp[i-j][j])%MOD;</span><br><span class="line">            <span class="comment">//1.i-j的数，j-1个划分，每个划分数+1，再加上1的划分；2.i-j的数。j个划分，每个划分数+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">350</span>&amp;&amp;dp[n][i]!=<span class="number">0</span>;i++)</span><br><span class="line">            ans=(ans+dp[n][i])%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1259" target="_blank" rel="noopener">1259 整数划分 V2</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重复的划分，五边形定理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> q[<span class="number">405</span>],f[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">five</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">400</span>;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LL temp=(i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        q[i]=(<span class="number">3</span>*temp*temp-temp)/<span class="number">2</span>;</span><br><span class="line">        q[i+<span class="number">1</span>]=(<span class="number">3</span>*temp*temp+temp)/<span class="number">2</span>;</span><br><span class="line">       <span class="comment">// printf("%lld,",q[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,c=<span class="number">1</span>;j&lt;=<span class="number">400</span>;j+=<span class="number">2</span>,c*=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-q[j]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            f[i]=(f[i]+f[i-q[j]]*c+MOD)%MOD;</span><br><span class="line">            <span class="keyword">if</span>(i-q[j+<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            f[i]=(f[i]+f[i-q[j+<span class="number">1</span>]]*c+MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,cas=<span class="number">1</span>;</span><br><span class="line">    LL a;</span><br><span class="line">    five();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;不可重复的数字划分（基础dp）&quot;&gt;&lt;a href=&quot;#不可重复的数字划分（基础dp）&quot; class=&quot;headerlink&quot; title=&quot;不可重复的数字划分（基础
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="http://github.com/xxq1999/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>The Best Path(欧拉+并查集)</title>
    <link href="http://github.com/xxq1999/2018/08/15/The-Best-Path(%E6%AC%A7%E6%8B%89+%E5%B9%B6%E6%9F%A5%E9%9B%86)/"/>
    <id>http://github.com/xxq1999/2018/08/15/The-Best-Path(欧拉+并查集)/</id>
    <published>2018-08-15T14:53:42.531Z</published>
    <updated>2018-08-15T14:52:39.615Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="The-Best-Path"><a href="#The-Best-Path" class="headerlink" title="The Best Path"></a><a href="https://nanti.jisuanke.com/t/29370" target="_blank" rel="noopener">The Best Path</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个点，m条边，问你是否能够一次性不重复的走完其他所有的边，对于每一点有一个权值，ans=经过的每一次点的异或和（一个点可以重复多次），求怎么走使得这个ans最大。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一次性走完很显然是要欧拉路或者回路的，那么条件就是0个或者2个奇数度数的点，这个开头计数一下就好，另外还要判断是否连通，否则永远走不到某些路，所以用并查集查询father即可。</p><p>然后对于欧拉路来说，两个奇数度数的点一定有贡献，而对于偶数度数u的点来说，只要看u/2的奇偶性即可，是奇数就有贡献，偶数就没贡献，因此在开头把所有的点先异或一遍得一个ans，然后对于每一个点分析，如果没贡献就再异或一次。</p><p>如果是欧拉回路，那么就对每一个点作为起始点，我们可以发现起始点是没有贡献的，因此ans对于每一个起始点异或，取最大值即可。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> poor[N];</span><br><span class="line"><span class="keyword">int</span> deg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span>  <span class="comment">///找跟根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=id[x])</span><br><span class="line">    &#123;</span><br><span class="line">        id[x]=id[id[x]];</span><br><span class="line">        x=id[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">un</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pr=Find(p);</span><br><span class="line">    <span class="keyword">int</span> qr=Find(q);</span><br><span class="line">    <span class="keyword">if</span>(pr==qr) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz[pr]&lt;=sz[qr])</span><br><span class="line">    &#123;</span><br><span class="line">        sz[qr]+=sz[pr];id[pr]=qr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sz[pr]+=sz[qr];id[qr]=pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id[i]=i;sz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="keyword">sizeof</span>(deg));</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;poor[i]);</span><br><span class="line">            ans=ans^poor[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            deg[u]++;</span><br><span class="line">            deg[v]++;</span><br><span class="line">            un(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ji=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>) ji++;</span><br><span class="line">             <span class="keyword">if</span>(Find(i)!=Find(<span class="number">1</span>))</span><br><span class="line">             &#123;</span><br><span class="line">                 cnt++;<span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt!=<span class="number">0</span>||(ji!=<span class="number">0</span>&amp;&amp;ji!=<span class="number">2</span>)) &#123;<span class="built_in">printf</span>(<span class="string">"Impossible\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ji) <span class="comment">//欧拉路</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">if</span>(deg[i]%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(deg[i]/<span class="number">2</span>)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                    ans=ans^poor[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//回路</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp=ans^poor[i];</span><br><span class="line">                ans=max(ans,temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;The-Best-Path&quot;&gt;&lt;a href=&quot;#The-Best-Path&quot; class=&quot;headerlink&quot; title=&quot;The Best Path&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swordsman(多个优先队列)</title>
    <link href="http://github.com/xxq1999/2018/08/15/Swordsman(%E5%A4%9A%E4%B8%AA%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)/"/>
    <id>http://github.com/xxq1999/2018/08/15/Swordsman(多个优先队列)/</id>
    <published>2018-08-14T16:49:07.092Z</published>
    <updated>2018-08-14T16:49:07.093Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Swordsman"><a href="#Swordsman" class="headerlink" title=" Swordsman"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6396" target="_blank" rel="noopener"> Swordsman</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个n,代表有n个队伍，一个k，代表每个队伍中有k个战士，对应k个经验值，我方队伍中也有k个战士。</p><p>输入我方战士的k个战斗力，</p><p>接下来每一行输入敌方每个队伍k个战士的战斗力，打败k个战士后可以得到的经验值。</p><p>只有我方k个战士的战斗力均对应大于敌方某个队伍中k个战士的战斗值，才能得到相应的k个经验，提升战斗力，然后接着跟其他的队伍打。</p><p>问你我方战士每个人最后最多能为多少战斗力？</p><p>k&lt;=5,n&lt;=1e5，保证得到的战斗力在int范围内。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先由于读入数据大，先来个读入挂。</p><p>然后我们可以对每一种敌方战士（列），建立k个优先队列，以战斗值小为上。</p><p>然后不断循环，每次从第1个战士开始和第1个队列中的敌方战士打，如果强于他，就弹出这个战士，并记录这个战士对应的队伍中的战败情况，一旦他们的队伍全军覆没，我方每个战士就可以得到相应的经验值，然后和第i个队列中的战士打，一直到i=k为止，结束一轮循环。</p><p>然后一直循环直到某一次循环中不再有打赢他们的情况出现。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt;a[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MX = <span class="number">4e7</span>; <span class="comment">//1e7 占用内存 11000kb</span></span><br><span class="line">    <span class="keyword">char</span> buf[MX]; <span class="keyword">int</span> c, sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        sz = fread(buf, <span class="number">1</span>, MX, <span class="built_in">stdin</span>);<span class="comment">//一次性全部读入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; sz &amp;&amp; buf[c] != <span class="string">'-'</span> &amp;&amp; (buf[c] &lt; <span class="string">'0'</span> || buf[c] &gt; <span class="string">'9'</span>)) c++;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= sz) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若读完整个缓冲块则退出</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>; <span class="keyword">if</span>(buf[c] == <span class="string">'-'</span>) flag = <span class="number">1</span>, c++;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; c &lt; sz &amp;&amp; <span class="string">'0'</span> &lt;= buf[c] &amp;&amp; buf[c] &lt;= <span class="string">'9'</span>; c++) t = t * <span class="number">10</span> + buf[c] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) t = -t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,k,x,d[<span class="number">6</span>],b[<span class="number">100008</span>][<span class="number">6</span>],c[<span class="number">100008</span>]; <span class="comment">//d用来存当前战斗力，b是打败的奖励，c是记录某一行的打败情况</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;zz;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    IO::begin();</span><br><span class="line">    IO::read(t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        IO::read(n);</span><br><span class="line">        IO::read(k);</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) IO::read(d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(a[i].size()) a[i].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) IO::read(x),zz.first=x,zz.second=i,a[j].push(zz); <span class="comment">//先把所有的情况放到优先队列中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) IO::read(b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> f;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)    <span class="comment">//对于每一列</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!a[i].empty()) <span class="comment">//对于某一列的最小的元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    zz=a[i].top();</span><br><span class="line">                    <span class="keyword">if</span>(zz.first&lt;=d[i])  <span class="comment">//可以打败</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        a[i].pop();</span><br><span class="line">                        c[zz.second]++;  <span class="comment">//记录下这一行的打败情况</span></span><br><span class="line">                        <span class="keyword">if</span>(c[zz.second]==k) <span class="comment">//如果这一行都打败了 ，就吃掉啦</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) d[j]+=b[zz.second][j];</span><br><span class="line">                            ans++,f=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!f) <span class="keyword">break</span>; <span class="comment">//如果某次循环中没有能吃的，就break了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;d[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Swordsman&quot;&gt;&lt;a href=&quot;#Swordsman&quot; class=&quot;headerlink&quot; title=&quot; Swordsman&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Age of Moyu(bfs)</title>
    <link href="http://github.com/xxq1999/2018/08/15/Age-of-Moyu(bfs)/"/>
    <id>http://github.com/xxq1999/2018/08/15/Age-of-Moyu(bfs)/</id>
    <published>2018-08-14T16:18:41.037Z</published>
    <updated>2018-08-14T16:19:20.894Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Age-of-Moyu"><a href="#Age-of-Moyu" class="headerlink" title="Age of Moyu"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6386" target="_blank" rel="noopener">Age of Moyu</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个点，m条边，要求从1号走到n号，每条边上都有一种颜色，如果你在相同颜色的边上走，不会有额外的花费，但是如果你从一种颜色的边走到另一种颜色的边上，那么就要加1的花费，求的是最小花费。</p><p>1&lt;=n&lt;=1e5, 0&lt;=m&lt;=2e5</p><p>多组。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果直接bfs优先队列处理大顶堆的话，把跑过的点或者边标记了的话，是考虑不周到的。</p><p>如：</p><p>6 8 </p><p>1 2 2 </p><p>2 3 2 </p><p>3 4 2 </p><p>1 4 1 </p><p>1 5 1</p><p>4 5 2 </p><p>5 6 2 </p><p>2 6 1  答案应该是1，但是很多都容易输出2。</p><p>正确的做法是，用set[i]储存每次到达点i的前驱结点，如果到达这个点的花费比历史中到达这个点的最小花费要大，就continue,如果相等，前驱结点在set中，continue，如果不在set中，就放入set中，如果小于的话，就把set[i]清空，然后把历史最小花费mincost[i]更新了，并且把前驱结点放到set中（我发现放这条边的颜色也是可以的），然后对当前这个点连出去的每一条边继续判断，如果不是反向边，而且mincost[nxt]&gt;=（(当前颜色!=下个颜色)+mincost[i]），就把mincost[nxt]更新了，并且如果nxt点不是终点，就把nxt点push到优先队列中，优先队列存的是每一个点的到达状态，按照到达的花费从小到大放。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,color,nxt; <span class="comment">//下一个点，这条边的颜色，对于这个点相连的下一条边</span></span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;preid[maxn]; <span class="comment">//到达某点时花费相同的前一个结点</span></span><br><span class="line"><span class="keyword">int</span> idcost[maxn]; <span class="comment">//到达某点的最小花费</span></span><br><span class="line"><span class="keyword">int</span> head[maxn]; <span class="comment">//暂时记录上一条边的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val,id;<span class="comment">//当前总花费，当前到达点</span></span><br><span class="line">    <span class="keyword">int</span> color,father;<span class="comment">//前一条边上的颜色，前一个结点</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;p) <span class="keyword">const</span>&#123;<span class="keyword">return</span> val&gt;p.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    idcost[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.push((node)&#123;idcost[<span class="number">1</span>],<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> len,id,color,father,tot,i,cl,nxt;</span><br><span class="line">    node tmp;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        id=tmp.id,tot=tmp.val,father=tmp.father,color=tmp.color;</span><br><span class="line">        <span class="keyword">if</span>(tot&gt;idcost[id]) <span class="keyword">continue</span>; <span class="comment">//如果当前到达的总花费比到这一点的最小的花费要贵</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tot==idcost[id])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(preid[id].find(color)!=preid[id].end()) <span class="comment">//如果当前到达点已经记录了前一个点的颜色//我发现father前驱结点也是对的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            preid[id].insert(color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//更新最小花费</span></span><br><span class="line">        &#123;</span><br><span class="line">            preid[id].clear();</span><br><span class="line">            preid[id].insert(color);</span><br><span class="line">            idcost[id]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=head[id];~i;i=e[i].nxt) <span class="comment">//对于这个点连接的其他点</span></span><br><span class="line">        &#123;</span><br><span class="line">            cl=e[i].color;</span><br><span class="line">            nxt=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(nxt==father) <span class="keyword">continue</span>; <span class="comment">//反向边</span></span><br><span class="line">            <span class="keyword">if</span>(((cl!=color)+idcost[id])&lt;=idcost[nxt])</span><br><span class="line">            &#123;</span><br><span class="line">                idcost[nxt]=(cl!=color)+idcost[id];</span><br><span class="line">                <span class="keyword">if</span>(nxt!=n)</span><br><span class="line">                    q.push((node)&#123;idcost[nxt],nxt,cl,id&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(idcost[n]==INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> idcost[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(idcost,INF,<span class="keyword">sizeof</span>(idcost));</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            preid[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            e[total]=(edge)&#123;v,w,head[u]&#125;; <span class="comment">//一种新型存边方式hhh</span></span><br><span class="line">            head[u]=total++;</span><br><span class="line">            e[total]=(edge)&#123;u,w,head[v]&#125;;</span><br><span class="line">            head[v]=total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Age-of-Moyu&quot;&gt;&lt;a href=&quot;#Age-of-Moyu&quot; class=&quot;headerlink&quot; title=&quot;Age of Moyu&quot;&gt;&lt;/a&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="bfs" scheme="http://github.com/xxq1999/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>输入输出</title>
    <link href="http://github.com/xxq1999/2018/08/14/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://github.com/xxq1999/2018/08/14/输入输出/</id>
    <published>2018-08-14T14:26:04.158Z</published>
    <updated>2018-08-16T15:13:08.407Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar();x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>; ch = getchar());</span><br><span class="line"><span class="keyword">for</span> (; ch &gt;=<span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(a,a+n<span class="number">-1</span>,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MX = <span class="number">4e7</span>; <span class="comment">//1e7 占用内存 11000kb</span></span><br><span class="line">    <span class="keyword">char</span> buf[MX]; <span class="keyword">int</span> c, sz;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        sz = fread(buf, <span class="number">1</span>, MX, <span class="built_in">stdin</span>);<span class="comment">//一次性全部读入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (c &lt; sz &amp;&amp; buf[c] != <span class="string">'-'</span> &amp;&amp; (buf[c] &lt; <span class="string">'0'</span> || buf[c] &gt; <span class="string">'9'</span>)) c++;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= sz) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//若读完整个缓冲块则退出</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">0</span>; <span class="keyword">if</span>(buf[c] == <span class="string">'-'</span>) flag = <span class="number">1</span>, c++;</span><br><span class="line">        <span class="keyword">for</span>(t = <span class="number">0</span>; c &lt; sz &amp;&amp; <span class="string">'0'</span> &lt;= buf[c] &amp;&amp; buf[c] &lt;= <span class="string">'9'</span>; c++) t = t * <span class="number">10</span> + buf[c] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) t = -t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    IO::begin();</span><br><span class="line">    IO::read(t); <span class="comment">//读入t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Family View（AC自动机求匹配串位置）</title>
    <link href="http://github.com/xxq1999/2018/08/14/Family-View%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%B1%82%E5%8C%B9%E9%85%8D%E4%B8%B2%E4%BD%8D%E7%BD%AE%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/14/Family-View（AC自动机求匹配串位置）/</id>
    <published>2018-08-14T14:16:10.498Z</published>
    <updated>2018-08-14T14:16:10.499Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Family-View"><a href="#Family-View" class="headerlink" title="Family View"></a><a href="https://nanti.jisuanke.com/t/29367" target="_blank" rel="noopener">Family View</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>就是给你n个模式串，长度总和不超过1e6，给你一个匹配串，长度不超过1e6，然后要求是把匹配的字符换成”*”。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>AC自动机，在标记尾节点的地方（个数）顺带标记一下匹配串的最长长度，然后用vector pair存一下每次匹配时的位置和匹配的长度，最后对于每一pair进行处理。（对了 先把模式串用小写的保存下来，因为不区分大小写）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1000006</span>;    <span class="comment">//maxm是总结点数：约为字母数+++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[maxm],word[maxm];</span><br><span class="line"><span class="keyword">char</span> s2[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;tt[maxm];</span><br><span class="line"><span class="keyword">int</span> nxt[maxm][<span class="number">26</span>],f[maxm],size;    <span class="comment">//nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;Index; <span class="comment">//位置、长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;    <span class="comment">//初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号</span></span><br><span class="line">    <span class="built_in">memset</span>(nxt[size],<span class="number">0</span>,<span class="keyword">sizeof</span>(nxt[size]));</span><br><span class="line">    f[size]=tt[size].tail=<span class="number">0</span>;</span><br><span class="line">    tt[size].len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;    <span class="comment">//构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作</span></span><br><span class="line">    <span class="keyword">int</span> i,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x=nxt[p][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        p=x?x:x=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    tt[p].tail++;    <span class="comment">//此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成</span></span><br><span class="line">    tt[p].len=max(tt[p].len,(<span class="keyword">int</span>)<span class="built_in">strlen</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makenxt</span><span class="params">()</span></span>&#123;    <span class="comment">//利用bfs来构造失配指针</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">//先将0结点挂的字母加入队列，失配指针指向0结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=nxt[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(v)&#123;</span><br><span class="line">            f[v]=<span class="number">0</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=nxt[u][i];</span><br><span class="line">            <span class="keyword">if</span>(!v)nxt[u][i]=nxt[f[u]][i];    <span class="comment">//当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q.push(v);    <span class="comment">//u结点存在指向i的结点，则将所指向的结点下标加入队列</span></span><br><span class="line">                f[v]=nxt[f[u]][i];    <span class="comment">//失配指针指向上个结点失配指针指向结点所挂当前字母的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;    <span class="comment">//查询s串中模式串出现了多少种/次</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v&amp;&amp;!nxt[v][s[i]-<span class="string">'a'</span>])v=f[v];    <span class="comment">//先匹配直到没有失配</span></span><br><span class="line">        v=nxt[v][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp=v;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt[tmp].tail!=<span class="number">0</span>) <span class="comment">//这里！</span></span><br><span class="line">                Index.push_back(make_pair(i,tt[tmp].len));</span><br><span class="line">            tmp=f[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        Index.clear();</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        size=<span class="number">0</span>,newnode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,word);</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        makenxt();</span><br><span class="line">        getchar();</span><br><span class="line">        gets(S);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(S);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(S[i]&gt;=<span class="string">'A'</span>&amp;&amp;S[i]&lt;=<span class="string">'Z'</span>)</span><br><span class="line">                s2[i]=S[i]-<span class="string">'A'</span>+<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s2[i]=S[i];</span><br><span class="line">        query(s2);</span><br><span class="line">        len=Index.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Index[i].second;j++)</span><br><span class="line">                S[Index[i].first-j]=<span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(S);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC自动机注释模板"><a href="#AC自动机注释模板" class="headerlink" title="AC自动机注释模板"></a>AC自动机注释模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">500006</span>;    <span class="comment">//maxm是总结点数：约为字母数+++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000005</span>],word[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[maxm][<span class="number">26</span>],tail[maxm],f[maxm],size;    <span class="comment">//nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;    <span class="comment">//初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号</span></span><br><span class="line">    <span class="built_in">memset</span>(nxt[size],<span class="number">0</span>,<span class="keyword">sizeof</span>(nxt[size]));</span><br><span class="line">    f[size]=tail[size]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;    <span class="comment">//构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作</span></span><br><span class="line">    <span class="keyword">int</span> i,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> &amp;x=nxt[p][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        p=x?x:x=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    tail[p]++;    <span class="comment">//此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makenxt</span><span class="params">()</span></span>&#123;    <span class="comment">//利用bfs来构造失配指针</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;    <span class="comment">//先将0结点挂的字母加入队列，失配指针指向0结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=nxt[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(v)&#123;</span><br><span class="line">            f[v]=<span class="number">0</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=nxt[u][i];</span><br><span class="line">            <span class="keyword">if</span>(!v)nxt[u][i]=nxt[f[u]][i];    <span class="comment">//当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                q.push(v);    <span class="comment">//u结点存在指向i的结点，则将所指向的结点下标加入队列</span></span><br><span class="line">                f[v]=nxt[f[u]][i];    <span class="comment">//失配指针指向上个结点失配指针指向结点所挂当前字母的结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> s[])</span></span>&#123;    <span class="comment">//查询s串中模式串出现了多少种/次</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v&amp;&amp;!nxt[v][s[i]-<span class="string">'a'</span>])v=f[v];    <span class="comment">//先匹配直到没有失配</span></span><br><span class="line">        v=nxt[v][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp=v;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            ans+=tail[tmp];</span><br><span class="line">            tail[tmp]=<span class="number">0</span>;    <span class="comment">//这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次</span></span><br><span class="line">            tmp=f[tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        size=<span class="number">0</span>,newnode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,word);</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        makenxt();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体版</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; //查询匹配的数量 ，不知道有没有带重复的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">asd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fail; <span class="comment">// 失配指针</span></span><br><span class="line">    <span class="keyword">int</span> vis[<span class="number">26</span>]; <span class="comment">// 子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> end; <span class="comment">// 标记有几个单词以这个节点结尾 </span></span><br><span class="line">&#125; AC[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> rt,cnt,l,n;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">char</span> *ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> now=rt,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=ch[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!AC[now].vis[v]) AC[now].vis[v]=++cnt;</span><br><span class="line">        now=AC[now].vis[v];</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].end+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++) <span class="comment">// 第一层肯定没有之前的点与他匹配 </span></span><br><span class="line">        <span class="keyword">if</span>(AC[rt].vis[i]) </span><br><span class="line">            Q.push(AC[rt].vis[i]); <span class="comment">// 因为默认是 0 所以没有写指向根节点 </span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.front(); Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++) <span class="comment">// 枚举所有子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(AC[u].vis[i]) <span class="comment">// 存在这个子节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];</span><br><span class="line">                <span class="comment">// 子节点的fail指针指向当前节点的</span></span><br><span class="line">                <span class="comment">// fail指针所指向的节点的相同子节点 </span></span><br><span class="line">                Q.push(AC[u].vis[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//不存在这个子节点</span></span><br><span class="line">            AC[u].vis[i]=AC[AC[u].fail].vis[i];</span><br><span class="line">            <span class="comment">// 当前节点的这个子节点指向当</span></span><br><span class="line">            <span class="comment">// 前节点fail指针的这个子节点 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> now=rt,ans=<span class="number">0</span>,u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=ch[i]-<span class="string">'a'</span>;</span><br><span class="line">        now=AC[now].vis[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=now; j &amp;&amp; AC[j].end!=<span class="number">-1</span>; j=AC[j].fail)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=AC[j].end;</span><br><span class="line">            AC[j].end=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch+<span class="number">1</span>);</span><br><span class="line">        build(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    get_fail();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(ch));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Family-View&quot;&gt;&lt;a href=&quot;#Family-View&quot; class=&quot;headerlink&quot; title=&quot;Family View&quot;&gt;&lt;/a&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="AC自动机" scheme="http://github.com/xxq1999/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Sequence(整除分块+矩阵快速幂)</title>
    <link href="http://github.com/xxq1999/2018/08/14/Sequence(%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82)/"/>
    <id>http://github.com/xxq1999/2018/08/14/Sequence(整除分块+矩阵快速幂)/</id>
    <published>2018-08-14T13:59:21.921Z</published>
    <updated>2018-08-14T14:25:22.569Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Sequence"><a href="#Sequence" class="headerlink" title=" Sequence"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6395" target="_blank" rel="noopener"> Sequence</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义：<br>$$<br>F_1=A<br>$$</p><p>$$<br>F_2=B<br>$$</p><p>$$<br>F_n=D\cdot{}F_{n-1}+C\cdot{}F_{n-2}+\lfloor\frac{P}{n}\rfloor<br>$$</p><p>求Fn，Mod1e9+7。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一看到这个向下取整！</p><p>多么亲切啊！</p><p>整除分块啊！</p><p>……</p><p>一开始怎么都想不出来怎么把分块用进去，队友一波机智，先分块，然后矩阵快速幂，哇，秒啊，然后两个小时过去了……</p><p>由于莫比乌斯中我们经常会用到一个分块的概念：<br>$$<br>\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就想，因为矩阵快速幂要求的是尾项是个常数，而对于这个整除来说，在某些区间内它的值是一定的，因此我们就可以先把他们划分为好几块，然后对于每个区间进行矩阵快速幂即可，有些细节注意，比如说次数不足3次时，要手写一波判断，因为没有需要的Fn-1，Fn-2，比如n小于p的时候，需要在循环内直接结束，比如n大于p的时候，分块结束后再进行裸的矩阵快速幂。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">&#125;m,r;</span><br><span class="line"><span class="function">mat <span class="title">mult</span><span class="params">(mat x,mat y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat res=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">        res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mat <span class="title">PowerMod</span><span class="params">(mat x,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat ans=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        ans=mult(ans,x);</span><br><span class="line">        x=mult(x,x);</span><br><span class="line">        n=n/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll a,b,c,d,p,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,a);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,b);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        m.a[<span class="number">0</span>][<span class="number">2</span>]=m.a[<span class="number">1</span>][<span class="number">1</span>]=m.a[<span class="number">2</span>][<span class="number">1</span>]=m.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        m.a[<span class="number">0</span>][<span class="number">0</span>]=d;m.a[<span class="number">0</span>][<span class="number">1</span>]=c;</span><br><span class="line">        m.a[<span class="number">1</span>][<span class="number">0</span>]=m.a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        ll pre=b,ppre=a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>,R;L&lt;=p;L=R+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            R=p/(p/L); </span><br><span class="line">            <span class="keyword">int</span> zs=min(<span class="number">1l</span>l*R-L+<span class="number">1</span>,n-L+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(zs&lt;=<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=zs;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    ll tmp=pre;</span><br><span class="line">                    pre=((pre*d+ppre*c)%MOD+p/L)%MOD;</span><br><span class="line">                    ppre=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(n&gt;=L&amp;&amp;n&lt;=R) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m.a[<span class="number">0</span>][<span class="number">2</span>]=p/L;</span><br><span class="line">            r=PowerMod(m,zs);</span><br><span class="line">            ll p1=(r.a[<span class="number">0</span>][<span class="number">0</span>]*pre+r.a[<span class="number">0</span>][<span class="number">1</span>]*ppre+r.a[<span class="number">0</span>][<span class="number">2</span>])%MOD;</span><br><span class="line">            ll p2=(r.a[<span class="number">1</span>][<span class="number">0</span>]*pre+r.a[<span class="number">1</span>][<span class="number">1</span>]*ppre+r.a[<span class="number">1</span>][<span class="number">2</span>])%MOD;</span><br><span class="line">            pre=p1;ppre=p2;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;=L&amp;&amp;n&lt;=R) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;p)</span><br><span class="line">        &#123;</span><br><span class="line">            m.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">            r=PowerMod(m,n-max(<span class="number">2l</span>l,p));</span><br><span class="line">            ll p1=(r.a[<span class="number">0</span>][<span class="number">0</span>]*pre+r.a[<span class="number">0</span>][<span class="number">1</span>]*ppre+r.a[<span class="number">0</span>][<span class="number">2</span>])%MOD;</span><br><span class="line">            pre=p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Sequence&quot;&gt;&lt;a href=&quot;#Sequence&quot; class=&quot;headerlink&quot; title=&quot; Sequence&quot;&gt;&lt;/a&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="矩阵快速幂" scheme="http://github.com/xxq1999/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>错排（公式+三种生成）</title>
    <link href="http://github.com/xxq1999/2018/08/14/%E9%94%99%E6%8E%92%EF%BC%88%E5%85%AC%E5%BC%8F+%E4%B8%89%E7%A7%8D%E7%94%9F%E6%88%90%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/08/14/错排（公式+三种生成）/</id>
    <published>2018-08-13T17:11:41.968Z</published>
    <updated>2018-08-16T15:10:42.196Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ol><li>普通阶乘</li></ol><p>$$<br>D_n=|I|-\sum_{i=1}^n|S_i|+\sum_{i=1}^n\sum_{j&gt;i}|S_i∩S_j|-\sum_{i=1}^n\sum_{j&gt;i}\sum_{k&gt;i}|S_i∩S_j∩S_k|+…+(-1)^{n-1}|S_1∩S_2∩…∩S_n|<br>$$</p><p>$$<br>=n!(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+…+(-1)^{n}\frac{1}{n!})<br>$$</p><ol><li>递推关系</li></ol><p>$$<br>D_n=(n-1)(D_{n-1}+D_{n-2}),D_1=0,D_2=1<br>$$</p><p>$$<br>D_n=nD_{n-1}+(-1)^n<br>$$</p><h2 id="三种生成方式"><a href="#三种生成方式" class="headerlink" title="三种生成方式"></a>三种生成方式</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>时间复杂度为$O(D_n)$，但是由于递归函数的调用开销是很大的，系统要为每次函数调用分配存储空间，并将调用点压栈予以记录。而在函数调用结束后，还要释放空间，弹栈恢复断点。所以，考虑函数处理过程，整体看来，递归法的效率并不高。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Digui</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> cur,<span class="keyword">int</span> vis[])</span> <span class="comment">//递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        copy(a+<span class="number">1</span>,a+n,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        num1++;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]&amp;&amp;cur!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;a[cur]=i;</span><br><span class="line">            Digui(n,cur+<span class="number">1</span>,vis);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典序生成法"><a href="#字典序生成法" class="headerlink" title="字典序生成法"></a>字典序生成法</h3><p>用全排列的字典序生成法，同时对每次生成的全排列检验是否合法。</p><p>时间复杂度$O(2n*n!)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dictionary</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//字典生成</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        b[i]=i;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(b[i]==i)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        num2++;</span><br><span class="line">        copy(b+<span class="number">1</span>,b+n,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(b+<span class="number">1</span>,b+<span class="number">1</span>+n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进的字典序生成法"><a href="#改进的字典序生成法" class="headerlink" title="改进的字典序生成法"></a>改进的字典序生成法</h3><p>在对于某一个生成的全排列时判断，同时对接下来不正确的全排列都跳过。由于这种额外的判断方式，我们不能再使用next_permutation函数。</p><p>时间复杂度$O(D_n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AdLxOrder</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *dearr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> *occup = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> Flag = n + <span class="number">1</span>; <span class="comment">//记录不满足错排的元素位置，均满足则为n+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123; dearr[i] = <span class="number">0</span>;occup[i] = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n)                            <span class="comment">//安排第i个位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//安排第i个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (occup[j] == <span class="number">0</span> &amp;&amp; j != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    occup[j] = <span class="number">1</span>;            <span class="comment">//occup[j]记录j是否已经被安排</span></span><br><span class="line">                    dearr[i] = j;            <span class="comment">//安排dearr[i]</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n)                    <span class="comment">//安排最后一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)    <span class="comment">//安排第i个位置，无论是否满足</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (occup[j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    occup[j] = <span class="number">1</span>;            <span class="comment">//occup[j]记录j是否已经被安排</span></span><br><span class="line">                    dearr[i] = j;</span><br><span class="line">                    <span class="keyword">if</span> (j == i)</span><br><span class="line">                        Flag = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                <span class="comment">//i == n+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Flag == n + <span class="number">1</span>)                <span class="comment">//满足，输出，并找字典序下一个</span></span><br><span class="line">            &#123;</span><br><span class="line">                num_a++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n; k++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d  "</span>,dearr[k]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt; <span class="number">1</span>; k--)    <span class="comment">//从右往左找下降</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dearr[k - <span class="number">1</span>] &lt; dearr[k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        pos = k - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = n; m &gt; pos; m--)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dearr[m] &gt; dearr[pos])    <span class="comment">//找到后缀中较大的最小元素</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (dearr[m] == pos)</span><br><span class="line">                                    Flag = pos;     <span class="comment">//记录不满足的位置</span></span><br><span class="line">                                <span class="keyword">int</span> tmp = dearr[m];   <span class="comment">//交换</span></span><br><span class="line">                                dearr[m] = dearr[pos];</span><br><span class="line">                                dearr[pos] = tmp;</span><br><span class="line">                                <span class="comment">//记录不满足的位置（只记录最左侧）</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> k1 = pos+<span class="number">1</span>, k2 = n; k1 &lt; k2; k1++, k2--)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (dearr[k1] == k2 &amp;&amp; Flag &gt; k2)</span><br><span class="line">                                        Flag = k2;  <span class="comment">//记录不满足的位置</span></span><br><span class="line">                                    <span class="keyword">if</span> (dearr[k2] == k1 &amp;&amp; Flag &gt; k1)</span><br><span class="line">                                        Flag = k1;  <span class="comment">//记录不满足的位置</span></span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">int</span> tmp = dearr[k2]; <span class="comment">//陆续交换</span></span><br><span class="line">                                    dearr[k2] = dearr[k1];</span><br><span class="line">                                    dearr[k1] = tmp;</span><br><span class="line">                                &#125;</span><br><span class="line">                                i = n; <span class="comment">//循环末尾有i++，此处特取n</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">//找关键位置的下一个值</span></span><br><span class="line">            &#123;                                <span class="comment">//关键位置：下降位置和不满足位置的最左者</span></span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt; <span class="number">1</span>; k--)    <span class="comment">//从右往左找下降</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dearr[k - <span class="number">1</span>] &lt; dearr[k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        pos = k - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (pos &gt; Flag)        <span class="comment">//pos取下降位置和不满足位置的最左者</span></span><br><span class="line">                            pos = Flag;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt;= n; m++) occup[dearr[m]] = <span class="number">0</span>; <span class="comment">//全部重置</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = dearr[pos] + <span class="number">1</span>; m &lt;= n; m++) <span class="comment">//从dearr[pos]+1开始找</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (occup[m] == <span class="number">0</span> &amp;&amp; m != pos) <span class="comment">//给pos找到下一个值</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                dearr[pos] = m;</span><br><span class="line">                                occup[m] = <span class="number">1</span>;</span><br><span class="line">                                i = pos;</span><br><span class="line">                                Flag = n + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (Flag == n + <span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            k = pos + <span class="number">1</span>;    <span class="comment">//重新向前找下降，循环末尾有k--，此处特+1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []dearr;</span><br><span class="line">    <span class="keyword">delete</span> []occup;</span><br><span class="line">    <span class="keyword">return</span> num_a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公式&quot; class=&quot;headerlink&quot; title=&quot;公式&quot;&gt;&lt;/a&gt;公式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;普通阶乘&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排列组合" scheme="http://github.com/xxq1999/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
      <category term="学习" scheme="http://github.com/xxq1999/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GuGuFishtion(欧拉函数公式+莫比乌斯)</title>
    <link href="http://github.com/xxq1999/2018/08/14/GuGuFishtion(%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%AC%E5%BC%8F+%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF)/"/>
    <id>http://github.com/xxq1999/2018/08/14/GuGuFishtion(欧拉函数公式+莫比乌斯)/</id>
    <published>2018-08-13T17:04:22.643Z</published>
    <updated>2018-08-13T17:04:22.652Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="GuGuFishtion"><a href="#GuGuFishtion" class="headerlink" title="GuGuFishtion"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6390" target="_blank" rel="noopener">GuGuFishtion</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>求：<br>$$<br>Ans=\sum_{i=1}^{n}\sum_{j=1}^m\frac{φ(ij)}{φ(i)φ(j)}\%p<br>$$<br>其中，n,m&lt;=1e6, max(n,m)&lt;=p&lt;=1e9，且p为素数。</p><p>##思路</p><p>由欧拉函数公式：<br>$$<br>φ(x)=x(1-\frac{1}{p_1})(1-\frac{1}{p_2})(1-\frac{1}{p_3})…(1-\frac{1}{p_n})，其中p_i为x的质因子<br>$$<br>将公式带入$\frac{φ(ij)}{φ(i)φ(j)}$中：<br>$$<br>原式=\frac{ij(1-\frac{1}{c_1})…(1-\frac{1}{c_t})}{i(1-\frac{1}{a_1})…(1-\frac{1}{a_n})j(1-\frac{1}{b_1})…(1-\frac{1}{b_m})}<br>$$</p><p>$$<br>=\frac{1}{(1-\frac{1}{a_1})(1-\frac{1}{a_2})…(1-\frac{1}{b_1})(1-\frac{1}{b_2})…}<br>$$</p><p>上下同乘以gcd(i,j)，则可以得到：</p><p>(这里虽然讲不清楚但是大致是一个容斥)<br>$$<br>原式=\frac{gcd(i,j)}{gcd(i,j)-gcd(i,j)/质因数的任意组合+gcd(i,j)/所有质因子的组合}<br>$$</p><p>$$<br>=\frac{gcd(i,j)}{φ(gcd(i,j))}<br>$$</p><p>因此<br>$$<br>Ans=\sum_{i=1}^{n}\sum_{j=1}^m\frac{gcd(i,j)}{φ(gcd(i,j))}\%p<br>$$<br>令k=gcd(i,j)，并枚举k，有：<br>$$<br>Ans=\sum_{i=1}^{n}\sum_{j=1}^m\sum_{k=1}^{min(n,m)}\frac{k}{φ(k)}[gcd(i,j)==k]\%p<br>$$</p><p>$$<br>=\sum_{k=1}^{min(n,m)}\frac{k}{φ(k)}\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)==k]\%p<br>$$</p><p>$$<br>=\sum_{k=1}^{min(n,m)}\frac{k}{φ(k)}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[gcd(i,j)==1]\%p<br>$$</p><p>$$<br>=\sum_{k=1}^{min(n,m)}\frac{k}{φ(k)}\sum_{i=1}^{\lfloor\frac{n}{dk}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dk}\rfloor}<br>\sum_{d=1}^{min(n,m)}μ(d)\%p<br>$$</p><p>$$<br>=\sum_{k=1}^{min(n,m)}\frac{k}{φ(k)}\sum_{d=1}^{min(n,m)}μ(d){\lfloor\frac{n}{dk}\rfloor}{\lfloor\frac{m}{dk}\rfloor}\%p<br>$$</p><p>就可以做啦！</p><p>枚举k=1~min(n,m)，先分析出要预先求的东西：</p><ol><li>μ(d)</li><li>φ(k)</li></ol><p>预处理：由于n/dk向下取整时，当dk&gt;n，值为0，因此我们只要先枚举dk=1到min(n,m)即可。</p><p>然后对于for(k)，dk为d的倍数增长，此时，d=dk/k,将μ(dk/k)、n/dk、m/dk相乘，取模得到F(k)+=。</p><p>计算：然后就可以一个大循环，枚举k从1~min(n,m)，求得k*逆元(φ(k))，再*先前求得的F(k)，并取模即可。</p><p>注意：由于时间限制， 取模一定要尽量少取。特别是在预处理阶段中，求F(k)时，由于F(k)是重复累加的，因此若是<strong>每一次累加都取模，会造成不必要的时间浪费</strong>，因此我们可以把F(k)开long long，然后在全部预处理完毕之后再一次性for取模。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll MOD;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> phi[maxn],mu[maxn],prim[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">ll quzheng[maxn],f[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得（扩展gcd）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">ll d=ex_gcd(b,a%b,y,x);</span><br><span class="line">y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mod_inverse</span><span class="params">(ll a,ll n)</span><span class="comment">//乘法逆元，a与n必须互素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll x,y;</span><br><span class="line">ll d = ex_gcd(a,n,x,y);</span><br><span class="line"><span class="keyword">return</span> (x%n+n)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对于μ函数的线筛 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        vis[prim[j]*i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>) &#123;phi[i*prim[j]]=phi[i]*prim[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;mu[i*prim[j]]=-mu[i];phi[i*prim[j]] = phi[i] * phi[prim[j]];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MIN;i++) quzheng[i]=<span class="number">1l</span>l*(n/i)*(m/i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MIN;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=MIN;j+=i)</span><br><span class="line">            f[i]+=<span class="number">1l</span>l*mu[j/i]*quzheng[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MIN;i++) <span class="comment">//就是这个TLE</span></span><br><span class="line">        f[i]%=MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,t;</span><br><span class="line">    get_mu(<span class="number">1000000</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;m,&amp;n,&amp;MOD);</span><br><span class="line">        cal(n,m);</span><br><span class="line">        <span class="keyword">int</span> MIN=min(n,m);</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MIN;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=(ans+(<span class="number">1l</span>l*i*mod_inverse(phi[i],MOD))%MOD*f[i]+MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;GuGuFishtion&quot;&gt;&lt;a href=&quot;#GuGuFishtion&quot; class=&quot;headerlink&quot; title=&quot;GuGuFishtion&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="莫比乌斯反演" scheme="http://github.com/xxq1999/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>Prefix Free Code（字符串）</title>
    <link href="http://github.com/xxq1999/2018/08/12/Prefix-Free-Code/"/>
    <id>http://github.com/xxq1999/2018/08/12/Prefix-Free-Code/</id>
    <published>2018-08-12T13:54:26.966Z</published>
    <updated>2018-08-16T15:16:44.690Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Prefix-Free-Code"><a href="#Prefix-Free-Code" class="headerlink" title="Prefix Free Code"></a><a href="https://nanti.jisuanke.com/t/29556" target="_blank" rel="noopener">Prefix Free Code</a></h2><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个字符串，这些字符串都不是互相的前缀，再给你一个模式串。模式串由k个其中的字符串任意排列组成。求这个模式串是从中选k个按照字典序排列组成的第几个串？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用全排列的方法，1~n表示前n个字符串，用字符串哈希的方法把他们压缩成数字放在map里映射字符串的序号。</p><p>然后遍历模式串。对于每找到一个字符串，按照（比此序号小的字符串-前面已经用掉的字符串的个数）*剩下的位子的全排列数量乘以原先算出来的种数，然后把这个新找到的字符串add到树状数组中，用来标记已经用掉的字符串的个数。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll fac[<span class="number">1000010</span>];</span><br><span class="line">ll inv[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">string</span> ss;</span><br><span class="line"><span class="keyword">const</span> ll base=<span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1234567891011l</span>l;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=s[id].size();</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        ans=(ans*base+(s[id][i]))%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=d[x];</span><br><span class="line">        x-=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        d[x]+=v;</span><br><span class="line">        x+=lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">PowerMod</span><span class="params">(ll a,ll b,ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    ll k;</span><br><span class="line">    k=a;</span><br><span class="line">    k=k%c;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(ans*k)%c;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        k=(k*k)%c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    inv[MAXN]=PowerMod(fac[MAXN],MOD<span class="number">-2</span>,MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=MAXN<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">    sort(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll tot=solve(i);</span><br><span class="line">        mp[tot]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ss;</span><br><span class="line">    <span class="keyword">int</span> len=ss.size();</span><br><span class="line">    ll temp=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=(temp*base+(ss[i]))%mod;</span><br><span class="line">        <span class="keyword">if</span>(mp[temp]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> id=mp[temp];</span><br><span class="line">            ll sum=<span class="number">1</span>;</span><br><span class="line">            sum=id<span class="number">-1</span>-query(id);</span><br><span class="line">            sum=((fac[n-cnt]*inv[n-k])%MOD*sum)%MOD;</span><br><span class="line">            ans=(ans+sum)%MOD;</span><br><span class="line">            temp=<span class="number">0</span>;</span><br><span class="line">            add(id,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans+<span class="number">1</span>)%MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Prefix-Free-Code&quot;&gt;&lt;a href=&quot;#Prefix-Free-Code&quot; class=&quot;headerlink&quot; title=&quot;Prefix Fre
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="全排列构造" scheme="http://github.com/xxq1999/tags/%E5%85%A8%E6%8E%92%E5%88%97%E6%9E%84%E9%80%A0/"/>
    
      <category term="字符串哈希" scheme="http://github.com/xxq1999/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
</feed>

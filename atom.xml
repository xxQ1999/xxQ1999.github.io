<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeartBeat</title>
  
  <subtitle>飞光飞光，劝你一杯酒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/xxq1999/"/>
  <updated>2018-07-27T16:55:51.372Z</updated>
  <id>http://github.com/xxq1999/</id>
  
  <author>
    <name>XXQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组合数学</title>
    <link href="http://github.com/xxq1999/2018/07/27/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://github.com/xxq1999/2018/07/27/组合数学/</id>
    <published>2018-07-26T16:06:26.940Z</published>
    <updated>2018-07-27T16:55:51.372Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Cayley公式："><a href="#Cayley公式：" class="headerlink" title="Cayley公式："></a>Cayley公式：</h2><blockquote><p>一个完全图K_n有$n^{n-2}$棵生成树，即n个有标号1~n的顶点的树的个数为：$n^{n-2}$</p></blockquote><p>证明：你画个图</p><blockquote><p>给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n&gt;2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。</p></blockquote><p>简化为：n个数字可重复的排列到n-2个位置上去。</p><h2 id="不全相异的排列"><a href="#不全相异的排列" class="headerlink" title="不全相异的排列"></a>不全相异的排列</h2><p>n个元素组成的多重集，$a_i$重复$n_i$次，$n=∑_{i=1}^kn_i$,从n个元素中选取r个排列，求不同的排列数。</p><p>若r=n ,为：$\frac{n!}{n_1!n_2!…n_k!}$</p><h2 id="重复排列和重复组合"><a href="#重复排列和重复组合" class="headerlink" title="重复排列和重复组合"></a>重复排列和重复组合</h2><p>排列：在n个不同物体中可重复选取r个排列：$n^r$</p><p>组合：…… 组合：$C_{n+r-1}^r$</p><p>证明组合：对于1~n的x集合中选取r个元素，然后对应的构造r个y集合中的元素，对应关系为：$y_i=x_i+i-1$，</p><p>故……</p><h2 id="圆周排列"><a href="#圆周排列" class="headerlink" title="圆周排列"></a>圆周排列</h2><blockquote><p>a、b、c、d，普通排列：24，圆周排列：6 = 24/4 也就说；普通数量/个数 = （n-1）！</p></blockquote><p>##生成全排列</p><h3 id="序数法："><a href="#序数法：" class="headerlink" title="序数法："></a>序数法：</h3><p>任何$m=a_{n-1}(n-1)!+a_{n-2}(n-2)!+a_{n-3}(n-3)!+……+a_2<em>2!+a_1</em>1!$              ………………………①</p><p>其中a1 = m%2， a2=(m/2)%3 , a3=(m/2/3)%4 ……直到m/……=0；</p><p>那么！a集合（$a_{n-1}~a_1$）共有n！种排列对不对！那么怎样把1,2，……n的一个排列和①联系起来呢？</p><blockquote><p>某一个n阶排列的序号是m，那么将m转换为阶乘进制数后，阶乘进制数的第i位就是在i右面比i小的元素个数。例如4阶排列中（从0开始计数的）第19个排列的序号是19，将19转换成阶乘进制数是3010，那么，第一位是0，表明1的右面没有比1小的元素，而第二位是1，则2的右面有一个元素小于2，第三位是0，即3的右面没有比它小的元素，第四位是3，4的右面有3个元素小于它。显然，这个排列是4 2 1 3。</p></blockquote><h3 id="字典序法："><a href="#字典序法：" class="headerlink" title="字典序法："></a>字典序法：</h3><blockquote><p>很简单就是1234 、 1243、 1324、 1342、……这样的全排列生成顺序</p></blockquote><p>方法是：eg：上一个排列数为：3421 (p.s.以下的i j k都是下标) 1~n</p><ol><li>求$ i = max ( j|a_j-1&lt;a_j ) = 2$</li><li>求$ j = max(k|a_i-1&lt;a_k)= 2$</li><li>交换$a_i-1$ 和 $a_j$ ，得：4321</li><li>将$a_ia_{i+1}a_{i+2}……a_n$逆序：得4123。</li></ol><p><a href="http://poj.org/problem?id=1833" target="_blank" rel="noopener">Poj 1833</a> 可以使用stl中的next_permutation(op1,op2)自动生成字典序的下一个全排列。</p><p>op1是放排列的数组首地址a，op2是排列的长度a+n。</p><p>到最后一个排列时返回为false。</p><p>但是这一题卡输出，用stl的<iterator>中的</iterator></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(a,a+n<span class="number">-1</span>,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>参考用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1300</span>];</span><br><span class="line">    <span class="keyword">int</span> m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            next_permutation(a,a+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        copy(a,a+n<span class="number">-1</span>,ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">" "</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="邻位互换法"><a href="#邻位互换法" class="headerlink" title="邻位互换法"></a>邻位互换法</h3><p>计蒜客构造题 <a href="https://nanti.jisuanke.com/t/28877" target="_blank" rel="noopener">[bellring]</a></p><blockquote><p>仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？</p></blockquote><p>n=1;        1</p><p>n=2;        12 , 21</p><p>n=3;        123, 132, 312, 321, 231, 213</p><p>……</p><p>用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">本算法的思想也是希望以（12…n）作为n个元素1，2，…，n的第一个排列，</span></span><br><span class="line"><span class="comment">然后按照某种方法，由一个排列（p）＝（p1p2…pn）直接生成下一个排列，</span></span><br><span class="line"><span class="comment">直到全部排列生成完毕为止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以n＝4为例，开始在排列1234的各数上方加一个左箭头“←”，</span></span><br><span class="line"><span class="comment">当一个数上方箭头所指的一侧，相邻的数比该数小时，便称该数处于活动状态。</span></span><br><span class="line"><span class="comment">从排列（p）＝（p1p2…pn）生成下一个排列的算法如下：</span></span><br><span class="line"><span class="comment">（1）若排列（p）＝（p1p2…pn）中无一数处于活动状态，则停止，否则转（2）；</span></span><br><span class="line"><span class="comment">（2）求所有处于活动状态的数中的最大者，设为k，</span></span><br><span class="line"><span class="comment">k和它的箭头所指的一侧的相邻数互换位置，转（3）；</span></span><br><span class="line"><span class="comment">（3）令比k大的所有数的箭头改变方向，转（1）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> DIR&#123;LEFT=<span class="number">-1</span>,RIGHT=<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：判断下标i所指p中元素是否处于活动状态</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dirin,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *iin,待判定元素的下标</span></span><br><span class="line"><span class="comment"> *Nin,待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：true 表示待判定元素为活动状态，</span></span><br><span class="line"><span class="comment"> *false 表示待判定元素处于非活动状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsActive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,<span class="keyword">const</span> DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> i,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i+dir[i] &lt; <span class="number">0</span> || i+dir[i] &gt;= N)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(p[i+dir[i]] &lt; p[i])<span class="comment">//箭头所指一侧相邻的数比该数小</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：找到p中处于活动状态的数中的最大者</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dir in,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *Nin,待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：上述最大者的下标，-1表示调用参数有误,N表示没有活动者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxActive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,<span class="keyword">const</span> DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">if</span>(IsActive(p,dir,i,N) &amp;&amp; (p[i] &gt; p[k]))</span><br><span class="line">k = i;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：交换下标i所指元素与其箭头方向所指元素,原位交换</span></span><br><span class="line"><span class="comment"> *输入参数：pinout,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dir inout,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *iin,待交换元素的下标</span></span><br><span class="line"><span class="comment"> *返回值：true 表示交换成功</span></span><br><span class="line"><span class="comment"> *false 表示交换失败，失败原因为调用参数有误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> *p, DIR *dir, <span class="keyword">int</span> *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> || dir == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换相邻的元素；</span></span><br><span class="line"><span class="keyword">char</span> temp = p[*i];</span><br><span class="line">p[*i] = p[*i+dir[*i]];</span><br><span class="line">p[*i+dir[*i]] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素相关的箭头也得交换</span></span><br><span class="line">DIR T = dir[*i];</span><br><span class="line">dir[*i] = dir[*i+T];</span><br><span class="line">dir[*i+T] = T;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*i = *i + T;<span class="comment">//使*i依旧是未交换前*i所指元素的下标</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数功能：上述算法思路第三步，修改所以比k大的元素的箭头方向，原位修改</span></span><br><span class="line"><span class="comment"> *输入参数：pin,指向n个字符的一个当前排列</span></span><br><span class="line"><span class="comment"> *dirinout,标记p中每个元素的箭头方向</span></span><br><span class="line"><span class="comment"> *kin,p中处于活动状态的最大者的下标，由MaxActive函数求出</span></span><br><span class="line"><span class="comment"> *Nin,缓冲区p的长度,也是待排列字符的个数</span></span><br><span class="line"><span class="comment"> *返回值：true 表示函数执行成功</span></span><br><span class="line"><span class="comment"> *false 表示函数执行失败，失败原因为调用参数有误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModifyDir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p,DIR *dir,<span class="keyword">const</span> <span class="keyword">int</span> k,<span class="keyword">const</span> <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span> || dir == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;p[k])</span><br><span class="line">dir[i] = (dir[i] == LEFT ? RIGHT : LEFT);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N =<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span> [N+<span class="number">1</span>];</span><br><span class="line">DIR *dir = <span class="keyword">new</span> DIR [N];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="string">'1'</span>+i;</span><br><span class="line">dir[i] = LEFT;</span><br><span class="line">&#125;</span><br><span class="line">p[N]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(p)<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p[<span class="built_in">strlen</span>(p)<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">k = MaxActive(p,dir,N);</span><br><span class="line"><span class="keyword">if</span>(k == N)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">Swap(p,dir,&amp;k);</span><br><span class="line">ModifyDir(p,dir,k,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(p)<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]-<span class="string">'0'</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p[<span class="built_in">strlen</span>(p)<span class="number">-1</span>]-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"><span class="keyword">delete</span> []dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>$$<br>a_{n+1}=\frac{4n+2}{n+2}a_n<br>$$</p><p>1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, … …</p><h2 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h2><blockquote><p>定义：对于序列$a_0,a_1,a_2 … $构造一个函数：</p></blockquote><p>$$<br>G(x)=a_0+a_1x+a_2x^2+…<br>$$</p><blockquote><p>则，函数G(x)就是序列$a_0,a_1,a_2…$的母函数。</p></blockquote><p>比如说一个普通型母函数的应用：</p><p>有质量为1,2,3的砝码各一枚：</p><p>（1）可以称出多少种不同的质量？</p><p>解：1个1g砝码可以用1+x表示，1表示不用，x表示用1g砝码</p><p>​    1个2g砝码可用$1+x^2$表示……</p><p>​    1个3g砝码$1+x^3$……</p><p>​    则其母函数$G(x)=(1+x)(1+x^2)(1+x^3)=1+x+x^2+2x^3+x^4+x^5+x^6$</p><p>​    x上的指数表示质量，x前的系数表示搭配种类。</p><p>​    故可以称出6种。</p><p>（2）若砝码有无穷个？</p><p>解：以2g砝码为例，那么2g砝码可以组成：$(1+x^2+x^4+x^6……)$</p><p>因此：$G(x)=(1+x+x^2+x^3+……)(1+x^2+x^4+x^6+……)(1+x^3+x^6+x^9+……)$</p><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个比较快速</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">K对应具体问题中物品的种类数。</span></span><br><span class="line"><span class="comment">v[i]表示该乘积表达式第i个因子的权重，对应于具体问题的每个物品的价值或者权重。</span></span><br><span class="line"><span class="comment">n1[i]表示该乘积表达式第i个因子的起始系数，对应于具体问题中的每个物品的最少个数，即最少要取多少个。</span></span><br><span class="line"><span class="comment">n2[i]表示该乘积表达式第i个因子的终止系数，对应于具体问题中的每个物品的最多个数，即最多要取多少个。</span></span><br><span class="line"><span class="comment">对于表达式(1+x+x^2)(x^8+x^10)(x^5+x^10+x^15+x^20)，v[3]=&#123;1,2,5&#125;，n1[3]=&#123;0,4,1&#125;，n2[3]=&#123;2,5,4&#125;。</span></span><br><span class="line"><span class="comment">解题的关键是要确定v、n1、n2数组的值。</span></span><br><span class="line"><span class="comment">通常n1都为0，但有时候不是这样。</span></span><br><span class="line"><span class="comment">n2有时候是无限大。</span></span><br><span class="line"><span class="comment">P是可能的最大指数。</span></span><br><span class="line"><span class="comment">如果n2为无穷大，那么第二层循环条件j&lt;=n2[i]可以去掉。</span></span><br><span class="line"><span class="comment">a[i],i为指数，内容为系数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化a，因为有last，所以这里无需初始化其他位</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> last2=min(last+n[i]*v[i],P);<span class="comment">//计算下一次的last</span></span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//只清空b[0..last2]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n1[i];j&lt;=n2[i]&amp;&amp;j*v[i]&lt;=last2;j++)<span class="comment">//这里是last2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=last&amp;&amp;k+j*v[i]&lt;=last2;k++)<span class="comment">//这里一个是last，一个是last2</span></span><br><span class="line">b[k+j*v[i]]+=a[k];</span><br><span class="line"><span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//b赋值给a，只赋值0..last2</span></span><br><span class="line">last=last2;<span class="comment">//更新last</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2082" target="_blank" rel="noopener">HDU2082</a></p><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100</span>],n[<span class="number">100</span>],a[<span class="number">100</span>],b[<span class="number">100</span>],last,last2,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n[i]);</span><br><span class="line">            v[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">1</span>;last=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化a，因为有last，所以这里无需初始化其他位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> last2=min(last+n[i]*v[i],<span class="number">50</span>);<span class="comment">//计算下一次的last</span></span><br><span class="line">            <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//只清空b[0..last2]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=n[i]&amp;&amp;j*v[i]&lt;=last2; j++) <span class="comment">//这里是last2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;=last&amp;&amp;k+j*v[i]&lt;=last2; k++) <span class="comment">//这里一个是last，一个是last2</span></span><br><span class="line">                    b[k+j*v[i]]+=a[k];</span><br><span class="line">            <span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(last2+<span class="number">1</span>));<span class="comment">//b赋值给a，只赋值0..last2</span></span><br><span class="line">            last=last2;<span class="comment">//更新last</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">50</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i])   ans+=a[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>//这里来一个大整数分解的模板吧（质因子）</p><h2 id="Ferrrs图像"><a href="#Ferrrs图像" class="headerlink" title="Ferrrs图像"></a>Ferrrs图像</h2><blockquote><p>一个自上而下的n层各自组成的图像，$m_i$为第i层的格子数。当$m_i≥m{i+1}$，即上层的格子数不少于下层的格子数时，称之为Ferrers图像。</p></blockquote><p>绕$y=-x$旋转得到的图像仍然是Ferrers图像，这样两个称为一对共轭Ferrers图像。</p><p>整数的拆分也可以用这个图像来表示。</p><p>可根据图像证明定理：整数n拆分成k个数的和的拆分数，与数n拆分成最大数为k的拆分数相等。</p><p>eg：24=5+5+5+4+3+2 的图像 共轭图像的话，24=6+6+5+4+3，</p><p>可以看出，24拆分成6个数的最大数=24拆分成最大数为6的拆分数</p><p>……</p><h2 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h2><p>在不全相异的排列那一p里面，r=n可以容易求出，但是当r一般情况的时候就复杂了。</p><p>幂级数……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Cayley公式：&quot;&gt;&lt;a href=&quot;#Cayley公式：&quot; class=&quot;headerlink&quot; title=&quot;Cayley公式：&quot;&gt;&lt;/a&gt;Cayley公式：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计蒜客暑期</title>
    <link href="http://github.com/xxq1999/2018/07/08/%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%9A%91%E6%9C%9F/"/>
    <id>http://github.com/xxq1999/2018/07/08/计蒜客暑期/</id>
    <published>2018-07-08T07:20:48.063Z</published>
    <updated>2018-07-27T17:00:40.897Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>7.7</p><p>A. 思维题，重点在于当剩余的n&lt;k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那n=1，当然ok。</p><p>B. dijkstra最短路一下</p><p>D. Dp，结束后想了一下，dp[i]表示第i层停下来的所有怨气，dp[i]=min(dp[i],dp[j] + val(j-&gt;i)) ,（j&lt;i）i之前电梯停在j层，然后从j直接到i 的话，加上这一部分的怨气就好了val，而valij的怨气就是i的前缀和加上若每一层都停的怨气，再减去了j层停下来的人消失的这部分怨气。</p><p><img src="\source\mdpicture\20180712A.jpg" alt="20180712A"></p><p>F. 飞行航道 水</p><p>J. 找单词，八方找，正反找。看了题解 好像是先判断了一下回文减少了一下长度？</p><p>7.10</p><p>B.  最少按下的按钮次数</p><p>用bfs，时间小于0，变成0，大于3600，变为3600。vis[i]记录时间为i的最少步骤数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n,sum;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>],vis[<span class="number">3610</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">    node temp,tp;</span><br><span class="line">    temp.val=<span class="number">0</span>;</span><br><span class="line">    temp.step=<span class="number">0</span>;</span><br><span class="line">    q.push(temp);</span><br><span class="line">    vis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=temp.val+a[i];</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>) cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur&gt;<span class="number">3600</span>) cur=<span class="number">3600</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[cur]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[cur]=temp.step+<span class="number">1</span>;</span><br><span class="line">                tp.step=temp.step+<span class="number">1</span>;</span><br><span class="line">                tp.val=cur;</span><br><span class="line">                q.push(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=sum;i&lt;=<span class="number">3600</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,vis[i],i-sum);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>G. 水</p><p>I. 计算组成n的最小的两个斐波那契数a b，其中按b小来排，且a&lt;b</p><p><img src="\source\mdpicture\180710I.jpg" alt="I"></p><p>由上可知，先计算出最大的两个相邻数相加小于n的地方，设为x，y（x&lt;y），然后xa+yb=n,从b=1开始求满足条件的a，且a&lt;b。</p><p>J. 把迷宫设置大，然后从中间模拟</p><p>7.12</p><p>B. 最小路径覆盖，网络流，最大流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">3000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,cap,nxt;</span><br><span class="line">&#125;e[M];;<span class="comment">//邻接表要开边数的两倍</span></span><br><span class="line"><span class="keyword">int</span> src,des,dis[N],head[N],ecnt;  <span class="comment">//memset dis,head-1 ecnt=0,src=0,des=2*n+1;</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[ecnt].v=v;</span><br><span class="line">    e[ecnt].cap=w;</span><br><span class="line">    e[ecnt].nxt=head[u];</span><br><span class="line">    head[u]=ecnt++;</span><br><span class="line">    e[ecnt].v=u;</span><br><span class="line">    e[ecnt].cap=<span class="number">0</span>;</span><br><span class="line">    e[ecnt].nxt=head[v];</span><br><span class="line">    head[v]=ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(src);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[src]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap&gt;<span class="number">0</span>&amp;&amp;dis[v]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[des]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==des) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(e[i].cap&gt;<span class="number">0</span>&amp;&amp;dis[v]==dis[u]+<span class="number">1</span>&amp;&amp;(t=Dfs(v,min(a,e[i].cap))))</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].cap-=t;</span><br><span class="line">            e[i^<span class="number">1</span>].cap+=t;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t=Dfs(src,inf)) ans+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,u,v;</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">    src=<span class="number">0</span>;des=<span class="number">2</span>*num+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">        Addedge(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=num+<span class="number">1</span>;i&lt;=<span class="number">2</span>*num;i++)</span><br><span class="line">        Addedge(i,<span class="number">2</span>*num+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;u);</span><br><span class="line">        <span class="keyword">while</span>(u--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v);</span><br><span class="line">            Addedge(i,num+v+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=num+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num-Dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>E. 求次短路是否等于最短路长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN (10000 + 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (5000*5000*2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, cost;</span><br><span class="line">    edge(<span class="keyword">int</span> tv = <span class="number">0</span>, <span class="keyword">int</span> tc = <span class="number">0</span>):</span><br><span class="line">        to(tv), cost(tc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> N, R;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; graph[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];     <span class="comment">//最短距离</span></span><br><span class="line"><span class="keyword">int</span> dist2[MAXN];    <span class="comment">//次短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dist, dist+N, INF);</span><br><span class="line">    fill(dist2, dist2+N, INF);</span><br><span class="line">    <span class="comment">//从小到大的优先队列</span></span><br><span class="line">    <span class="comment">//使用pair而不用edge结构体</span></span><br><span class="line">    <span class="comment">//是因为这样我们不需要重载运算符</span></span><br><span class="line">    <span class="comment">//pair是以first为主关键字进行排序</span></span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt; Q;</span><br><span class="line">    <span class="comment">//初始化源点信息</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push(P(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//同时求解最短路和次短路</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        P p = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="comment">//first为s-&gt;to的距离，second为edge结构体的to</span></span><br><span class="line">        <span class="keyword">int</span> v = p.second, d = p.first;</span><br><span class="line">        <span class="comment">//当取出的值不是当前最短距离或次短距离，就舍弃他</span></span><br><span class="line">        <span class="keyword">if</span>(dist2[v] &lt; d) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; graph[v].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = graph[v][i];</span><br><span class="line">            <span class="keyword">int</span> d2 = d + e.cost;</span><br><span class="line">            <span class="keyword">if</span>(dist[e.to] &gt; d2)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(dist[e.to], d2);</span><br><span class="line">                Q.push(P(dist[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dist2[e.to] &gt; d2 &amp;&amp; dist[v] &lt; d2)</span><br><span class="line">            &#123;</span><br><span class="line">                dist2[e.to] = d2;</span><br><span class="line">                Q.push(P(dist2[e.to], e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A, B, D,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;R,&amp;K);</span><br><span class="line">    <span class="keyword">while</span>(K--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;D);</span><br><span class="line">        graph[A<span class="number">-1</span>].push_back(edge(B<span class="number">-1</span>, D));</span><br><span class="line">        graph[B<span class="number">-1</span>].push_back(edge(A<span class="number">-1</span>, D));</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">if</span>(dist2[N<span class="number">-1</span>]==dist[N<span class="number">-1</span>])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F. 求大数因子个数，用大数分解求出质因数</p><p>…… 机房。记得传回来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;7.7&lt;/p&gt;
&lt;p&gt;A. 思维题，重点在于当剩余的n&amp;lt;k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>飞行员配对(最大流模板)</title>
    <link href="http://github.com/xxq1999/2018/05/11/2018-05-11-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9(%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/05/11/2018-05-11-飞行员配对(最大流模板)/</id>
    <published>2018-05-11T14:44:22.000Z</published>
    <updated>2018-05-11T14:44:54.819Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];        <span class="comment">//残留网络，初始为原图</span></span><br><span class="line"><span class="keyword">int</span> flow[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> nodeNum;            <span class="comment">//节点总数量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[<span class="number">201</span>],p,q,v,i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">        pre[i]=<span class="number">-1</span>;</span><br><span class="line">    que[<span class="number">0</span>]=s;</span><br><span class="line">    pre[s]=s;</span><br><span class="line">    p=<span class="number">0</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&lt;q)</span><br><span class="line">    &#123;</span><br><span class="line">        v=que[p++];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> (pre[i]==<span class="number">-1</span>&amp;&amp;(flow[v][i]&lt;g[v][i]||flow[i][v]&gt;<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i]=v;</span><br><span class="line">                que[q++]=i;</span><br><span class="line">                <span class="keyword">if</span> (i==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改残留矩阵和增广路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=t,v,MIN=INF;</span><br><span class="line">    <span class="keyword">while</span> (i!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i]&lt;g[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(MIN&gt;g[v][i]-flow[v][i])</span><br><span class="line">                MIN=g[v][i]-flow[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flow[i][v]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(MIN&gt;flow[i][v])</span><br><span class="line">                MIN=flow[i][v];</span><br><span class="line">        &#125;</span><br><span class="line">        i=v;</span><br><span class="line">    &#125;</span><br><span class="line">    i=t;</span><br><span class="line">    <span class="keyword">while</span> (i!=s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i]&lt;g[v][i])</span><br><span class="line">            flow[v][i]+=MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flow[i][v]&gt;<span class="number">0</span>)</span><br><span class="line">            flow[i][v]-= MIN;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 从节点s到节点t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s,t))</span><br><span class="line">        track_back(s,t);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=nodeNum+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (i!=s)res+=flow[s][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,b,e,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;nodeNum);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">memset</span>(flow,<span class="number">0</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;b,&amp;e))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>&amp;&amp;e==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        g[e][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        g[i][nodeNum+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&lt;=nodeNum;i++)</span><br><span class="line">        g[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max_flow(<span class="number">0</span>,nodeNum+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;看！代码&quot;&gt;&lt;a href=&quot;#看！代码&quot; class=&quot;headerlink&quot; title=&quot;看！代码&quot;&gt;&lt;/a&gt;看！代码&lt;/h2&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://github.com/xxq1999/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>我依赖成瘾了的你</title>
    <link href="http://github.com/xxq1999/2018/04/24/2018-04-24-%E6%88%91%E4%BE%9D%E8%B5%96%E6%88%90%E7%98%BE%E4%BA%86%E7%9A%84%E4%BD%A0/"/>
    <id>http://github.com/xxq1999/2018/04/24/2018-04-24-我依赖成瘾了的你/</id>
    <published>2018-04-24T13:36:44.000Z</published>
    <updated>2018-04-24T15:02:34.399Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Please give the password. "/> <label for="pass"> Please give the password. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX182Ox5Qt2wEAJSw5Oqmr/BbshPU1RejUIBj6VJAgnMdHxd+YZKrdyRp2g2mLgG5poo8MgOcFLpUtGGY6l8NrlpOYu0yiKAJSe8KwXtyBtD1Lf53kGj5q8/7k/C1QjgtpYkMBp0O3iUHzYP6ImDHy+BUaHkrHT/MCAEmgLuoGs82S76j/Zuc/7yAzmOaSM5SeFYIiCUi7UV1blyTVJTFkrJWbOmGToiuQ+wyOxVECz5KO7uXSds4Rs+n8+EG+xdpfnQ3ynjHH/5PK5wKP8iujHAgZYCWjRT+Ll8alTbpSed4NQGyzdFmZGOm1Z5SuvrV+zgk+54MLajifjIXyY7mUXODTOn2JJ14+ttHNWaT3PNwy3w0zR1AkB0Lehv7EYQ+nYC5t7k2KagFIrTJr180/mX24Idue43f+1GIrtQZfIPLZcTZ2FIKNFke46imw9sgV2h1YMGWi4aib6CwcK3eUq9KI0OMXYv+xIWFLwv0wCT9/Pv+Me4vma+bRPeSVi6C7AcOvHtGvT5GdOksYpJ56eHz6kDgJJUpuqkcAUwZ1yK+CKSgRDcGkKoUfpP2qBBTBJ+xEW0i1NfgefE2FDE+nk53zW49J0JqIxekniXPDM7y4lNpHx+Oe6X99uC6+xwCw1QufyDDR6b9mwvVwSPfu1WcLbhTEh0jx1IXJ/6fYbhV0iU/eoEN1Snqp8aFGH/NY6W+mMT6rE9iDMFMP5OW+Y1D3XMMzmfDCJEnrX/piwqa+TY1UFsXVKlMSkpUYgrdJfiU0bboyU8PrhrejBgL9+qfMzAyJ6Fp5+f7Peip2OJwDxBVMS2F+kX4GFEjHi1udwLIPZjA5u/yoOAhjNUrIZO4rjHuu0U/CBtT/feDJaoNokDG7/OUrZ2wrRvab4VQHvBtsJAubDuE7506fVD7Ok26gbx0zDMvIg2TCot3WQeDwVWmzJYBsUd9vY/SquD9UyUXPrzBAWYS3QQasIXkSYfigyUE1EkoGgh3hKsUcOqwWnNX4OTdDIMnEbPLPj21dPA3AW16OsOzblxs/LrF7p4CDNih69UGyDYmwWdDvfjASlj/ZQYxm2CFf15eFaneGj6E2r/y8ZqqxAtlxmMZa4WhlNV5SuL9M8GBCXMlVDpkr4RAuQgOUqyk8OUcnGdUBpVYM0TOwnjPAWm1GX5YWA9gko1Ilpj5W8YmcPLrceaINx4T7qT+fc9NKhUtaKivl/Xf0v//j9zsUDmRRdykZmD+JK0V+aI50KUA1XxkUmXbrG6GVK/3+LnMEYbMT6ut8rAWorOzA9rPvswdCwnp+YqQgSMk1/ronvaEEADqE+ReCT0JlxYJuuLcRlsmcuA4NUTmRNWQgCNuIE7A2j1rnMES6SsqMhwvNq6/YaIsOBTHxSnWQYKYeLP0YyPRVyr6EhOQm7yi6HR4uM+vG5A6RxGDRXRz+JhMTFcRq3uxF05cg9XzoJfJdrfcv8EF5IsW5+x+Ir9yrPDO99buCltD+b9tvFFVjgNO5Qz+aavfj8jXo9Ls/o4XlJaeMnmOGQfRz6amjfPle7ktbuxLhuleZYs1akmH3EqieDSgIl5YuvYaWPpVIOhEH5r9mxUB4QljF7z3CowLLb8OTw8CB6ZnU1NtKV9T/yl1KBtaxvu5EfwSFoI08IYRZQ9U/JC+TYvnHmJxPE7fN3N/LxhTbAkXcjGNz0APArBtD2DYS3TXAy/e5F1QMzt3TMtg24QYSFlbihZ/V3H6lulJQj+v+jQnV16JcjBgvdBUYT+4F9Jn3cTjoMY04PBoFlL8KTRMZsVF9rUvk/hUhmgIyK8SyC8I/JD1OeUjN3auik4kGStGYr4xNHxWKrvXmrYVVNiOZrlndTRP1yfeDwjmeiPRhwjcle5H2Ymd8v+plvT0hYe3MkjMhyDAto22UUyMCUqL19nEsMeS9QrxcgyFVGQ9HiNJEKHoIZpZWXHD06ppoOlxU4hp3EQdB9krl8SkbmfSzp1IgjmFsPpmBWfH8huOObKChOJzJof0InfQwLg8v10/P6Z7VtQ2VadkMpu2uUudl6DC+ukSW9F0f51toSlVSOi4COvURLmzDYUEK+11aEizmFU8bNVR/KbF8fnsK4surUKZ1gwJynN4Pq/LoeMYoap8ypeE9t5JXIIb56XK6TrmSsIduZXRQGFbnQR4D1ov8of9pHJidd/2jFzqGzpJQVlnTrKt7DVxp7I1NbIm/A5UuDNP9xl9Bq/iGpEpJ/U4Tkr+OXMWw1YIi4wyiB/E23dH4bF6y6XVtx5HyE3DSmfli20qCnFevi8esoYOZN9K3BT3k2fT8ZEmlI7k1XalBP1BvPVVXzAm7B7nnQ9DusXW2GwmxttoFBY19iHJJHIEvlWdf0weTvw79GZUl/CmbFl1RVMwvbKkNxCx3YtnKXORRr57BmCM7DPgB5AI9gUolGLmzXm389/u/bPIidLUx8qNRQfGCtAMJ3IkR8tdRGyFhpw216+mMWfjAyQ7HRN8IroodL8BbGtM80YptHECgvNdaOd/Zh9mNLvLZK9NSevYKM4LWlwowedcIb1fszDamRqELJgoQf3lHHeC30twvz3OLxj74v9JanJyLnGC5BvHekGJmAhrqJG5hKJqHUW+wFw420w4UPjKweiaSUnPSGoVQrnjtkny2wm25L9IduV4UsYtppbvBkjBZmCBzFt7ffegxVdB0Kd4LpS2NYJDyXiwfZ1vy6siWauyf3/nI4EjpIH41lCTA1Yj4ncRNSRvZhV3aaRnLYNmgIb0+TjB25027iB4Jj/wwt/mZeXL5MbOk+XYI5bpr9N8BPeEto0kr7e9OERf/JLLB23lIQz1Qs1b5NTvszi6IeBqIZtd5jNxR8ukkaq7aCPGgOdBDhfJWv1jW6ilpbgDyyEI1zHlD+1AJ0BBvv/9K9Vrq6CvgQmktQ53HklEYiaSv0wH7Q/EltxmyfowGYeDlZYec4aXsgsqFVrjSw1aGGuY6zzjeqC5q8RiBA/01Bw34IcthpEWY9LhQW0HuYq/tcYdvea68qsU/UeL+lAzj9Hp47ZOHJkEYblNoBMm7r/N6Qt51EC1WE1Y6BMUODAhcTRVyVLeo+S+5jpUKCSnpPmTQkJcwAS4+DvYe8U1mJVntOWuCcPLsdSxfkRJ9Ug9MuenSfpzUTwQZrVG6t5FZaVPWuv8wJsaBQ2/T0zPqcEOIGFQEBw+Y914LgtSwJdS5uwLT2rOLupp8sB4KlXJhDlCpbbD04ZYWOHIrw9rD1j6vK2iUmKPRFANYGnzfJm6VlXDi3VDa4o5udncdw5hc7e3I1+Vo8rH7T5S1/j4isJeb+2xCQU4AW162Z0qCqwpttf7NTzVDDz2zy9HmPU4JqDsnVA21xTAATnem+9r8LCM/Pp1XCdtMQ5pIq1sD26RWgr+1W+Y9DUEu7zPCdZvFnws8DN6b4jJwCC13p8PVjJ1lE9DYhTIg72hbZ+9cJe/KK5FrP2I/jxAQA4QTR9B7/SD6XXolhMbRVTVE6zZpAnk2Kqqv0IvbcFKtfabs23B6KeRQr1RFT8CtIQJpAF5tdBJAQH2JbxaUvdA4Y34UCA1ec9PU0GSpbV581tpZgam06ninMv+RECka3LXwAi+Lct601ciaGm5vuzt4eSDLFTnW5TPVCEp8wixPv6gnG75TY2c68ONfPBsco8jeSxVddO0yNZGqqf0ccAT2jQ/iuvJJTk+ahZ7NezfL3hnKgpB7hHG2GX27fzSvPpGO0TfW5e2RhuBi0foHzUtJ8Ts/0f3XwERltFaGqDMp9Eku+sidmOFoCtatKWYx81IMPUZI+kkcJufXblZCLcpp95MkdG3OhAOjrvguQp/sPYE4fp8naR5OCn58IKGd3H6UT+Y9tk6yfgG1rv1QX8TxCIzH5g90PhOeJgaLl5XnDSqDMuRKq8DS3Go4FaGlM/87/Hk9QJePUQgfkK5/b7jKWSb4ktoHUVUNNsJZq/rprda8CSlBxajPFxd2/xs1L1AcOx4RQd52F4UlF3TMbAK/JYgGP/UCJwQ9UOnC9VXGwmBiQITMmFuIoXLePHAnwMD4bZmFRFcphFBdOTCotiEnHLxNvsfIRSlin2Ml2NSM2+YImZ3nWuoxKMqAzE6IAUwlbyHeCOcACgMYUeGs/cTjCE4ChKaTSNbuIYmVrQ10Al/tIlhQzLTS/4EWeJM8imcNQ+em3KWSGlWAnEjTC1meKOG9ZH6VXemhPmaSn5MLgjH0fzG20USwTWimDd7ctxOUqdfRlw4RSFnE087vnKJAFPolQYXdijiIV9wUcoaUeiFE7ZthOQMxxDjC5rb+g2WaG2sfBVaznS9rX0Axu/3CTIXP9MUyJqQXx/KIplqw9viKHAnBW+ymo6eS6b0EKVAFsyE11CwLb/QdgG3jplMHUZwohYcDXWl73MHcE7gYAQr9C8ePsoJzLPrzo+EYG8xiqrcjmr5RDWYcJ2Z2gsfVQrCdflhUs8Ds12A2vL43QNGRZPBMDwzfz2GOf9+iGF/klWYVV2iC61lc8ACOor+VwQuQxBPgS8NaKK2Mcqo7cAB75wQ6fpjFpMIk+lirJGVNA4wTGuoiXJ5e8ugvZFP4avX1g8vcCQVr779MAtSoqAxADaKNHYkmzX6TFKv6I6Nyq8FksyyPyXeHpTh5obH78iwzzXtYgPaA3HNtupiPs53jAO9LvOU3Wd81K+biJjAVEapHdyoIhCSbnsLZ+XvoydaxtWCzd8a3RfXIDhsvsEXjUWsRmbwhCz9G4o+S3fqy2mmsoiVXNsko9VWMShLJ0LvA8z5qoJs312OKqWLLvVvc9x9XknCVMbXFCP681HiVRZzMQ30MIyuDFTr8q+Or7TIDUYWaXVJLoTpL9OseKvWIF6cXn1iDjS5WKmVPyl316wdLyB6z+lUBFtmlnoGGvxzoOJr7fYoim8++2hL8lKdOt8+7d4ymjsDqTuiIXru2XP31CznxouCkSJ84MW+IRMJmSS/SN4d5FWzuT4YJYkW7ym3QaV+WNSLcI2SVt0eHTPQnBYCKzMHRYamrKefxZvwqhECOrr83rfqhhi9c5NiQPML6NeYe2vK9Lmx8pGjjd5EAH+z+cJOjbfohFpRJ34iwqKcJQOs+M7RBOK9oyeXMu2xttxRrLodtj2QiMToI5me4A+YChuZX9dtABAAIvcE7JyM22XZQ1Tyy5GGnCo65yoXt7R52qYpV3AYeBKl82LbcyaEvj01ho5O6Gn+hwN3YH+oP5pMrGQ4EY8vK9nJVf34xiNpeqItxeJVFElCoE2GyuPPJD24seCEZmF6+XvU+EDSsrse9iSCCuniYkFxs1+/N5W8eWcsVd0cNqO5vvDmVbxkqV762wWgRnI62pG31eUzyyo/5a/bbA5+ZxMMQ7gOctEqWVnAfAfGVjmqHSBcViFOFOOh0yXf6p2PIYoMHNf9E2QrdO0h9nPbSLnxS1j/z0uOYils5UT36H/EKmTncTBXseWd29xeoRuhpmMBTiP+8AQYfB6BkRcqePxAHVsEfFuoe2by9WYPfBqNtuFkTVuH07ZUVK+zfVf6nM3uhCzYrIgN5obYtFD7mvN/V07ti+HGoipWnElZYwyCdFIFr5FDa2F4iQozCQyOi+u8yn+WQFAsb5y9pOefYZ2BHyUmX+78psegq9JM1vTO6KR9XL2qO3mhY8zyDskquHRwI3JTI7yIPDvuGrB96/lOoG2WNPnkX5YYo2g4x750FlfGFInNwdOInm2zeE8QSNphmlGfhrYFsg7OW+vAcBc1KO5xDsIdl0wYgk1JQlDtXqz/L3x0TwfMNYVKIwVnJJEyG/gwkzmbZiTiVdvE3R3FKsdav10tWbe9NHQ2TtOaAiEP9kM4Tng4MdrUYyZEwpysZXE9cSdG5KARTV1NlOfuh3PkUq5zBpbxiPRGELPgb/sKW0P2HvPcjTWPes/bIwoIsBpEHsj1Jh377RhJgUYJyo3Whvo0KZHGP4fYDGptKyOZyX4N4k6X7KPYPcnSCDH47/jmoPEs6exuOfef4NAZQ+jPJkUr+VF7siGRfUrt2QjbXkxGNblPW9M4MD1xl21FJb/284mrNrB8mtVIwXiTyQBEvnjQtFR6nNtbcMYvCT4k/ZHBhCIx0wN/Agjd/wXy2NqGKXLHlfhWir8x3gPHwQLN2w+yyjdBnZRKZjYCkaxDXRBTLRMoA4ToobUZM7yyOenk93Y3ujKEvVpr0FakuaVMTytorie4fs9Q0DBciHG9dRgnl/cNCSWunNx5mL9pDel8FD5Bie4mQy6X5EK7/pj7RY5+LmHnrSkazRH1E/w5fPWqZRjPjAifCJvhzhDyVchW6VBNNVLlq9APJ9BgAZv8Ld/j4SHs5FIUovJdbt6tXz26XW3E4wR+UuFo2GM+efjei8P8UPOPju0BPutd6qBBm+eGCzEnwnq0ue6ZN5ewE3PGw9jUM7biZa19mmP4hssVKmj6yz91eoybrDEZpmZZu7oIT2OUfBEI0qo8StmYf2ZJLL+a7gfRqDFguXG4X2EQ5MWdAFKsOvQmf+h6dOBCsRYyUoj4qaVIUZ2kribKqw2TDPbmw2a8bCx8cFZ8f8C1YgWiRiVFMF233l2sBslxgq5K/UmQ3Xx7RTB1c5FguGnav7pySi09+PBJBmNE6yl3vBClKgGhqZiEGULFJ5br4OaczJn/YFoybjap79c/KbE+nfZ0LMma+RNm5TfA0pNR51Kejsqt69OWl6zMkVO2MT7ubnd/MFmM523qBC0nHvUK3sLwLV91yi56pD68dOmXsVz0TUIazEQEg33oHu5FYvEKRPViij1PVcNvHzpN7Pt5Xi++KDri/Xmygv2aqVuhe5PLuMLFY5MpmWFyHzwDtSv2H6xoIViErARpHE60movcUvZ/LLGxgyBHkRiR0aAnIQVg+xv0PRD5b1Wz7sxVzxbfsHFAh3QRPa30RZvGtoz5Zpt10YpWWMZraLBnq+mSOD0EtJ5yNR08VvcyUFhcRCw4f1+5LBaEj80LwZkGFSptun4KfNiKPkJju70EU1yTq6xJCOw3upiQCs9abR2zzzsDnpdJMgUsqPb/sQc1lofPrRnnG7YdQQ3BtX9yqvN3Tvc2wFvUFH3FjfovscyJhkPgXwd1Jd4J3xwuzl8nAp4ybz+PeHb1fBN3SuBkJLNoE2ftfBYdO9nRh/9dtCcGQ83GX8T/ryfadG3RDqH77gQ/8LyiMvC6k33nv9vQnoJWqNiZOJ0W4Uw6+QxMAxgtgHzKobz+R/V35UJNyORd0wUCAx9r0WGSNVrZSA0xZU8VwEbf2mMxY5epbpDVmijXGcS34tmiI5O/hTJJOeZ85610I9w/ta8kvRVzsbrd+l4w2gFc3t55VV9T/klpucHdNqvNWipNzjD5WuMmIOjcatpYyLMQoEBzJmCLpfcT8HpvIXNTDNZhPYm2SqY1jeRSwb0I1Vbch6QHsFreKdaPTlG5brhEkioyiScLRfj9S/q/txZ/LfySIa9+y9LCfhrLMaJxSsLbq+tbDrpEGcOkRR6WS5MsdWFz74gUQEk5TT7s/CsDJGsLfCU0XH8+/7zH7Nz9EtxwQRFUlE+84gIgfVaKHJ9vApBfPw/h54MO32ZPLpY8gcAHm2DG0GRCHw+0sXPNwHbHoL+cb7ZbCSuZR17xNfZi/A9ITLmf1nuq2ZurryxDst4CGzM7Vr9M8g4Jb3wMkuJ6eScJ2VQTilOJToWfHdmKlz6JLnhnJ1zwF7/K8nCGm3XhPDpX54nXZFY6H1rIu+/TqOtu9QZ9eiIeQX4YtS45gLqMVXwCjte+eGYweey7DlQWid0ExDkIY/zvoMGG10bp1SNY2Rn8EQrVpzKsAU88/5PWTY+82HkPsL6h45zww+JvALgvW4kup587ca0tLbvEDlEvGy+jPTn/RBCyqNrO417cDvqvkOseuOipZEDO8VcAdAAC3n5QexQgNyZ3rFzhInBV8JTD9R0WuqHGRPdtO3pXRX7I/Dl1Fn8vnwYd36gu0QvtvYxIL5nLsK9iMbIZFWp+bdUP5F+Zd96dvZGJ3ZMmuTDeoz0y5ZwMGUCy6jH71CJEphl/NG9wsLJaEk8fC2TMyLHYTWt/kTuEXr/JuOpDXiKylkqDhXYyEqZ/wfeE5RSJFm1jEchzHXzYqFF3P9157ytqpFDlCzsLulIwAmfscOdo0idQn2spz6mHQuzKfMfXdzdoKfD7/+mzbINOmFTIoI8glAS5+pqFvPNvIzLd0+D5GqH9ZUbZPqNLivCQP2pAJF6idKtjlLc3otb4jWrG5QTbxlf+kc2Z24H+9ZcIaNrxz3Y0gHjzQHdyk98FnAcoeakfz++QjlgBCrJ/LhHjonMYMjmjsk2Lj3A6a2KMvcLvVAui3FcotJGn1gydH3xVs+mACK7RX/4PPxhVcC9C9WOhA12wI+pxGS3ql/en/uxj0H/n13zSoYKkr+QrdRKDpzUdVx2Zf5OZIpNJHIUhajSClA01qqlXZ9altTzExI+Zfil/CUHRnB77OcK8tPjfP8vOmL7hItU5eV2+T+/9477SHDeqyR6NJ/9C6GN0L2D34nzhFfzBk9XU8wtfvE7CnSc7rhCfBQrqJWx0016gliw8771cvwnJehBpR7rbyf27bQZmNwgus1YTDzkrUKDv4zw130KnVjbSMPXbqQGKzQlf2/ITfU+MVxZbFlMURn3yu2aGSSAtD8l+LQlLue1p2JtzpNNTsGsGmfxyHkXAMgS6fk0q+Vl6hineKc9t54DmzP4+/Bnz/Ijuo+qL6sT7mtKsMu3W+6w/UdV3dnDixjZjfddkwFdXQwz+bpDINdm5+Bbxx3ZXVwM6mZDqgFMeYVnfcNA969vcs1kT856FjTMM1cN6/eP/TZVf+OiBo0MYi3fRBcF82n5WEWjIP2lI1TiMpo5H/4E/lJ0GYKbEPy9jCNwb2yN+WGtVE7p6/CuhNmDm+j6E8mxPMLHdY6VmZzvi7Yp9fLnz1YsUw3T3xISsqJUFopjIjt/6oWx0zbA6bIKt9BYWD/Rjy1ziwdsroW0NqCQR05ms4L+CoVlxE/RhaE7IkYJmFwVDZOcGN8eCLCTNDrqlShAx147NwoFTLQyl32qWyGURbT97UMXEYnEpVKqjZfkZLVt+MelUCM0Ll5Epna3RFbcAc6Pzm0HPy7uumQe+svHlw8iMdxghKNh4gjJx6FSa8pyrZKOeurLWBLDiRopx4TjKc+aZ/l2BWR2pJyTYIjGFXtNeyWQzBMaVWQGOcoreiUr6YvrW7YRu9N0MCyDm2khlpqJIatQ/W8XhQ4Fyp6BzOHpReJr0yg6S72z+Co9WmB6aLg5kkCvYe/XJg5DABpv51tB2cOEcYDJPaWDubkbdwU/lWLhjKr7FukBfnneghOdf6B/XVyFkp9pNRJRSbhoWNjz+oVoNeqDakDhCJF+K4rpQwLmCU4VgFREleX1PO7vDoL8SjjLzT00X1e+kJxhSahcwEiRybgCR5N+XtajcX1OBiTgT+k0GmsbuAjkrH/7O1pGj9FeHaH+uDJTus3s2KoMFSyDty+fn8ejHrkgV1nL5aRnO51yc8F3ThklkExWL/QCg92/QL2X7ESCgU/TqZrPGKNo4KEv9bTwTMzTekiWRlZ/ksjnYg0n4J3QBPY3pnqMD2sfX/xD5lfaEWB3EvFqcHBNL7De6JZ+s4NhZJvsU8sui20ntI7pjYeC91qjhvrATDWDID6BH06gLvuqmO3bxFOG2+xoHvEXeXBrOObPmYg6+r429ZzM77VPAuJwZnnhAB+wmcMFi7SpoLUJwU9MBgwmctUtkkYVpa4ZrSa0VuywHPW4otM3ZmuZDvz13Q0ZlC1sEouMgmxlSzxZY3vnnbtdN/jA71R294oJXWMrP0hlgrf60XoGnjnKxr56a8nLGe4qwK6GGcfvdcVtf+rx85HZhliuxbEmtBqIshX81TZIW72P8cjwF1W06YuthmJ06j4npkqwH+ujljYUgLsZ/uOe/coVrTfEfnrt6YwAez0by4cAkSp6fp0huW/FCxHGkZdOHcOh8aHZ2aG2eZh7MfmUUi7o/TiltTUv2uQAsrz6gt3VoRUj5evbOh2LUJ4hw4LK4m+1QgZjK9iRe3KO80NzR0o7g6R5KuTzkwx5I5dABAY3lx50HxQsEjnuSMJcmP3ZBlxIdR17qTWHCekjlpQrRlmmxI3Czud9z/UEXzxHTQm7B3Dp7gYGm+ImudEl0lgH2qg0OXw+Px8cXOZiuoYduSOxcOHC7FMWMPdHB/3UOmwnh8Pe8OQdUpymk/vxIekfiG0OdwsPNgBKUJq4bU/2MmLbYmAQDMoAA0xTf7c6npRE3Yj/N29kReGNZ4j17vSnwlMpA/FEFwJRUBnGOWlq2m5Jz2JoFdKEWDJYJ6ydQDyVz/ubVUf+Js55dfFnoQruaUm5pCwE1cow78/6DkExAKPApeKRDn32pJ5mDiXSY4UFnthQ1Uv/fekT1czUh9YsKJu9mVvLaO09n4BerpF7XCaxkSOmA9BT4iMWLW2TOo1B+vhTFmjJHaikCYyVWTkiEO7RklfUjSZUFjQl0599/B+XLnsU98PJiQ96JYgEzeMGW4vE3wTWIjzlXC/8dxAbxYaDSzeeNqer5MwU4tFJj6rg/+nUZtW11EbFyo/GlTVIc4inhUxCwzkloE8NeBQ4zHU1bPaodEVZtqHYHubnrIqxvpT87cbZgps9rd+3FhN5lk833EXF5Kickhdxi/duASTBQe9gp+/6Mzw+xT9kN8m7LS5HozwtMCZiUNWis4PB6/Owqo56kCdtEm7Za7CFBfIWSulYRWKDD6jWTGUSfKqOImn4VJ8GvfAenYvgEXbUXR81SmeHl2J2aZbYSboHKgZIrzYO0OBBH2r9YHgj8xt3QaIh7wlCXvKLsaH5j9YWdiMf/TYXn0nLd9VqSTSTJkHuNHlS4Hox9J0SaL7v/ms/NV3beh0igzgDhqdWJr78HUKpK25YpiYZssJ6Qoqg01zSCa7/PuvYJRJLNXGBXDs2vNFM/SHunAyiJJ2y6KXGTNvdBOlbV59Wi1UtJOkYuisuFRkLbXm2zTT/PFXfO2RE1b0WwaB6PboeV3quLGg3RwMExv8crU2mCoscKXveJt/unAooqu/fBRB5Dw5AeAz5ErZWkUBl8A+9WJDRriyFAPvfqPbHJr0IPpxJhPZLZ0ucX2vN66TKoV2+1EHa16vqDgivBwYIwRamz/O0F9iTAWDS1lM1Gbo89185fYxkHIwtHJWwk6Rr0KsJqO+A69lfTbddOhLRd6KHP3E6DXmlI4vS7kS5lDfvPbc5/+t3W1V/n1Tk8ygNh5QwtC45uPPTfhYwoDgkrQpNceu5XVs+yAXLvzE/4eEk2oUciiibVB2A1x7Z3BMowZU71l55BbGHyuq9CAhUYjfPQvYpPF/x2XPszjmvrng5cZzU1AIakAuNATRntYNNK51rGSL1+Tgqr2FG+R1iz2vQRMRFaOHg8QGK5oEfrMPYWE7DsBtqIgzTvxsR+y6MPB74coRTNNyAxA2lbzok7FpLuiRz9c8+wq+QWkUQrEIuPEey5OfydlZm9GRc6FlAFaWVlhwxzfvVGrzsl9SuE60j3dFybT23NUrRXiJ7pO7kYYuNOzUNJRgOXZfPmw2N9Ux9J2agDCOaRgDZiR2P3zDBBfzZUl1ySQ1UDRyrRbOR9LJG1n3L9exljwLKPz5QAfabVbOfVnR4+IN0n9AYJRFOXKRyA2QvmoXfB89SNHEkT809gufrs1hxXLWpqmdlJ600PhXNM6T6pKTfGjz4CSRnYUqzGbJTWkxfHWvaBThc6wMvhd3eqhgnlXb3iggMJb6BA3KVaO0xMwtIgcFOOndCZmLBcnDZsVY3sJ0gyFV1nkRkyIhSIVoU8tUAhOT2bmlmDRRyXW0x9C1G80U8aw3R0IEIm1OEg7Ah422xVx9/a3ybbRT/I+DcDoLsv8nUWj6E68sxhqO4hVYIMpfrfvvlOKtLAZTiiaCDBiwNafLur+XW8hsBQIMmlR+vqsdCUVx+th0Mhy7UrnE1zGOzRBKEZ/iWIAZ/K9ccsbaWsz/5CUK96rQaoDCMyvKEBCvgFFI/XQdThe12UPPr2FlCX9INClOVndVacQBwofSwkB8w6EbAdtsZjR/dTxvvGhW0140B7BDxhnYn/kkEYvtnjt68UvVdhjxIM+J2Ij/MtIqTGFvnRq8oJd5gYctb3+briER3JS/QxYkGesS4Jrz+O1kwaobhewa5VDB/y/zZ+rfkH8/oF4SKFZEHEX80tNQonMfaXw8P3Xrxq6IXekVTA5g== </div>]]></content>
    
    <summary type="html">
    
      NEED PASSWORD./文章已加密
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>网络流 【待续】</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-网络流/</id>
    <published>2018-04-23T11:26:23.000Z</published>
    <updated>2018-05-13T07:20:14.748Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：</p><p><img src="\mdpicture\水管流量.jpg" alt="水管流量最大该是多少呢"></p><h2 id="网络流的定义"><a href="#网络流的定义" class="headerlink" title="网络流的定义"></a>网络流的定义</h2><p>在有向图G=（V,E）中：</p><p>1、有唯一的一个源点S（入度为0：出发点）</p><p>2、有唯一的一个汇点（出度为0：结束点）</p><p>3、图中的每条弧（u,v）都有一个非负的容量c（u,v）</p><p>满足上述条件的图G称为网络流图。</p><p>记为：G=（V,E,C）</p><a id="more"></a><h3 id="可行流"><a href="#可行流" class="headerlink" title="可行流"></a>可行流</h3><p>每条管道中可以通过的流量。</p><p><img src="\mdpicture\可行流.JPG" alt="可行流"></p><h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><p>在所有的可行流中，流量最大的一个流。（最大流可能不止一个）</p><p>解决最大流的问题常用到Ford-Fulkerson方法（在此方法下，存在着若干种不同时间复杂度下的实现）</p><h4 id="Ford-Fulkerson和Edmonds-Karp"><a href="#Ford-Fulkerson和Edmonds-Karp" class="headerlink" title="Ford-Fulkerson和Edmonds-Karp"></a>Ford-Fulkerson和Edmonds-Karp</h4><p>1、残存网络</p><p>第一个图是流网络，边上的12/16,12指的是流量，16是容量。</p><p>第二个图是残存网络，可能会存在一对相反的边，如刚刚12/16在残存网络中，体现为 v1-&gt;s = 12，s-&gt;v1 = 16-12。与流网络中对应的边代表的是该边的残余容量，流网络中不存在的边是一条反向的已有流量边，这部分流量<strong>可以通过回流减少</strong>。（残存网络中值为0的边不画出）</p><p><img src="\mdpicture\残余网络.JPG" alt="残存网络和流网络对比"></p><p>2、增广路径</p><p>假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量&lt;容量，注意，是严格的&lt;,而不是&lt;=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。</p><p>3、方法</p><p>我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。<strong>当找不到增广路的时候，当前的流量就是最大流</strong>，这个结论非常重要。</p><!--而Ford-Fulkerson方法和Edmonds-Karp的区别就是在寻找增广路时，前者是随便找一条，dfs深搜，后者找一条节点数最少的，bfs广搜--><p>寻找增广路的时候我们可以简单的从源点开始做bfs，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。</p><p>4、代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[MAX][MAX];  <span class="comment">//残留网络容量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAX];  <span class="comment">//保存增广路径上的点的前驱顶点</span></span><br><span class="line"><span class="keyword">bool</span> visit[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ford_Fulkerson</span><span class="params">(<span class="keyword">int</span> src,<span class="keyword">int</span> des,<span class="keyword">int</span> n)</span></span>&#123;   <span class="comment">//src：源点 des：汇点 n：顶点个数</span></span><br><span class="line">     <span class="keyword">int</span> i,_min,total=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!Augmenting_Path(src,des,n))<span class="keyword">return</span> total; <span class="comment">//如果找不到增广路就返回，在具体实现时替换函数名</span></span><br><span class="line">         _min=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">         i=des;</span><br><span class="line">         <span class="keyword">while</span>(i!=src)&#123;   <span class="comment">//通过pre数组查找增广路径上的边，求出残留容量的最小值</span></span><br><span class="line">             <span class="keyword">if</span>(_min&gt;c[pre[i]][i])_min=c[pre[i]][i];</span><br><span class="line">             i=pre[i];</span><br><span class="line">         &#125;</span><br><span class="line">         i=des;</span><br><span class="line">         <span class="keyword">while</span>(i!=src)&#123;    <span class="comment">//再次遍历，更新增广路径上边的流值</span></span><br><span class="line">             c[pre[i]][i]-=_min;</span><br><span class="line">             c[i][pre[i]]+=_min;</span><br><span class="line">             i=pre[i];</span><br><span class="line">         &#125;</span><br><span class="line">         total+=_min;     <span class="comment">//每次加上更新的值</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==t)</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">  used[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">Edge &amp;e=g[u][i];</span><br><span class="line"><span class="keyword">int</span> v=e.to;</span><br><span class="line"><span class="keyword">if</span>(!used[v]&amp;&amp;e.cap&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=dfs(v,t,min(e.cap,f));</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap-=d;</span><br><span class="line">g[e.to][e.rev].cap+=d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,f;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">f=INF;</span><br><span class="line"><span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line"><span class="keyword">int</span> d=dfs(s,t,f);</span><br><span class="line"><span class="keyword">if</span>(d&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">res+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">--*</span><br><span class="line">    Ford-fulkerson最短扩充路</span><br><span class="line">    调用前输入残余矩阵 g[][]</span><br><span class="line">    直接调用max_flow(源点, 汇点) 返回最大流</span><br><span class="line">    </span><br><span class="line">    注意初始化：nodeNum（节点总数量）</span><br><span class="line">    注意节点标号： <span class="number">0</span> - (nodeNum<span class="number">-1</span>)</span><br><span class="line">*/</span><br><span class="line"><span class="comment">//pku1273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN];        <span class="comment">//残留网络，初始为原图</span></span><br><span class="line"><span class="keyword">int</span> flow[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> nodeNum;            <span class="comment">//节点总数量</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> que[<span class="number">201</span>], p, q, v, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">        pre[i] = <span class="number">-1</span>;  </span><br><span class="line">    que[<span class="number">0</span>] = s;</span><br><span class="line">    pre[s] = s;</span><br><span class="line">    p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; q)</span><br><span class="line">    &#123;</span><br><span class="line">        v = que[p++];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">            <span class="keyword">if</span> (pre[i] == <span class="number">-1</span> &amp;&amp; (flow[v][i] &lt; g[v][i] || flow[i][v] &gt; <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pre[i] = v;</span><br><span class="line">                que[q++] = i;</span><br><span class="line">                <span class="keyword">if</span> (i == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改残留矩阵和增广路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = t, v, min = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i] &lt; g[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; g[v][i] - flow[v][i])</span><br><span class="line">                min = g[v][i] - flow[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (flow[i][v] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; flow[i][v])</span><br><span class="line">                    min = flow[i][v];</span><br><span class="line">            &#125;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">    i = t;</span><br><span class="line">    <span class="keyword">while</span> (i != s)</span><br><span class="line">    &#123;</span><br><span class="line">        v = pre[i];</span><br><span class="line">        <span class="keyword">if</span> (flow[v][i] &lt; g[v][i])</span><br><span class="line">            flow[v][i] += min;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (flow[i][v] &gt; <span class="number">0</span>)</span><br><span class="line">                flow[i][v] -= min;</span><br><span class="line">        i = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 从节点s到节点t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s, <span class="keyword">const</span> <span class="keyword">int</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (bfs(s, t))</span><br><span class="line">        track_back(s, t);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">        <span class="keyword">if</span> (i != s) res += flow[s][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, b, e, c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;nodeNum)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(flow, <span class="number">0</span>, <span class="keyword">sizeof</span>(flow));</span><br><span class="line">        <span class="keyword">while</span> (m--)  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;b, &amp;e, &amp;c), g[b - <span class="number">1</span>][e - <span class="number">1</span>] += c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max_flow(<span class="number">0</span>, nodeNum<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h3><p>就是从图G(V,E)中去除一些边，使得图G中源点S到终点T不连通。如果去除的这些边的权和最小，就是最小割。这个权和可以证明等于网络的最大流量！因此，最大流等价于最小割。求解最大流问题，也可以转化为最小割。求最大流和求最小割集是两类不同的算法。求解最小割集普遍采用<strong>Stoer-Wagner</strong>算法。</p><h4 id="Stoer-Wagner"><a href="#Stoer-Wagner" class="headerlink" title="Stoer-Wagner"></a>Stoer-Wagner</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cut</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) node[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> k, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; now; i++) &#123;</span><br><span class="line">            k = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; now; j++) <span class="keyword">if</span>(!vis[node[j]]) &#123;</span><br><span class="line">                dis[node[j]] += G[node[pre]][node[j]];</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">-1</span> || dis[node[k]] &lt; dis[node[j]]) &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[node[k]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == now - <span class="number">1</span>) &#123;</span><br><span class="line">                ret = min(ret, dis[node[k]]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; now; j++) &#123;</span><br><span class="line">                    G[node[pre]][node[j]] += G[node[j]][node[k]];</span><br><span class="line">                    G[node[j]][node[pre]] = G[node[pre]][node[j]];</span><br><span class="line">                &#125;</span><br><span class="line">                node[k] = node[--now];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;\mdpicture\水管流量.jpg&quot; alt=&quot;水管流量最大该是多少呢&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络流的定义&quot;&gt;&lt;a href=&quot;#网络流的定义&quot; class=&quot;headerlink&quot; title=&quot;网络流的定义&quot;&gt;&lt;/a&gt;网络流的定义&lt;/h2&gt;&lt;p&gt;在有向图G=（V,E）中：&lt;/p&gt;
&lt;p&gt;1、有唯一的一个源点S（入度为0：出发点）&lt;/p&gt;
&lt;p&gt;2、有唯一的一个汇点（出度为0：结束点）&lt;/p&gt;
&lt;p&gt;3、图中的每条弧（u,v）都有一个非负的容量c（u,v）&lt;/p&gt;
&lt;p&gt;满足上述条件的图G称为网络流图。&lt;/p&gt;
&lt;p&gt;记为：G=（V,E,C）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="网络流" scheme="http://github.com/xxq1999/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Clever King (最大权闭合子图模板)</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-Clever-King-(%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-Clever-King-(最大权闭合子图模板)/</id>
    <published>2018-04-23T08:42:22.000Z</published>
    <updated>2018-04-24T14:58:39.644Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Clever-King"><a href="#Clever-King" class="headerlink" title="Clever King"></a><a href="https://nanti.jisuanke.com/t/26172" target="_blank" rel="noopener">Clever King</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>T组数据，有n个产品，m个矿坑。接下来n个数字happiness[i]表示第i个产品的幸福指数，接下来m个数字，ori[i]表示第i个矿坑的开发费用。接下来n行，每行先输入两个数字n1，n2，分别表示第i号产品需要开发的矿坑，和需要的原材料产品。（矿坑开发后材料无限，产品生产后幸福指数一定会增加，不管是作为产品本身还是原材料），要求 幸福指数 - 费用  的最大值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最大权闭合子图模板。<a href="https://blog.csdn.net/jingmiaa/article/details/52814814" target="_blank" rel="noopener">【关于网络流】</a>（ND）</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个子图（点集）， 如果它的所有的出边都在这个子图当中，那么它就是闭合子图。<br>点权和最大的闭合子图就是最大闭合子图。</p><p>简单说就是有一些点，每个点有一些点权（正负都有），要选一个点，就必须要选它所连向的点。</p><p>有可能连成一条链，像这样：x-&gt;y-&gt;z-&gt;…</p><p>求合法的点集的最大的点权和。</p><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>设s为源点，t为汇点。</p><p>使s连向所有的正权点（非负权点），边权为点权。</p><p>使所有非负权点（负权点）连向t，边权为点权的绝对值。</p><p>若需要选y才能选x，连一条由x到y的边，边权是∞。</p><p><strong>最大点权和 = 正权点和 - 最小割</strong></p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">505</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next,flow;</span><br><span class="line">&#125;e[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cur[maxn],co[maxn],d[maxn],Final[maxn],tot,s,t;</span><br><span class="line"><span class="comment">// s源点 t终点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].to=y,e[tot].next=Final[x],e[tot].flow=z,Final[x]=tot;</span><br><span class="line">    e[++tot].to=x,e[tot].next=Final[y],e[tot].flow=<span class="number">0</span>,Final[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flow)</span> <span class="comment">//模板 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==t) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> use=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[x];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(e[i].flow&gt;<span class="number">0</span>&amp;&amp;d[e[i].to]+<span class="number">1</span>==d[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=dg(e[i].to,min(flow-use,e[i].flow));</span><br><span class="line">            use+=c;</span><br><span class="line">            e[i].flow-=c;</span><br><span class="line">            e[i^<span class="number">1</span>].flow+=c;</span><br><span class="line">            <span class="keyword">if</span>(flow==use) <span class="keyword">return</span> use;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur[x]=Final[x];</span><br><span class="line">    <span class="keyword">if</span>(!(--co[d[x]])) d[<span class="number">0</span>]=t;</span><br><span class="line">    ++co[++d[x]];</span><br><span class="line">    <span class="keyword">return</span> use;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n1,n2,temp,n,m;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=<span class="number">0</span>;tot=<span class="number">1</span>;s=t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cur,<span class="number">0</span>,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">        <span class="built_in">memset</span>(co,<span class="number">0</span>,<span class="keyword">sizeof</span>(co));</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">memset</span>(Final,<span class="number">0</span>,<span class="keyword">sizeof</span>(Final));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        ans=n+m;s=ans+<span class="number">1</span>;t=ans+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//s和正权相连</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            sum+=temp;</span><br><span class="line">            link(s,i,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)  <span class="comment">//t和负权相连</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            link(i+n,t,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n1,&amp;n2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n1;j++)  <span class="comment">//i个点需要j的话，就把i-&gt;j，边权是inf</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                link(i,temp+n,<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                link(i,temp,<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        co[<span class="number">0</span>]=t;</span><br><span class="line">        <span class="keyword">for</span>(;d[<span class="number">0</span>]&lt;t;) sum-=dg(s,<span class="number">1</span>&lt;&lt;<span class="number">30</span>); <span class="comment">//最小割</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Clever-King&quot;&gt;&lt;a href=&quot;#Clever-King&quot; class=&quot;headerlink&quot; title=&quot;Clever King&quot;&gt;&lt;/a&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="最大权闭合子图" scheme="http://github.com/xxq1999/tags/%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Goldbach （Miller Rabin模板+埃氏筛模板)</title>
    <link href="http://github.com/xxq1999/2018/04/23/2018-04-23-Goldbach-%EF%BC%88Miller-Rabin%E6%A8%A1%E6%9D%BF+%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%A8%A1%E6%9D%BF)/"/>
    <id>http://github.com/xxq1999/2018/04/23/2018-04-23-Goldbach-（Miller-Rabin模板+埃氏筛模板)/</id>
    <published>2018-04-23T07:53:22.000Z</published>
    <updated>2018-04-23T08:40:14.158Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Goldbach"><a href="#Goldbach" class="headerlink" title="Goldbach"></a><a href="https://nanti.jisuanke.com/t/25985" target="_blank" rel="noopener">Goldbach</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>哥德巴赫猜想：输入一个T（100），输入一个偶数n（2&lt;n&lt;2^63），输出任意一组素数a，b，使得a+b=n。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>a和b必定为一大一小，从小的入手，用埃氏筛筛出1e6内的所有素数prim[]（猜想到小的那个素数一定不超过1e6），然后遍历prim[]，算出n-prim[i]，用基于概率的素数测试算法MillerRabin判断它是不是素数即可。</p><p><a href="https://blog.csdn.net/sunshine_cfbsl/article/details/52425798" target="_blank" rel="noopener">【Miller Rabin素数判定】</a></p><p>这里注意，由于2^63次过大，在相乘得过程中会超longlong，因此要改用unsigned long long。</p><blockquote><p>做题的时候，遇到范围是2^63，取模2^64的这种题目。遇到这种限制条件时就要想到用unsigned long long类型。这样，如果ull类型的整数溢出了，就相当于取模2^64了。因为ull的范围是[0,2^64-1]。而ll的范围是[-2^63,2^63-1]，因为有符号的第63位表示“正负”而不表示数值。</p></blockquote><p><strong>附一个公式：(1+a1)(1+a2)(1+a3)……(1+an-1)(1+an) = 1+sum{ai}+sum{ai·aj}+sum{ai·aj·ak}+……+sum{a1·a2·…·an}</strong></p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">typedef</span> ULL ULL;</span><br><span class="line">ULL n, x[MAXN];</span><br><span class="line"></span><br><span class="line">ULL pri[MAX+<span class="number">5</span>],num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)pri[num++]=i;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;num&amp;&amp;i*pri[j]&lt;MAX;j++)</span><br><span class="line">            vis[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">multi</span><span class="params">(ULL a, ULL b, ULL p)</span> </span>&#123;</span><br><span class="line">    ULL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1L</span>L) ans = (ans+a)%p;</span><br><span class="line">        a = (a+a)%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">qpow</span><span class="params">(ULL a, ULL b, ULL p)</span> </span>&#123;</span><br><span class="line">    ULL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1L</span>L) ans = multi(ans, a, p);</span><br><span class="line">        a = multi(a, a, p);</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ULL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">20</span>, i, t = <span class="number">0</span>;</span><br><span class="line">    ULL u = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!(u &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s--) &#123;</span><br><span class="line">        ULL a = rand()%(n<span class="number">-2</span>)+<span class="number">2</span>;</span><br><span class="line">        x[<span class="number">0</span>] = qpow(a, u, n);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            x[i] = multi(x[i<span class="number">-1</span>], x[i<span class="number">-1</span>], n);</span><br><span class="line">            <span class="keyword">if</span>(x[i] == <span class="number">1</span> &amp;&amp; x[i<span class="number">-1</span>] != <span class="number">1</span> &amp;&amp; x[i<span class="number">-1</span>] != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x[t] != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ULL n,temp;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Miller_Rabin(n-pri[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,pri[i],n-pri[i]);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Goldbach&quot;&gt;&lt;a href=&quot;#Goldbach&quot; class=&quot;headerlink&quot; title=&quot;Goldbach&quot;&gt;&lt;/a&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="模板" scheme="http://github.com/xxq1999/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="素数" scheme="http://github.com/xxq1999/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ACM-ICPC &amp; U</title>
    <link href="http://github.com/xxq1999/2018/04/19/2018-04-19-ACM-ICPC-&amp;-U/"/>
    <id>http://github.com/xxq1999/2018/04/19/2018-04-19-ACM-ICPC-&amp;-U/</id>
    <published>2018-04-19T13:50:24.000Z</published>
    <updated>2018-04-19T14:35:16.091Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32574246&auto=0&height=66"></iframe><p><img src="\mdpicture\ACM.jpg" arc="ACM-ICPC :) "></p><p>world final的直播，窝在图书馆的角落看了一下午，这种感觉真的很棒，真的让我有一种ACM即是力量的冲动。看着这么多的队伍们提交，Pending的进度条一点一点增加，然后高亮，切到队伍的镜头，一阵紧张，最后AC后的欢呼和击掌，然后匆匆进入下一题。</p><p>代码的力量是什么呢？</p><p>ACM的力量是什么呢？</p><p>让我明明笨拙到坚持不下去，却又不舍得放弃它。</p><p>大概是等待pending的期待的心情，WA了之后自言自语的不服，TLE绞尽脑汁优化的苦恼，或者是看着队友疯狂输出的感叹，大家叽里呱啦实在是很吵闹的讨论 …… 以及最后出现的世界上最好看的单词Accept的欣喜若狂。</p><p>真是充满着魔力的一切。</p><p><img src="\mdpicture\键盘上的秘密.jpg" arc="键盘上的星星点点"></p><hr><p><img src="\mdpicture\西装和狗毛.jpg" arc="西装领带，狗毛"></p><blockquote><p>四月十九号，倒计时：三天。</p></blockquote><hr><p><img src="\mdpicture\JJ圣所.jpg" arc="丹宁执着"></p><blockquote><p>许下演唱会的心愿。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;8
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>木棒切割（二分+DP+滚动数组优化）</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-%E6%9C%A8%E6%A3%92%E5%88%87%E5%89%B2%EF%BC%88%E4%BA%8C%E5%88%86+DP+%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-木棒切割（二分+DP+滚动数组优化）/</id>
    <published>2018-04-18T13:55:24.000Z</published>
    <updated>2018-04-18T14:21:08.279Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="木棒切割"><a href="#木棒切割" class="headerlink" title="木棒切割"></a><a href="https://vjudge.net/problem/HYSBZ-1044" target="_blank" rel="noopener">木棒切割</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有n个木棒，最多能切m下，接下来n行，给出n个木棒的长度，求出切割后最大长度的最小值，并求出有多少种切割方式，取模10007</p><p>n&lt;=50000，0&lt;=m&lt;=min(n-1,1000)，1&lt;=Li&lt;=1000</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二分答案，low=0，high=sum[n]。</p><p>得到最小值ans。</p><p>接下来用DP，求出切割种数。</p><p><strong>dp[i][j]表示前i个木棒切割j下的种数，设sum[i] 是前i个木棒的长度和 ，那么dp[i][j]=求和{ dp[k][j-1] }，满足条件：k&lt;i &amp;&amp; sum[i] - sum[k]&lt;=ans</strong> 。</p><p>但是写完之后，我们发现，诶，这个时间复杂度……O(n^2 * m)，这不超时有鬼……</p><p>于是我们可以进行下面的优化：</p><h3 id="1、空间"><a href="#1、空间" class="headerlink" title="1、空间"></a>1、空间</h3><p>由于当前的dp[][j]只与dp[][j-1]有关，所以呢，我们可以用滚动数组，用dp[][now]代替dp[i][j]，用dp[][pre]代替dp[][j-1]，其中pre=now^1。</p><p>这样空间就小啦~</p><h3 id="2、时间"><a href="#2、时间" class="headerlink" title="2、时间"></a>2、时间</h3><p>这个好难理解啊我觉得……大概是太笨了哼唧</p><p>对于dp[i][now],其实是dp[Mink][pre]……dp[i-1][Mink]的和！！Mink 就是满足 k&lt;i &amp;&amp; sum[i]-sum[k]&lt;=ans的最小的k。那么，对于从 1 到 n 枚举的 i ，相对应的 Mink 也一定是非递减的（因为 Sum[i] 是递增的）。我们记录下 dp[1][pre]…dp[i-1][pre] 的和 S ，Mink 初始设为 1，每次对于 i 将 Mink 向后推移，推移的同时将被舍弃的 p 对应的 dp[p][pre] 从 S 中减去。那么 dp[i][Now] 就是 S 的值。</p><p>时间复杂度O(nm)。</p><p>接下来请欣赏代码——</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">10007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50010</span>],sum[<span class="number">50010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> <span class="comment">//看看有没有单比mid还大的 或者分割不了的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=a[i];</span><br><span class="line">        <span class="keyword">if</span>(s&gt;mid) cnt++,s=a[i];</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mid) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> <span class="comment">//二分答案</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=sum[n];</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) ans=mid,r=mid<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">50010</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//滚动数组，前i块切j下的数量</span></span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>,pre=<span class="number">1</span>,s,Mink; <span class="comment">//mink 最小的满足k&lt;j &amp;&amp; s[i]-s[k]&lt;=ans 的</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="comment">//切i下</span></span><br><span class="line">    &#123;</span><br><span class="line">         s=<span class="number">0</span>,Mink=<span class="number">1</span>; </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="comment">//前j块</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="comment">//如果一下不割</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span>(sum[j]&lt;=ans) dp[j][now]=<span class="number">1</span>; <span class="comment">//如果这块东西比要求的要小，就前j块割0下是1钟</span></span><br><span class="line">                 <span class="keyword">else</span> dp[j][now]=<span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//s=sum&#123;dp[k][j-1]&#125; k&lt;j&amp;&amp;s[i]-s[k]&lt;=ans ，sum也相当于减去那些不满足条件的，</span></span><br><span class="line">                 <span class="comment">//因为这东西肯定单调非递减，所以一直找到最小的满足的k就好</span></span><br><span class="line">                 <span class="keyword">while</span>(Mink&lt;j&amp;&amp;(sum[j]-sum[Mink])&gt;ans) <span class="comment">//找到最小的满足条件的k</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     s-=dp[Mink][pre]; <span class="comment">//减去前mink块不符合条件的 切了i-1下的</span></span><br><span class="line">                     s=(s+MOD)%MOD;</span><br><span class="line">                     Mink++;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dp[j][now]=s%MOD; <span class="comment">//别忘了取模</span></span><br><span class="line">             &#125;</span><br><span class="line">             s=(s+dp[j][pre])%MOD; <span class="comment">// s加上前j块割i-1下的</span></span><br><span class="line">         &#125;</span><br><span class="line">         res=(res+dp[n][now])%MOD; <span class="comment">//总数相当于总数加上n块割i下的</span></span><br><span class="line">         now^=<span class="number">1</span>; <span class="comment">//滚动数组</span></span><br><span class="line">         pre=now^<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;木棒切割&quot;&gt;&lt;a href=&quot;#木棒切割&quot; class=&quot;headerlink&quot; title=&quot;木棒切割&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分" scheme="http://github.com/xxq1999/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
      <category term="滚动数组" scheme="http://github.com/xxq1999/tags/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Buy a ticket (最短路SPFA)</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-Buy-a-ticket-(%E6%9C%80%E7%9F%AD%E8%B7%AFSPFA)/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-Buy-a-ticket-(最短路SPFA)/</id>
    <published>2018-04-18T08:27:33.000Z</published>
    <updated>2018-04-18T08:49:55.281Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Buy-a-ticket"><a href="#Buy-a-ticket" class="headerlink" title="Buy a ticket"></a>Buy a ticket</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你n个城市，m条无向路，每条路有vi的权值（&gt;0），每个城市有ai的音乐会花费。</p><p>某人想去看音乐会，如果她在i城，他要去j城看演出，那么要花费的钱相当于来回的路费加上j城的演唱会的钱（也可以在自家看演出）。求的是，每个城市的人看一场音乐会的最少花费。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很熟悉的思路，定义一个超级原点，将超级原点和每个城市连起来，路的权值设为该城市的音乐会花费，同时加其他的路的权值设为原来的两倍（来回的花费），那么从原点到每个城市的最小花费就是每个城市的人看音乐会的最小花费。（最短路）</p><p>开头用dijkstra写，看了一下复杂度肯定会T，o(n^2)的样子，然后交了一发。后来换用SPFA，队列啥的，还是T，然后看了一下过的人的代码，发现他们用优先队列优化，将花费大的放在了前面。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to; <span class="comment">//目的</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val; <span class="comment">//花费</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;   </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node k)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val&gt;k.val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;Next[<span class="number">200005</span>]; <span class="comment">//路</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">200005</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//在Q里的情况</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis[<span class="number">200005</span>];  <span class="comment">//距离原点的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis)); </span><br><span class="line">    priority_queue&lt;Node&gt; Q; <span class="comment">//修改成优先队列，默认路径花费大的放前面，是的</span></span><br><span class="line">    Node temp;</span><br><span class="line">    temp.to=<span class="number">0</span>;temp.val=<span class="number">0</span>;</span><br><span class="line">    Q.push(temp);  <span class="comment">//把原点先入队</span></span><br><span class="line">    vis[<span class="number">0</span>]=<span class="number">1</span>;dis[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//原点到原点当然是0啦  </span></span><br><span class="line">    <span class="keyword">int</span> now,a;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp=Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        now=temp.to;</span><br><span class="line">        vis[now]=<span class="number">0</span>;  <span class="comment">//出队的点vis更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Next[now].size();i++)  <span class="comment">//遍历连接的城市</span></span><br><span class="line">        &#123;</span><br><span class="line">            a=Next[now][i].to;  </span><br><span class="line">            <span class="keyword">if</span>(dis[a]&gt;(dis[now]+Next[now][i].val)) <span class="comment">//如果从原点到这个城市的距离比中间接这个城市跳转要远</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[a]=dis[now]+Next[now][i].val;</span><br><span class="line">                <span class="keyword">if</span>(vis[a]==<span class="number">0</span>) <span class="comment">//如果a不在队列里</span></span><br><span class="line">                &#123;</span><br><span class="line">                    vis[a]=<span class="number">1</span>;temp.to=a;temp.val=dis[a];</span><br><span class="line">                    Q.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ori,to;</span><br><span class="line">    node temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;ori,&amp;to,&amp;temp.val);</span><br><span class="line">        temp.to=to;</span><br><span class="line">        temp.val*=<span class="number">2</span>;</span><br><span class="line">        Next[ori].push_back(temp);</span><br><span class="line">        temp.to=ori;</span><br><span class="line">        Next[to].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;dis[i+<span class="number">1</span>]);</span><br><span class="line">        temp.to=i+<span class="number">1</span>;temp.val=dis[i+<span class="number">1</span>];</span><br><span class="line">        Next[<span class="number">0</span>].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,dis[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Buy-a-ticket&quot;&gt;&lt;a href=&quot;#Buy-a-ticket&quot; class=&quot;headerlink&quot; title=&quot;Buy a ticket&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="最短路" scheme="http://github.com/xxq1999/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论" scheme="http://github.com/xxq1999/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Cashback (DP 区间最小值)</title>
    <link href="http://github.com/xxq1999/2018/04/18/2018-04-18-Cashback-(DP-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%B0%8F%E5%80%BC)/"/>
    <id>http://github.com/xxq1999/2018/04/18/2018-04-18-Cashback-(DP-区间最小值)/</id>
    <published>2018-04-18T07:57:23.000Z</published>
    <updated>2018-04-18T08:19:57.357Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Cashback"><a href="#Cashback" class="headerlink" title="Cashback"></a>Cashback</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>输入n和c。接下来给出长度为n的数组A。你可以将数组A划分成任意个子数组，假设其中一个子数组的长度为k，那么可以减去这个子数组内前k/c个（向下取整）小的数。要使划分后数组内的元素和最小，问最小的和为多少？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>预感到是DP，但是没有什么L用……</p><p>分析一下：如果其中一个子数组的长度k&lt; c，那么这个数组就一个也不能减少；如果长度k=c，那么就刚好减少一个；如果长度在c&lt; k&lt; 2c之间，并没有任何贡献，还是只能少一个。也就是说，长度正好为c的数组是优秀的。那么长度为2c的数组呢？我们假设[0,c-1]内，最小的数字为min1，第二小的是min2，[c,2c-1]内，最小的数字为min3，那么，如果min2&lt; min3，对于划分（2个长度为c）来说，消去的数字是min1+min3，而对于划分（1个长度为2c），消去的数字就是min1+min2，显然是两个c长度的划算。如果min2&gt;=min3，对于划分成（2个长度为c）来说，消去的数字就是min1+min3，对于划分（一个长度为2c），消去的数字为min1+min3，两者是相等的。因此综上而言，将数组划分成长度为c的小数组更划算一些。</p><p>那么就用到dp了，dp[i]指 前i个数字的最小和。</p><p>对于一个数字a[i]来说，（i&gt;c）dp[i] 要么是接受前一个数字的dp再加上自己的大小，要么就是重新进入一个长度是c的数组，起始index为i-c+1，dp[i]=dp[i-c] (前i-c的最小和）+sum[i]-sum[i-c] （这一段新的长度为c的数组的总和）- min{a[i-c+1], … , a[i] }（这一段长度是c的区间里的最小值），即：</p><p><strong>dp[i] = min(dp[i-1]+a[i] , dp[i-c] + sum[i] - sum[i-c] -  min{a[i-c+1], … , a[i] } )</strong></p><p>对于区间最小值min，用一个multiset维护就好了。multiset里只放当前i为最后一个数字的c个数字。而multiset中的.begin() 会返回容器中最小的数的指针。如果去掉最前面一个放进来的数字呢？. erase( .find(a[i-c+1]))就好了。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[MAX],a[MAX]; <span class="comment">//dp[i]指前i个元素相加的最小和</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX]; <span class="comment">//前i个元素和</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;s; <span class="comment">//s用来维护长度为c的区间内的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">dp[i]=sum[i]=sum[i<span class="number">-1</span>]+a[i]; </span><br><span class="line"><span class="comment">//初始化dp值，显然长度不足c的dp值为前i个数之和，其他的默认初始值为前i个数之和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)</span><br><span class="line">        s.insert(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s.insert(a[i]);</span><br><span class="line">        dp[i]=min(dp[i<span class="number">-1</span>]+a[i],dp[i-c]+sum[i]-sum[i-c]-*s.begin());</span><br><span class="line">        <span class="comment">//前一个数加上自己的和，前一个c区间及之前的最小和加上这个新的c区间的总和，减去这个区间的最小值</span></span><br><span class="line">        s.erase(s.find(a[i-c+<span class="number">1</span>]));<span class="comment">//删去下一步到了区间外的数字</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Cashback&quot;&gt;&lt;a href=&quot;#Cashback&quot; class=&quot;headerlink&quot; title=&quot;Cashback&quot;&gt;&lt;/a&gt;Cashback&lt;/h1
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
      <category term="CodeForces" scheme="http://github.com/xxq1999/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>二数(就没啥)</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-%E4%BA%8C%E6%95%B0(%E5%B0%B1%E6%B2%A1%E5%95%A5)/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-二数(就没啥)/</id>
    <published>2018-04-15T12:22:44.000Z</published>
    <updated>2018-04-15T12:41:19.305Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="二数"><a href="#二数" class="headerlink" title="二数"></a><a href="https://www.nowcoder.com/acm/contest/91/I" target="_blank" rel="noopener">二数</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个T&lt;=100,一个n, 1&lt;=n&lt;=10^100000-1 </p><p>二数：十进制下每一位都是偶数的数</p><p>求离n最近的二数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用字符串存。</p><p>思考可以得到，对于n要么向小了变，要么向大了变。</p><p>遍历，对于遇到的第一个奇数k，</p><p>1、变小：k– </p><p>​      然后其他所有的数字都变成‘8’</p><p>2、变大：k++</p><p>​     然后其他所有数字变成’0‘</p><p>对于k==’9’的情况，直接取变小就好了，因为变小的代价肯定小于变大的代价。</p><p>然后比较谁更近的话，从高位开始一位一位的比较差值大小就好了……</p><p>输出的时候去掉前导0，就好了……</p><p>（代码依旧丑，其实很多地方可以改进，但我也懒得……）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,len,flag;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="built_in">string</span> s,sm,sb;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        len=s.size(),flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>&amp;&amp;(s[<span class="number">0</span>]==<span class="string">'1'</span>||s[<span class="number">0</span>]==<span class="string">'0'</span>)) &#123; <span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>; &#125; <span class="comment">//1 0特判一下</span></span><br><span class="line">        sm=sb=s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="comment">//向下,</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((sm[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) sm[i]--,flag=<span class="number">1</span>; <span class="comment">//第一个数变小</span></span><br><span class="line">                <span class="keyword">else</span>  <span class="comment">//后面的数变大</span></span><br><span class="line">                    <span class="keyword">if</span>(sm[i]==<span class="string">'9'</span>) sm[i]=<span class="string">'8'</span>; <span class="comment">//9变8</span></span><br><span class="line">                    <span class="keyword">else</span> sm[i]=<span class="string">'8'</span>; <span class="comment">//其他数字变8</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">                sm[i]=<span class="string">'8'</span>; <span class="comment">//其他数字变8</span></span><br><span class="line">        &#125;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="comment">//向上</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((sb[i]-<span class="string">'0'</span>)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sb[i]==<span class="string">'9'</span>&amp;&amp;flag==<span class="number">0</span>) <span class="comment">//9同sm</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sb=sm;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)  sb[i]++,flag=<span class="number">1</span>;<span class="comment">//第一个变大</span></span><br><span class="line">                <span class="keyword">else</span> sb[i]=<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) sb[i]=<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line"></span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((s[i]-sm[i])&lt;(sb[i]-s[i])) <span class="comment">//前者小</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((s[i]-sm[i])&gt;(sb[i]-s[i])) <span class="comment">//后者小</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>) s=sb;</span><br><span class="line">        <span class="keyword">else</span> s=sm;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) &#123; flag=<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]); &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;二数&quot;&gt;&lt;a href=&quot;#二数&quot; class=&quot;headerlink&quot; title=&quot;二数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>K序列（DP）</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-K%E5%BA%8F%E5%88%97%EF%BC%88DP%EF%BC%89/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-K序列（DP）/</id>
    <published>2018-04-15T12:03:55.000Z</published>
    <updated>2018-04-15T12:41:38.349Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="K序列"><a href="#K序列" class="headerlink" title="K序列"></a><a href="https://www.nowcoder.com/acm/contest/91/L" target="_blank" rel="noopener">K序列</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个数组 a，长度为 n，若某个子序列中的和为 K 的倍数，那么这个序列被称为“K 序列”。对数组 a 求出最长的子序列的长度，满足这个序列是 K 序列。 </p><p>输入一个n，k，接下来输入n个整数，表示A[1]~A[n] ,1&lt;=n&lt;=1e5,1&lt;=a[i]&lt;=1e9,1&lt;=nK&lt;=1e7。输出最长子序列的长度。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>又一道DP。</p><p>dp[i][j] : 表示前i个数中，对k取模余数为j的最长的子序列长度</p><p>dp[i][j] =max (dp[i-1][j],dp[i-1][(k-a[i]%k+j)%k]+1) </p><p>解释一下，指的是上一层（前i-1个数字）余数一样的，和上一层再加上a[i]（前i个数字）[余数]+1。</p><p>这里有个条件是要判断一下这个取模的余数是否已经存在了，不然就不能比较。</p><p>讲的不太清楚，看代码吧。</p><p>（这里用二维 vector存dp）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;dp(n+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        dp[i].resize(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%k==j) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][(j-a[i]%k+k)%k]!=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i<span class="number">-1</span>][(j-a[i]%k+k)%k]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;K序列&quot;&gt;&lt;a href=&quot;#K序列&quot; class=&quot;headerlink&quot; title=&quot;K序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcod
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DP" scheme="http://github.com/xxq1999/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>1+2=3?(奇怪的斐波那契规律题)</title>
    <link href="http://github.com/xxq1999/2018/04/15/2018-04-15-1+2=3(%E5%A5%87%E6%80%AA%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E8%A7%84%E5%BE%8B%E9%A2%98)/"/>
    <id>http://github.com/xxq1999/2018/04/15/2018-04-15-1+2=3(奇怪的斐波那契规律题)/</id>
    <published>2018-04-15T11:58:34.000Z</published>
    <updated>2018-04-15T12:46:45.926Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="1-2-3？"><a href="#1-2-3？" class="headerlink" title="1+2=3？"></a><a href="https://www.nowcoder.com/acm/contest/91/F" target="_blank" rel="noopener">1+2=3？</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个T，接下来T行，每行一个N，输出满足 x异或2x== 3x 的第N个数字。</p><p>T&lt;=100,N&lt;=1e12</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>打了表，<a href="http://oeis.org/?language=english" target="_blank" rel="noopener">整数数列百科全书</a>中找到符合规律的数列，观察二进制形式后发现：</p><p><img src="\mdpicture\FB.jpg" alt="规律"></p><p>斐波那契数列：</p><p>1 2 3 5 8 13 21 34 55 ……</p><p>题中若N=60，则60= 55 + 5 （第9项+第4项）</p><p>则第60个满足条件的数为：1(9)00001(4)000 = 264 (4、9号位数为1，其他都是0)</p><p>由于1e12小于斐波那契的第59项，故开一个59大的数组，里面存斐波那契数，然后对于每一个N寻找最少的组成它的斐波那契数，找到他是第x项，那么ans+2^x即可。</p><p>（问题是我的代码怎么这么丑= =）</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;fei; <span class="comment">//算斐波那契 1 2 3 5这样的</span></span><br><span class="line">    fei.push_back(<span class="number">1</span>);fei.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(fei[fei.size()<span class="number">-1</span>]&lt;(<span class="number">1e12</span>+<span class="number">5</span>)) fei.push_back(fei[fei.size()<span class="number">-1</span>]+fei[fei.size()<span class="number">-2</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> n,temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">        temp=n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> weishu[<span class="number">100</span>],x=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)</span><br><span class="line">            weishu[i]=x,x*=<span class="number">2</span>; <span class="comment">//计算2的i次</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">57</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=fei[i]) <span class="comment">//找能组成他的斐波那契数，直接算</span></span><br><span class="line">                temp-=fei[i],ans+=weishu[i];</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;1-2-3？&quot;&gt;&lt;a href=&quot;#1-2-3？&quot; class=&quot;headerlink&quot; title=&quot;1+2=3？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="http://github.com/xxq1999/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
      <category term="规律" scheme="http://github.com/xxq1999/tags/%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>归途</title>
    <link href="http://github.com/xxq1999/2018/04/05/%E5%BD%92%E9%80%94/"/>
    <id>http://github.com/xxq1999/2018/04/05/归途/</id>
    <published>2018-04-05T07:20:41.640Z</published>
    <updated>2018-04-05T07:57:54.405Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="\mdpicture\拉杆箱会飞吗.jpg" alt="如果拉杆箱会飞"></p><p>回家，带着我的拉杆箱。</p><p>拉杆箱好沉啊，下着雨，要撑伞。红色的卫衣，薄荷绿的伞。</p><p><br></p><h2 id="城隍百味"><a href="#城隍百味" class="headerlink" title="城隍百味"></a>城隍百味</h2><p><img src="\mdpicture\城隍百味.jpg" alt="城隍庙地铁站"></p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>和小可爱在一起。</p><p>“我要吃三色杯！”</p><p>“上口爱！”</p><p>“给我尝一口！”</p><p>“好冷呐哥！”</p><p>“我要吃炸鱿鱼！”</p><p>“好脆呀！”</p><p>“别扯呀别扯！”</p><p>“我没我咬不动！”</p><p>“看你满嘴！”</p><p>“哼！”</p><p>“老板来三根肉串！”</p><p>“还吃……”</p><p>“臭豆腐要吗！”</p><p>“……要！”</p><p>“来一口！”</p><p>“哇呜是香菜！！TOT “</p><p>“很香！”</p><p>“哦这个味道！”</p><p>“这才是真正的臭豆腐！”</p><p>“霉的很完美！”</p><p>“……”</p><p><br></p><p><img src="\mdpicture\臭豆腐.jpg" alt="城隍庙臭豆腐"></p><p><br></p><h3 id="遇"><a href="#遇" class="headerlink" title="遇"></a>遇</h3><p>老地方，又遇见了一个乞讨的老爷爷，但是好像没有人愿意给他钱。</p><p>以前也遇到过一次，等饮料的时候，他伸出破烂的碗，看着我，上下颠一颠，几块钱硬币在碗里面当啷响。</p><p>我犹豫着响掏出一点碎钱，被小可爱制止了。</p><p>貌似有些残酷的冲老爷爷摆摆手，然后拿了饮料转身离开，给他一个背影。</p><p>后来我们往下走，在风很大的路口遇见了一个卖报纸的老婆婆，忘记了多少钱一份，两块还是三块？只记得小可爱二话不说就买了一份。报纸还是过期的，早就不知道哪儿去了。</p><p>记得他当时这样说：</p><p>“如果我们刚才给了那个乞丐钱，那对这个辛苦卖报的老婆婆是不是不公平？”</p><p><br></p><h2 id="归途"><a href="#归途" class="headerlink" title="归途"></a>归途</h2><blockquote><p>不断更新着的一切</p><p>高楼 大厦</p><p>人</p></blockquote><p><img src="\mdpicture\高樓.jpg" alt="萬達新樓"></p><p><br></p><blockquote><p>清明时节雨 纷纷</p></blockquote><p><img src="\mdpicture\我.jpg" alt="潮湿的"></p><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;\mdpicture\拉杆箱会飞吗.jpg&quot; alt=&quot;如果拉杆箱会飞&quot;&gt;&lt;/p&gt;
&lt;p&gt;回家，带着我的拉杆箱。&lt;/p&gt;
&lt;p&gt;拉杆箱好沉啊，下着雨，要撑
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Missing Leslie</title>
    <link href="http://github.com/xxq1999/2018/04/01/2018-04-01-Missing-Leslie/"/>
    <id>http://github.com/xxq1999/2018/04/01/2018-04-01-Missing-Leslie/</id>
    <published>2018-04-01T14:40:00.000Z</published>
    <updated>2018-04-02T05:08:20.276Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="\mdpicture\Leslie1.jpg" alt="春天该很好，你若尚在场"></p><blockquote><p>春天该很好，你若尚在场。</p></blockquote><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;\mdpicture\Leslie1.jpg&quot; alt=&quot;春天该很好，你若尚在场&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;春天该很好，你若尚在场。&lt;/
      
    
    </summary>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>CF 957C Three-level Laser (二分)</title>
    <link href="http://github.com/xxq1999/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(%E4%BA%8C%E5%88%86)/"/>
    <id>http://github.com/xxq1999/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(二分)/</id>
    <published>2018-04-01T14:24:00.000Z</published>
    <updated>2018-04-01T14:25:13.747Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Three-level-Laser"><a href="#Three-level-Laser" class="headerlink" title="Three-level Laser"></a><a href="http://codeforces.com/contest/957/problem/C" target="_blank" rel="noopener">Three-level Laser</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>输入一个n，m，n代表接下来有n个数字（从小到大），</p><p>接下来从n个数字中选3个数字i，j，k（i&lt;j&lt;k），</p><p>使得k-j/k-i 最大，且（k-i）&lt;=m。(n&lt;1e5)</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开头直接写，j=1开始遍历，要让值最大，i=j-1,（必定），k为可允许内最大的值。</p><p>用for找k，会T，于是改用二分，输出用.15f（精度限制，double到.6）。</p><h2 id="看！代码"><a href="#看！代码" class="headerlink" title="看！代码"></a>看！代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,U;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;U);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1=a[i],t2=a[i+<span class="number">1</span>],up=U+t1;</span><br><span class="line">        <span class="keyword">int</span> k=upper_bound(a+<span class="number">1</span>,a+<span class="number">1</span>+n,up)-a<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i+<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        res=max(res,(a[k]-t2*<span class="number">1.0</span>)/(a[k]-t1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.15f\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Three-level-Laser&quot;&gt;&lt;a href=&quot;#Three-level-Laser&quot; class=&quot;headerlink&quot; title=&quot;Three-le
      
    
    </summary>
    
      <category term="算法" scheme="http://github.com/xxq1999/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CodeForeces" scheme="http://github.com/xxq1999/tags/CodeForeces/"/>
    
      <category term="二分" scheme="http://github.com/xxq1999/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Yilia</title>
    <link href="http://github.com/xxq1999/2018/03/31/Change/"/>
    <id>http://github.com/xxq1999/2018/03/31/Change/</id>
    <published>2018-03-31T13:34:56.000Z</published>
    <updated>2018-04-01T14:47:52.294Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><img src="\mdpicture\18033102.jpg" alt="回老家的时候，在奶奶家旁边的荒地前拍的，一轮小小的月亮， 好像一个小小的我"></p><p><br></p><p>Hexo 找如何搭建相册的时候，发现的一个主题，yilia，简洁，充满魅力。</p><p>创作这个主题的作者Litten是鹅厂的一名前端。<br>好奇心的驱使，让我开始翻看着他的随笔，生活中的点点滴滴，却感叹于他的心思和文笔的细腻。</p><p>他写凛冬将至，说人的老去，很多是因为忘记了年轻。<br>他写生病，说意外的中断是多么可爱，欢乐可放歌，悲伤可饮酒。<br>要是心情郁闷的话，就用手托腮，手臂会因为帮上忙而开心。<br>…</p><p>以及各种稀奇古怪的专业文章，<br>讲反爬虫的，讲Unicode，<br>…</p><p>他的相册里的照片，<br>我实在是喜欢。<br>非常的生活，和触动。</p><p>我想了想，换掉了我执念的透明色主题。<br>毕竟看多了还是觉得花里胡哨。<br>博客嘛，<br>回到内容上来，还是更好。<br>我想谢谢这位陌生的，<br>不知道怎么称呼，<br>在这些天茫然的夜晚，我又重新感受到了，<br>生活该是什么样，就是什么样。</p><p><br></p><blockquote><p>事情无非是let，变化历历；或者是const，永恒安息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;img src=&quot;\mdpicture\18033102.jpg&quot; alt=&quot;回老家的时候，在奶奶家旁边的荒地前拍的，一轮小小的月亮， 好像一个小小的我&quot;&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>文章置顶</title>
    <link href="http://github.com/xxq1999/2018/03/31/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/"/>
    <id>http://github.com/xxq1999/2018/03/31/文章置顶/</id>
    <published>2018-03-31T10:44:59.291Z</published>
    <updated>2018-03-31T12:16:48.944Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>1、Hexo bash ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p>2、在需要置顶的文章的<code>Front-matter</code>中加上：<code>top: true</code></p><p>完毕。</p><p>3、置顶的文章添加置顶标志</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;1、Hexo bash ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Web Dairy" scheme="http://github.com/xxq1999/categories/Web-Dairy/"/>
    
    
      <category term="网站优化" scheme="http://github.com/xxq1999/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>聚餐</title>
    <link href="http://github.com/xxq1999/2018/03/31/%E8%81%9A%E9%A4%90/"/>
    <id>http://github.com/xxq1999/2018/03/31/聚餐/</id>
    <published>2018-03-30T16:29:04.858Z</published>
    <updated>2018-03-31T10:36:44.070Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" Please give the password. "/> <label for="pass"> Please give the password. </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      NEED PASSWORD./文章已加密
    
    </summary>
    
      <category term="Life &amp; Story" scheme="http://github.com/xxq1999/categories/Life-Story/"/>
    
    
      <category term="随想" scheme="http://github.com/xxq1999/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>

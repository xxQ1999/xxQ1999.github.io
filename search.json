[{"title":"Fruit Ninja(头一次接触的随机化算法)","url":"/2018/08/05/Fruit-Ninja(头一次接触的随机化算法)/","content":"\n#[Fruit Ninja](https://www.nowcoder.com/acm/contest/163/A) \n\n##题意\n\n屏幕上有n个水果，你可以画一条直线切掉其中一些，给你N和x，M/N>=x，M为切掉的水果数，x为0~1的纯小数，指的是切掉的水果比吧。问你是否有满足这个式子的这样一条直线，有输出yes，没有输出no。\n\nN<=1e4 , x小数点后一位（0,1）。\n\n## 思路\n\n随机化，巧妙巧妙，厉害厉害，佩服佩服，不过要分析一波随机的数量。由于m是切掉的水果数，n是总水果数，x是两者之比，也就是说在这条直线上的水果数是m个，意味着随机选一个水果，刚好在直线上的概率是x，因此随机选两个刚好组成这条直线的概率是x^2，而x∈[0.1,0.9]，因此概率最小为0.01，也就是说取100次就能取到那条我们需要的直线，反之如果没有满足的，就说明“NO”。为了保险起见，我们将随机范围设置为200。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct node{\n    ll x,y;\n};\nnode point[10010];\nint main()\n{\n    int t;\n    srand((unsigned)time(NULL));\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        double x;\n        scanf(\"%d%lf\",&n,&x);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lld%lld\",&point[i].x,&point[i].y);\n        }\n        int flag=0;\n        for(int i=0;i<200;i++)\n        {\n            int a=rand()%n;\n            int b=rand()%n;\n            while(a==b)\n                a=rand()%n;\n\n            int cnt=0;\n            for(int j=0;j<n;j++)\n                if((point[a].x-point[b].x)*(point[a].y-point[j].y)==(point[a].y-point[b].y)*(point[a].x-point[j].x))\n                    cnt++;\n\n            if(cnt>=n*x)\n            {\n                flag=1;break;\n            }\n        }\n        if(flag)    puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n```\n\n","tags":["随机化算法"],"categories":["算法"]},{"title":"HDU1085 Holding Bin-Laden Captive!(母函数)","url":"/2018/08/03/HDU1085-Holding-Bin-Laden-Captive!(母函数)/","content":"\n# [Holding Bin-Laden Captive!](http://acm.hdu.edu.cn/showproblem.php?pid=1085) \n\n## 题意\n\n有面值为1、2、5的三种硬币，给你三个数字分别表示拥有的硬币数量，问最小的不能组成的面值为多少?\n\n1<=n<=1000\n\n## 思路\n\njust母函数，x上的指数代表v[i]*num，比如面值为2的硬币有3枚，那么就可以组成这样的多项式：\n\n \n$$\n1+x^2+x^4+x^6\n$$\n然后套模板就行。\n\n## 看！代码\n\n\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int a1,a2,a3;\n    int v[3]={1,2,5};\n    int n[3]={0,0,0};\n    int n2[3];\n\n    while(~scanf(\"%d%d%d\",&n2[0],&n2[1],&n2[2]))\n    {\n        if(n2[0]==0&&n2[1]==0&&n2[2]==0) break;\n        int a[10000]={0},b[10000];\n        a[0]=1;\n\n        int last=0;\n        int P=n2[0]+n2[1]*2+n2[2]*5;\n        int K=3;\n        for (int i=0;i<K;i++)\n        {\n            int last2=min(last+n2[i]*v[i],P);//计算下一次的last\n            memset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n            for (int j=n[i];j<=n2[i]&&j*v[i]<=last2;j++)//这里是last2\n                for (int k=0;k<=last&&k+j*v[i]<=last2;k++)//这里一个是last，一个是last2\n                    b[k+j*v[i]]+=a[k];\n            memcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n            last=last2;//更新last\n        }\n        int flag=0;\n        for(int i=0;i<=P;i++)\n        {\n            if(a[i]==0)\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(!flag) printf(\"%d\\n\",P+1);\n        else printf(\"%d\\n\",i);\n    }\n    return 0;\n}\n```\n\n","tags":["母函数"],"categories":["算法"]},{"title":"伯努利求自然数幂和","url":"/2018/08/03/伯努利求自然数幂和/","content":"\nhttps://blog.csdn.net/acdreamers/article/details/38929067 \n\n下面两个代码都是可以作为模板n<=1e18\n\nhttps://blog.csdn.net/acdreamers/article/details/38929067\n\n```c++\n#include <iostream>\n#include <string.h>\n#include <stdio.h>\n \nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1000000007;\nconst int N = 2005;\n \nLL C[N][N];\nLL B[N],Inv[N];\nLL Tmp[N];\nLL n;\n \nvoid Init()\n{\n    //预处理组合数\n    for(int i=0; i<N; i++)\n    {\n        C[i][0] = C[i][i] = 1;\n        if(i == 0) continue;\n        for(int j=1; j<i; j++)\n            C[i][j] = (C[i-1][j] % MOD + C[i-1][j-1] % MOD) % MOD;\n    }\n    //预处理逆元\n    Inv[1] = 1;\n    for(int i=2; i<N; i++)\n        Inv[i] = (MOD - MOD / i) * Inv[MOD % i] % MOD;\n    //预处理伯努利数\n    B[0] = 1;\n    for(int i=1; i<N; i++)\n    {\n        LL ans = 0;\n        if(i == N - 1) break;\n        for(int j=0; j<i; j++)\n        {\n            ans += C[i+1][j] * B[j];\n            ans %= MOD;\n        }\n        ans *= -Inv[i+1];\n        ans = (ans % MOD + MOD) % MOD;\n        B[i] = ans;\n    }\n}\n \nLL Work(int k)\n{\n    LL ans = Inv[k+1];\n    LL sum = 0;\n    for(int i=1; i<=k+1; i++)\n    {\n        sum += C[k+1][i] * Tmp[i] % MOD * B[k+1-i] % MOD;\n        sum %= MOD;\n    }\n    ans *= sum;\n    ans %= MOD;\n    return ans;\n}\n \nint main()\n{\n    int T;\n    Init();\n    scanf(\"%d\", &T);\n    while(T--)\n    {\n        int k;\n        scanf(\"%I64d %d\", &n, &k);\n        n %= MOD;\n        Tmp[0] = 1;\n        for(int i=1; i<N; i++)\n            Tmp[i] = Tmp[i-1] * (n + 1) % MOD;\n        printf(\"%I64d\\n\", Work(k));\n    }\n    return 0;\n}\n```\n\n\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 1e9+5;\nconst int MAXN = 2e3+5;\nconst LL MOD = 1e9+7;\nconst double eps = 1e-7;\nconst double PI = acos(-1);\nusing namespace std;\n\nLL c[MAXN][MAXN], Inv[MAXN], B[MAXN];\nvoid Exgcd(LL a, LL b, LL &x, LL &y)\n{\n    if(b == 0)\n    {\n        x = 1;\n        y = 0;\n        return ;\n    }\n    LL x1, y1;\n    Exgcd(b, a%b, x1, y1);\n    x = y1;\n    y = x1 - (a/b)*y1;\n}\n //预处理组合数\nvoid Get_Fac()\n{\n    for(int i=0; i<MAXN; i++)\n    {\n        c[i][0] = 1;\n        c[i][i] = 1;\n    }\n    for(int i=1; i<MAXN; i++)\n        for(int j=1; j<=i; j++)\n            c[i][j] = (c[i-1][j]+c[i-1][j-1])%MOD;\n}\n //预处理逆元\nvoid Get_Inv()\n{\n    for(int i=1; i<MAXN; i++)\n    {\n        LL x, y;\n        Exgcd(i, MOD, x, y);\n        x = (x%MOD+MOD)%MOD;\n        Inv[i] = x;\n    }\n}\nLL quick_MOD(LL a, LL b)\n{\n    LL ans = 1;\n    while(b)\n    {\n        if(b & 1)\n            ans = (ans*a)%MOD;\n        b>>=1;\n        a = (a*a)%MOD;\n    }\n    return ans;\n}\nvoid Get_Bonuli()\n{\n    B[0] = 1;\n    for(int i=1; i<MAXN-1; i++)\n    {\n        LL tmp = 0;\n        for(int j=0; j<i; j++)\n            tmp = (tmp+c[i+1][j]*B[j])%MOD;\n        B[i] = tmp;\n        B[i] = B[i]*(-Inv[i+1]);\n        B[i] = (B[i]%MOD+MOD)%MOD;\n    }\n}\nvoid Init()\n{\n    Get_Fac();\n    Get_Inv();\n    Get_Bonuli();\n}\nint main()\n{\n    Init();\n    int T, k;\n    LL n;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        scanf(\"%lld%d\",&n,&k);\n        n++;\n        n %= MOD;\n        LL ans = 0;\n        for(int i=1; i<=k+1; i++)\n        {\n            ans = (ans+((c[k+1][i]*B[k+1-i])%MOD)*quick_MOD(n,(LL)i))%MOD;\n            ans = (ans%MOD+MOD)%MOD;\n        }\n        ans = ans*Inv[k+1];\n        ans = (ans%MOD+MOD)%MOD;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n"},{"title":"乘法逆元模板","url":"/2018/08/03/乘法逆元模板/","content":"\n1. 扩展欧几里得\n\n```c++\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n \nll mod_inverse(ll a,ll n)//乘法逆元，a与n必须互素\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\n```\n\n2. 费马小定理，快速幂\n\n```c++\nint find(int x)  //x与mod互素，且mod为素数\n{  \n    int k=mod-2,ans=1;  \n    while(k)  \n    {  \n        if (k&1) ans=(ll)ans*x%mod;  \n        x=(ll)x*x%mod;  \n        k>>=1;  \n    }  \n    return ans;  \n}  \n//x在%mod下的逆元\n\n/*已知p是质数且gcd(a, p) = 1，则 ap-1 ≡ 1 (mod p),  所以 a*ap-2 ≡ 1 (mod p)。\na^(p-2)就是a的逆元了*/\n\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"高斯消元模板","url":"/2018/08/03/高斯消元模板/","content":"\n### 简单版本\n\n```c++\n（1）有解的方程组：\n#define N 205\nusing namespace std;\nconst double eps=1e-8;\nint n;\ndouble a[N][N],del;\nbool gauss(){\n    for(int i=1;i<=n;i++){\n        int k=i;\n        for(int j=i+1;j<=n;j++)if(fabs(a[j][i])>fabs(a[k][i]))k=j;\n        if(fabs(del=a[k][i])<eps)return 0;\n        for(int j=i;j<=n+1;j++)swap(a[i][j],a[k][j]);\n        for(int j=i;j<=n+1;j++)a[i][j]/=del;\n        for(k=1;k<=n;k++)if(k!=i){\n            del=a[k][i];\n            for(int j=i;j<=n+1;j++)a[k][j]-=a[i][j]*del;\n        }\n    }\n    return 1;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n+1;j++)scanf(\"%lf\",&a[i][j]);\n    bool flag=gauss();\n    if(!flag)puts(\"No Solution\");\n    else for(int i=1;i<=n;i++)printf(\"%.2lf\\n\",a[i][n+1]);\n    return 0;\n}\n```\n\n### kuangbin的模板\n\n```c++\n//来自kuangbin大神的模板\n#include<stdio.h>\n#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<math.h>\nusing namespace std;\n\nconst int MAXN=50;\n\nint a[MAXN][MAXN];//增广矩阵\nint x[MAXN];//解集\nbool free_x[MAXN];//标记是否是不确定的变元\n\n/*\nvoid Debug(void)\n{\n    int i, j;\n    for (i = 0; i < equ; i++)\n    {\n        for (j = 0; j < var + 1; j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n*/\n\n\ninline int gcd(int a,int b)\n{\n    int t;\n    while(b!=0)\n    {\n        t=b;\n        b=a%b;\n        a=t;\n    }\n    return a;\n}\ninline int lcm(int a,int b)\n{\n    return a/gcd(a,b)*b;//先除后乘防溢出\n}\n\n// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，\n//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)\n//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.\nint Gauss(int equ,int var)\n{\n    int i,j,k;\n    int max_r;// 当前这列绝对值最大的行.\n    int col;//当前处理的列\n    int ta,tb;\n    int LCM;\n    int temp;\n    int free_x_num;\n    int free_index;\n\n    for(int i=0;i<=var;i++)\n    {\n        x[i]=0;\n        free_x[i]=true;\n    }\n\n    //转换为阶梯阵.\n    col=0; // 当前处理的列\n    for(k = 0;k < equ && col < var;k++,col++)\n    {// 枚举当前处理的行.\n// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)\n        max_r=k;\n        for(i=k+1;i<equ;i++)\n        {\n            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;\n        }\n        if(max_r!=k)\n        {// 与第k行交换.\n            for(j=k;j<var+1;j++) swap(a[k][j],a[max_r][j]);\n        }\n        if(a[k][col]==0)\n        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.\n            k--;\n            continue;\n        }\n        for(i=k+1;i<equ;i++)\n        {// 枚举要删去的行.\n            if(a[i][col]!=0)\n            {\n                LCM = lcm(abs(a[i][col]),abs(a[k][col]));\n                ta = LCM/abs(a[i][col]);\n                tb = LCM/abs(a[k][col]);\n                if(a[i][col]*a[k][col]<0)tb=-tb;//异号的情况是相加\n                for(j=col;j<var+1;j++)\n                {\n                    a[i][j] = a[i][j]*ta-a[k][j]*tb;\n                }\n            }\n        }\n    }\n\n  //  Debug();\n\n    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).\n    for (i = k; i < equ; i++)\n    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.\n        if (a[i][col] != 0) return -1;\n    }\n    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.\n    // 且出现的行数即为自由变元的个数.\n    if (k < var)\n    {\n        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.\n        for (i = k - 1; i >= 0; i--)\n        {\n            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.\n            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.\n            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && free_x[j]) free_x_num++, free_index = j;\n            }\n            if (free_x_num > 1) continue; // 无法求解出确定的变元.\n            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.\n            temp = a[i][var];\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];\n            }\n            x[free_index] = temp / a[i][free_index]; // 求出该变元.\n            free_x[free_index] = 0; // 该变元是确定的.\n        }\n        return var - k; // 自由变元有var - k个.\n    }\n    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.\n    // 计算出Xn-1, Xn-2 ... X0.\n    for (i = var - 1; i >= 0; i--)\n    {\n        temp = a[i][var];\n        for (j = i + 1; j < var; j++)\n        {\n            if (a[i][j] != 0) temp -= a[i][j] * x[j];\n        }\n        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.\n        x[i] = temp / a[i][i];\n    }\n    return 0;\n}\nint main(void)\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    int i, j;\n    int equ,var;\n    while (scanf(\"%d %d\", &equ, &var) != EOF)\n    {\n        memset(a, 0, sizeof(a));\n        for (i = 0; i < equ; i++)\n        {\n            for (j = 0; j < var + 1; j++)\n            {\n                scanf(\"%d\", &a[i][j]);\n            }\n        }\n//        Debug();\n        int free_num = Gauss(equ,var);\n        if (free_num == -1) printf(\"无解!\\n\");\n   else if (free_num == -2) printf(\"有浮点数解，无整数解!\\n\");\n        else if (free_num > 0)\n        {\n            printf(\"无穷多解! 自由变元个数为%d\\n\", free_num);\n            for (i = 0; i < var; i++)\n            {\n                if (free_x[i]) printf(\"x%d 是不确定的\\n\", i + 1);\n                else printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        else\n        {\n            for (i = 0; i < var; i++)\n            {\n                printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"欧拉","url":"/2018/08/02/欧拉函数计算φ(n)/","content":"\n<h2>φ(n)</h2>\n\n\n\n欧拉函数，指的就是小于n与n互质的数的个数。\n\n```c++\nint phi(int n) {\n    int ans = n;\n    for (int i = 2; i <= sqrt(n); ++i) if (n % i == 0) {\n        ans = ans / i * (i-1);\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) ans = ans / n * (n-1);\n    return ans;\n}\n```\n\n以下的代码以 O(NlogN)复杂度求出 [2,N] 中每个数的欧拉函数。\n\n```c++\nvoid euler(int n) {\n    for (int i = 2; i <= n; ++i) phi[i] = i;\n    for (int i = 2; i <= n; ++i) if (phi[i] == i)\n        for (int j = i; j <= n; j += i)\n            phi[j] = phi[j] / i * (i-1);\n}\n```\n\n下面利用线性筛法的思想在 O(N)的时间内快速递推出 [2,N] 中每个数的欧拉函数。\n\n```c++\ntypedef long long ll;\nconst int maxn = 10000000 + 5;\nint phi[maxn], pri[1000005], n, tot;\nbool mark[maxn];\nll ans, sum[maxn];\nvoid getphi() {\n    phi[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        if (!mark[i]) { phi[i] = i - 1; pri[++tot] = i; }\n        for (int j = 1; j <= tot; j++) {\n            int x = pri[j];\n            if (i*x>n)break;\n            mark[i*x] = 1;\n            if (i%x == 0) { phi[i*x] = phi[i] * x; break; }\n            else phi[i*x] = phi[i] * phi[x];\n        }\n    }\n}\n```\n<h2>降幂</h2>\n\n<h3>公式</h3>\n$$\na^x\\equiv a^{x \\ mod \\ \\phi(p) + \\phi(p)} (mod \\ p)\\  (x \\geq p)\n$$\n\n### 快速幂\n\n```c++\nll qmod(ll a,ll n,ll mod)\n{\n    ll b=a%mod,ans=1;\n    while(n)\n    {\n        if(n&1)\n        {\n            ans=(ans*b)%mod;\n        }\n        b=b*b%mod;\n        n>>=1;\n    }\n    return ans;\n}\n```\n\n\n\n### 模板\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\ntypedef __int64 ll;\nchar b[1000006];\n\nll ouler(ll n)\n{\n    ll ans=n,a=n;\n    for(ll i=2;i*i<=a;i++){\n        if(a%i==0){\n            ans-=ans/i;\n            while(a%i==0){\n                a/=i;\n            }\n        }\n    }\n    if(a>1){\n        ans-=ans/a;\n    }\n    return ans;\n}\n\nll qmod(ll a,ll n,ll mod)\n{\n    ll tmp=a%mod,ans=1;\n    while(n){\n        if(n&1){\n            ans=(ans*tmp)%mod;\n        }\n        tmp=tmp*tmp%mod;\n        n>>=1;\n    }\n    return ans;\n}\n//利用公式\nll solve(ll a,char *b,ll c)\n{\n    int PHI=ouler(c);\n    ll res=0;\n    for(int i=0;b[i];i++)\n    {\n        res=(res*10+b[i]-'0');\n        if(res>c)break;\n    }\n    if(res<=PHI)\n    {\n        return qmod(a,res,c);\n    }\n    else\n    {\n        res=0;\n        for(int i=0;b[i];i++)\n        {\n            res=(res*10+b[i]-'0')%PHI;\n        }\n        return qmod(a,res+PHI,c);\n    }\n}\n\nint main()\n{\n    ll a,c,i;\n    ll n=0,tmp;\n    while(scanf(\"%I64d%s%I64d\",&a,b,&c)!=EOF)\n    {\n        printf(\"%I64d\\n\",solve(a,b,c));\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Let Sudoku Rotate (dfs+剪枝)","url":"/2018/08/02/Let-Sudoku-Rotate-(dfs+剪枝)/","content":"\n# [Let Sudoku Rotate](http://acm.hdu.edu.cn/showproblem.php?pid=6341) \n\n## 题意\n\n数独，有一个16*16的数独 数独内的数字从0~E，一开始数独是完美的，可是有个人逆时针旋转了数独中的某几块（4x4），导致数独不完美了，给你这个旋转后的数独，要求还原他至少要再旋转几步？\n\n\n\n## 思路\n\ndfs+剪枝。\n\n写出下列几个操作：\n\n1. 顺时针旋转4*4的方块；\n2. 判断每行的总和是否都为120；\n3. 判断每行和每列的元素是否都不重复；\n4. dfs，由于一行块有4个分块，因此四重循环，同一个x分别对应y的起始：0，4，8，12，循环+1表示旋转次数+1，如果在2、3的判断中都满足这写要求，说明可以进行下一个x+4（起始行）块的旋转操作dfs，step+本次旋转的操作（i，j，k，l四重循环），要是不满足还是要继续。当x==16或者是step比当前已知的最小ans要大的时候都可以return。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst int INF = 0x3f3f3f3f;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nchar m[20][20];\nchar cop[4][4];\nint ans=64;\nvoid print()\n{\n    printf(\"\\n\");\n    for(int i=0;i<16;i++,printf(\"\\n\"))\n        for(int j=0;j<16;j++)\n            printf(\"%c\",m[i][j]);\n    printf(\"\\n\");\n}\nint rol(int x,int y)\n{\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            cop[i][j]=m[x+3-j][y+i];\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            m[i+x][j+y]=cop[i][j];\n}\nbool sum(int x)\n{\n    for(int j=x;j<x+4;j++)\n    {\n        int temp=0;\n        for(int i=0;i<16;i++)\n        {\n            temp=temp+((m[x][i]>='0'&&m[x][i]<='9')?(m[x][i]-'0'):(m[x][i]-'A'+10));\n        }\n        if(temp!=120) return false;\n    }\n    return true;\n}\nbool multi(int x)\n{\n    int vis[16]={0};\n    for(int j=x;j<x+4;j++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<16;i++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n\n    for(int i=0;i<16;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int j=0;j<=x+3;j++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n    return true;\n}\nvoid dfs(int x,int step)\n{\n    if(step>ans) return;\n    if(x==16)\n    {\n        ans=min(ans,step);return;\n    }\n    for(int i=0;i<4;i++,rol(x,0))\n    for(int j=0;j<4;j++,rol(x,4))\n    for(int k=0;k<4;k++,rol(x,8))\n    for(int l=0;l<4;l++,rol(x,12))\n    {\n        if(!(sum(x)&&multi(x))) continue;\n        dfs(x+4,step+i+j+k+l);\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        getchar();\n        for(int i=0;i<16;i++)\n            scanf(\"%s\",m[i]);\n        ans=64;\n        dfs(0,0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["dfs"],"categories":["算法"]},{"title":"Harvest of Apples (莫队)","url":"/2018/08/02/Harvest-of-Apples-(莫队)/","content":"\n# [Harvest of Apples](http://acm.hdu.edu.cn/showproblem.php?pid=6333) \n\n## 题意\n\n题意是从n个苹果里面选取最多m个苹果的方案数量。m、n、t<=1e5\n\n##思路\n\n莫队分块+组合预处理，原来莫队中的区间[l,r]在这里用n、m代替了。\n\n接下来是推公式部分：\n\nS(n,m)表示$\\sum_{i=1}^n\\sum_{j=1}^mC_i^j$\n\n我们可以得出$S(n,m)=S(n,m-1)+C_n^m$ ,-------①\n\n又因为有$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$（组合数学的一个基本公式），因此又可以推出：$S(n,m)=S(n-1,m)+S(n-1,m-1)=2S(n-1,m)-C_{n-1}^m$--------②\n\n有了①②两个式子，我们就可以得到S(n,m)和S(n-1,m)、S(n+1,m)、S(n,m-1)、S(n,m+1)之间的关系，先预处理出n！和相应的需要的逆元，然后把输入的查询分块，按照代码中所示的“套路”排序法，排一排，然后对于每个n，m开始处理，分四种情况这样。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nll multi[N];\nll devide[N];\nll ans[N];\nll pos[N];\nll er;\nint D=(int)sqrt(1.0*N);\nstruct node{\n    int n,m;\n    int id;\n    bool operator <(const node& p) const{\n        if(pos[n]==pos[p.n]) return m<p.m;\n        return n<p.n;                           //N大的排前面\n    }\n};\nnode qujian[N];\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll n)//乘法逆元,n取模\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\nvoid init(int n)\n{\n    multi[0]=1;\n    multi[1]=1;\n    for(int i=2;i<=n;i++)\n        multi[i]=multi[i-1]*i%MOD;\n    devide[n]=mod_inverse(multi[n],MOD);\n    for(int i=n-1;i>=0;i--)\n        devide[i]=devide[i+1]*(i+1)%MOD;\n}\nll cal(int n,int m)\n{\n    return ((multi[n]*devide[m])%MOD*devide[n-m])%MOD;\n}\nvoid operation1(int n,int m,ll &res)\n{\n    res=((2ll*res)%MOD-cal(n,m)%MOD+MOD)%MOD;\n}\nvoid operation2(int n,int m,ll &res)\n{\n    res=(res+cal(n-1,m))%MOD*er%MOD;\n}\nvoid operation3(int n,int m,ll &res)\n{\n    res=(res+cal(n,m+1))%MOD;\n}\nvoid operation4(int n,int m,ll &res)\n{\n    res=(res-cal(n,m)+MOD)%MOD;\n}\nint main()\n{\n    init(100000);\n    int t;\n    int n,m;\n    er=mod_inverse(2ll,MOD);\n    scanf(\"%d\",&t);\n    for(int i=1;i<=t;i++)\n    {\n        scanf(\"%d%d\",&qujian[i].n,&qujian[i].m);\n        qujian[i].id=i;\n        pos[i]=i/D;\n    }\n    sort(qujian+1,qujian+t+1);\n    int curl,curr;\n    curl=curr=1;\n    ll res=2;\n    for(int j=1;j<=t;j++)\n    {\n        while(curl<qujian[j].n) operation1(curl++,curr,res);\n        while(curr<qujian[j].m) operation3(curl,curr++,res);\n        while(curl>qujian[j].n) operation2(curl--,curr,res);\n        while(curr>qujian[j].m) operation4(curl,curr--,res);\n        ans[qujian[j].id]=res;\n    }\n    for(int i=1;i<=t;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\n","tags":["莫队"],"categories":["算法"]},{"title":"Ascending Rating（思维+单调队列）","url":"/2018/08/02/Ascending-Rating（思维+单调队列）/","content":"\n# [ Ascending Rating](http://acm.hdu.edu.cn/showproblem.php?pid=6319)\n\n## 题意\n\n 输入n,m,k,p,q,r,MOD,表示一个长度为n的数列，给你前k个数字，（后面的要根据递推式自己写），然后m表示一个[l,l+m]的区间，从l=1开始，在这个区间中有两个值，一个是MAX，一个是CNT，起始都为0，从区间的第一个数开始扫，如果扫到的数字比MAX大，让MAX=ai，并且CNT++。求的是$A =\\sum_{i=1}^{n-m+1}{MAX_i 异或i}$ , $B=\\sum_{i=1}^{n-m+1}{CNT_i 异或i}$\n\n思路是用一个单调队列从最后一个区间往前倒着维护，如果队列为空，则直接放入ai，若ai>=队首元素，则将队列中的元素全部弹出，同时将ai放入，若ai小于队首元素，则将队尾中小于ai的元素弹出，将ai放入队尾中，每一个区间的cnt值即为队列中元素的个数，而MAX值则为队首元素。如果队首元素的位置不在下一个区间范围内，则弹出。注意STL的双端队列会被卡，这里可以用数组直接模拟。（可以补一个正向写的，但是我WA到死，主要就是用单调栈来维护每一个数字右边的第一个比他大的位置，最后一个栈里的数的stack设为n+1，然后从右到左，dp[n-1]=1，dp[i]=dp[stack[i]]+1，………然后单调队列维护区间最大值）\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nlong long a[10000010];\nlong long que[20000010];\nint main()\n{\n    int t,n,m,k,p,q,r,MOD;\n    int size,front,rear;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        size=0;\n        front=rear=1e7+5;\n        scanf(\"%d%d%d%d%d%d%d\",&n,&m,&k,&p,&q,&r,&MOD);\n        for(int i=1;i<=k;i++)\n            scanf(\"%lld\",&a[i]);\n        for(int i=k+1;i<=n;i++)\n            a[i]=(1LL*p*a[i-1]+1LL*q*i+r)%MOD;\n        long long MAX=0,CNT=0;\n        for(int i=n;i>=1;i--)\n        {\n            if(size==0)\n            {\n                que[front]=i;size=1;\n            }\n            else\n            {\n                if(a[que[front]]<=a[i])\n                {\n                    front=rear=1e7+5;\n                    que[front]=i;\n                    size=1;\n                }\n                else\n                {\n                    while(size>0&&a[que[rear]]<=a[i])\n                        size--,rear--;\n                    que[rear+1]=i;rear++;\n                    size++;\n                }\n            }\n            if(i<=n-m+1)\n            {\n                MAX+=a[que[front]]^i;\n                CNT+=size^i;\n                while(que[front]>=(i+m-1))\n                    front++,size--;\n            }\n        }\n        printf(\"%lld %lld\\n\",MAX,CNT);\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Sum of the Line (容斥/莫比乌斯反演)","url":"/2018/08/02/Sum-of-the-Line-(容斥莫比乌斯反演)/","content":"\n# [Sum of the Line](https://nanti.jisuanke.com/t/28970) \n\n## 题意\n\n给你一个n，分析之后发现求的是所有gcd(n,i)=1（i<=n）的数的平方和。\n\n用容斥，先用公式$\\frac{n(n+1)(2n+1)}{6}$求出1~n的平方和，然后筛出sqrt(n)内的素数，并求出n的所有质因数，然后对于质因数的乘积tot，如果质因数的个数是奇数，就加上$tot^2*(1^2+2^2+3^2……+(n/tot)^2)$，是偶数就减去。\n\n或者用莫比乌斯反演来做\n\n\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 998244353\n#define MAXN 10000\nusing namespace std;\ntypedef long long ll;\nll pri[10010],num=0;\nbool vis[10010];\nvector<ll>pr;\nvoid init()\n{\n    ll i,j;\n    for(i=2;i<MAXN;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAXN&&i%pri[j]!=0;j++)\n            vis[i*pri[j]]=true;\n    }\n}\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    init();\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        pr.clear();\n        ll xs=inverse(6ll,MOD);\n        ll tot=(((n*(n+1))%MOD*(2*n+1))%MOD*xs)%MOD;\n        ll temp=n;\n        for(int i=0;i<num;i++)\n        {\n            if(temp%pri[i]==0)\n            {\n                pr.push_back(pri[i]);\n                while(temp%pri[i]==0)\n                    temp/=pri[i];\n            }\n        }\n        if(temp>1)pr.push_back(temp);\n        int len=pr.size();\n        ll ans=0;\n        for(int i=1;i<(1<<len);i++)\n        {\n            int cnt=0;//有几个1\n            ll d=1;\n            for(int j=0;j<len;j++)\n            {\n                int temp=i>>j&1;\n                if(temp==1)\n                {\n                    cnt++;d=d*pr[j];\n                }\n            }\n            ll gs=n/d;\n            ll g=(((gs*(gs+1))%MOD*(2*gs+1))%MOD*xs)%MOD;\n            if(cnt%2==0)ans=(ans-((d*d)%MOD*g)%MOD+MOD)%MOD;\n            else ans=(ans+((d*d)%MOD*g))%MOD;\n            }\n        }\n        printf(\"%lld\\n\",(tot-ans+MOD)%MOD);\n    }\n    return 0;\n}\n```\n\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"A Possible Tree (带权并查集）","url":"/2018/08/02/A-Possible-Tree-(带权并查集）/","content":"\n<h1>[A Possible Tree](https://nanti.jisuanke.com/t/28968)</h1>\n\n## 题意\n\n给你一棵树，q个询问，问的是x->y路径上的异或和为val , 问你最多有几个询问是真的？\n\n带权并查集。由于异或的特点，假设某个点为根，比如0，那么比如2->5的异或值，就是2->1的异或值和5->1的异或值异或一下。所以我们用yihuo[i]来表示i到源点的异或和。如果两个数的源点已经一样，那么判断一下val==yihuo[i]^yihuo[j]即可，若是不一样，就把他们union，同时yihuo[rootp]=yihuo[p]^yihuo[q]^val。\n\n\n\n## 看！代码\n\n``` c++\n#include <bits/stdc++.h>\nusing namespace std;\nint fa[100010],yihuo[100010];\nint Find(int x)\n{\n    if(x!=fa[x])\n    {\n        int tmp=fa[x];\n        fa[x]=Find(fa[x]);\n        yihuo[x]^=yihuo[tmp];\n        return fa[x];\n    }\n    return x;\n}\n\nbool Union(int p,int q,int val)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n    {\n        fa[rp]=rq;\n        yihuo[rp]=yihuo[p]^yihuo[q]^val;\n        return true;\n    }\n    if((yihuo[p]^yihuo[q])!=val)\n        return false;\n    return true;\n}\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        fa[i]=i;yihuo[i]=0;\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,k,u,v,val;\n        scanf(\"%d%d\",&n,&k);\n        init(n);\n        for(int i=0;i<n-1;i++)\n            scanf(\"%d%d\",&u,&v);\n        int flag=1,ans=0;\n        for(int i=0;i<k;i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&val);\n            if(!Union(u,v,val)&&flag)\n            {\n                flag=0;\n                ans=i;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["带权并查集"],"categories":["算法"]},{"title":"Teemo's reunited (曼哈顿距离，思维)","url":"/2018/08/02/Teemos-reunited-(曼哈顿距离，思维)/","content":"\n# [Teemo's reunited](https://nanti.jisuanke.com/t/29326) \n\n## 题意\n\n求的是其他所有的点到某一点的距离和的最小值，就是曼哈顿距离。\n\n>这题也是用“分治”，虽说题目要求的是曼哈顿距离，但是我们为什么真的就要一步到位的求呢，可以横纵坐标分开求，先x排序，然后遍历一遍，求出横坐标的距离，然后y排序，遍历一遍求出坐标的距离加在刚才求得的x的距离上，就是曼哈顿距离了。\n>\n>这里有一个非常巧妙但是其实很显而易见的东西：假定现在我们已经按x排好序了分别是ABC三个点，那么C到AB的距离和是|C-A|+|C-B|，又因为已经排序了，那么绝对值可以去掉，得(C-A)+(C-B)，那么就是2*C-(A+B)，也就是说一个点到它前面的点的距离的和等于它前面的点的个数乘以它的自己再减去前面所有点的和，到这里你是不是想到求一个数列的和的时候我们遍历一遍数列就得到了，通过这个方法我们用O(n)就得到了一个点到它前面的点的距离和，然后再倒着遍历一遍数列用相似的思想把它到它后面的点的距离再加上就行了。\n>\n>还有一种也是分开x,y排序求和，不过可以这么做：先直接求出最前面的点到所有点的距离，然后依次遍历数列，通过后面一个点跟前面一个点的关系，找出差值相减，就是了。不明白的话仔细想想或者画图看看。\n\n## 看！代码\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1000000000000007\nusing namespace std;\nstruct node{\n\tlong long x,y;\n\tlong long sum;\n}a[100005];\nbool cmp1(node a,node b)\n{\n\treturn a.x<b.x;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.y<b.y;\n}\nint main(){\n\tint t,n;\n\tscanf(\"%d\",&n);\n\tlong long ans=INF;\n\tmemset(a,0,sizeof(0));\n\tfor(int i=0;i<n;i++)  \n        scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tsort(a,a+n,cmp1);\n\tlong long sum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum=i*a[i].x-sum;\n\t\tsum+=a[i].x;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].x;\n\t\tsum+=a[i].x;\n\t}\n\tsort(a,a+n,cmp2);\n\tsum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum+=i*a[i].y-sum;\n\t\tsum+=a[i].y;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].y;\t\t\t\n\t\tsum+=a[i].y;\n\t\tans=min(ans,a[i].sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Teemo's hard problem (dp)","url":"/2018/08/02/Teemos-hard-problem-(dp)/","content":"\n# [Teemo's hard problem](https://nanti.jisuanke.com/t/29204) \n\n## 题意\n\n题目意思是给你一个数列，你可以任意反转[L,R]，使得这个数列的非递减序列最长。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint a[2010];\nint pre[2010];//1的前缀长度（包括自己）\nint suf[2010];//2的后缀长度（包括自己）\nint dp[2005][2005][4];//[i,j]中以k结尾的最长非递增序列长度\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        memset(pre,0,sizeof(pre));\n        memset(suf,0,sizeof(suf));\n        memset(dp,0,sizeof(dp));\n        for(int i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&a[i]);\n            if(a[i]==1)pre[i]=pre[i-1]+1;\n            else pre[i]=pre[i-1];\n        }\n        for(int i=n; i>=1; i--)\n        {\n            if(a[i]==2)suf[i]=suf[i+1]+1;\n            else suf[i]=suf[i+1];\n        }\n        for(int i=1; i<=n; i++)\n        {\n            dp[i][i][a[i]]=1;\n            for(int j=i+1; j<=n; j++)\n            {\n                if(a[j]==1)\n                {\n                    dp[i][j][1]=max(dp[i][j-1][1],dp[i][j-1][2])+1;\n                    dp[i][j][2]=dp[i][j-1][2];\n                }\n                else if(a[j]==2)\n                {\n                    dp[i][j][1]=dp[i][j-1][1];\n                    dp[i][j][2]=dp[i][j-1][2]+1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1; i<=n; i++)\n            for(int j=i; j<=n; j++)\n            {\n                ans=max(ans,pre[i-1]+max(dp[i][j][1],dp[i][j][2])+suf[j+1]);\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["dp"],"categories":["算法"]},{"title":"Teemo's bad day  (并查集)","url":"/2018/08/02/Teemos-bad-day-(并查集)/","content":"\n# [Teemo's bad day](https://nanti.jisuanke.com/t/29203)  \n\n## 题意\n\n给两个相同长度的数组A，B，一次操作是改变A，B中相同的数字x为->y。如果A[i]=B[i]，i<=n，都成立，则完成。问最少的操作次数。\n\n裸并查集。find(a[i])!=find(b[i]),cnt++。\n\n## 看！代码\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[500010],b[500010];\nint fa[100010];\nint Find(int x)\n{\n    if(fa[x]==x)return x;\n    return fa[x]=Find(fa[x]);\n}\nvoid Union(int p,int q)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n        fa[rp]=rq;\n}\nvoid init(int n)\n{\n    for(int i=0;i<100010;i++)\n        fa[i]=i;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,cnt=0;\n        scanf(\"%d\",&n);\n        init(n);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d\",&b[i]);\n            if(a[i]==b[i]) continue;\n            if(Find(a[i])!=Find(b[i]))\n            {\n                cnt++;Union(a[i],b[i]);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n```\n\n","tags":["并查集"],"categories":["算法"]},{"title":"Goblin Garden Guards  (思维)","url":"/2018/08/02/Goblin-Garden-Guards-(思维)/","content":"\n# [Goblin Garden Guards](https://nanti.jisuanke.com/t/28882)  \n\n## 题意\n\n给n个哥布林的位置（x，y），给出m个圆，对于每一个圆，输出最大的不在圆内的哥布林数目。\n\n由于哥布林的位置是整数，那么对于圆，可以预处理出距离圆心0~r范围内的x最大偏差值和y的最大偏差值，如果哥布林的x，y与圆心的偏差值有一者在最大偏差值之外，就cnt++。\n\n## 看！代码\n\n```c++\n//拿的队友的代码\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nstruct point\n{\n    int x,y;\n}p[100010];\nbool cmp(point a,point b)\n{\n    return a.y<b.y;\n}\nvector<int>v[100010];\nvector<int>d[110];\nvoid init()\n{\n    for(int r=1;r<=100;r++)\n        for(int i=0;i<=r;i++)\n            d[r].push_back((int)floor(sqrt(1.0*r*r-i*i)));\n}\nint main()\n{\n    init();\n    int g,m,x,y,r;\n    scanf(\"%d\",&g);\n    for(int i=0;i<g;i++)\n        scanf(\"%d%d\",&p[i].x,&p[i].y);\n    sort(p,p+g,cmp);\n    for(int i=0;i<g;i++)\n        v[p[i].x].push_back(p[i].y);\n    scanf(\"%d\",&m);\n    int ans=0;\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&r);\n        int left=max(0,x-r),right=min(10000,x+r);\n        for(int dd=left;dd<=right;dd++)//横坐标\n        {       \n            int c=abs(dd-x);\n            int yl=max(0,y-d[r][c]),yr=min(10000,y+d[r][c]);\n            int pos1=lower_bound(v[dd].begin(),v[dd].end(),yl)-v[dd].begin();\n            int pos2=upper_bound(v[dd].begin(),v[dd].end(),yr)-v[dd].begin();\n            v[dd].erase(v[dd].begin()+pos1,v[dd].begin()+pos2);\n            ans+=pos2-pos1;\n        }\n    }\n    printf(\"%d\\n\",g-ans);\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Entertainment Box (multiset+贪心)","url":"/2018/08/02/Entertainment-Box-(multiset+贪心)/","content":"\n# [Entertainment Box](https://nanti.jisuanke.com/t/28880)  \n\n## 题意\n\nn个节目，k个录像带，给出每个节目的播放时间，求最多能录几个节目。\n\n用multiset维护当前正在录制的所有节目的结束时间，二分找到最接近下一个要录的节目的起始时间且小于起始时间的录像带，把这个录像带中的r替换成下一个要录的节目，cnt++，如果没有找到并且集合的size还不到k个的话，就直接把r放进去，cnt++。最后输出cnt。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstruct node\n{\n    int l,r;\n} nn[N];\nbool cmp(node a,node b)\n{\n    if(a.r==b.r)\n        return a.l<b.l;\n    return a.r<b.r;\n}\n\nmultiset<int>q;\nmultiset<int>::iterator pos;\nint main()\n{\n    int n,k;\n    int cnt=0;\n    int i;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d\",&nn[i].l,&nn[i].r);\n    sort(nn,nn+n,cmp);\n    for(i=0; i<n; i++)\n    {\n        if(q.empty())\n        {\n            cnt++;q.insert(nn[i].r);\n            continue;\n        }\n        if(*q.begin()>nn[i].l)\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n            continue;\n        }\n        pos=q.upper_bound(nn[i].l);\n        pos--;\n        if(*pos<=nn[i].l)\n        {\n            cnt++;\n            q.erase(pos);\n            q.insert(nn[i].r);\n        }\n        else\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    return 0;\n}\n```\n\n","tags":["贪心"],"categories":["算法"]},{"title":"Bell Ringing  (全排列的邻位构造法)","url":"/2018/08/02/Bell-Ringing-(全排列的邻位构造法)/","content":"\n# [Bell Ringing](https://nanti.jisuanke.com/t/28877)  \n\n用生成全排列的邻位互换法：（具体方法解释可以看排列组合的文章）\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1; 1\n\nn=2; 12 , 21\n\nn=3; 123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint A[15];\nint dir[15];\n\nvoid print()\n{\n    for(int i=1;i<n;i++)\n        printf(\"%d \",A[i]);\n    printf(\"%d\\n\",A[n]);\n}\nbool IF_Active(int i) //判断是否活跃（前面的数字比它小就是活跃）\n{\n    if(i+dir[i]<=0||i+dir[i]>n)\n        return false;\n    if(A[i+dir[i]]<A[i])\n        return true;\n    return false;\n}\n\nint MAX_Active() //找到最大的活跃数字\n{\n    int id=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(IF_Active(i)&&A[id]<A[i])\n            id=i;\n    }\n    return id;\n}\nint Swap(int i) //交换最大的活跃数字和它前面的那个数字，注意方向也要交换\n{\n    int c=A[i];\n    A[i]=A[i+dir[i]];\n    A[i+dir[i]]=c;\n\n    c=dir[i];\n    dir[i]=dir[i+c];\n    dir[i+c]=c;\n\n    return i+c;\n}\nvoid UPdate(int index)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(A[index]<A[i])\n            dir[i]=-dir[i];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        A[i]=i;\n        dir[i]=-1;\n    }\n    print();\n    \n    while(1)\n    {\n        int id=MAX_Active();\n        if(id==n+1) break;\n        id=Swap(id);\n        UPdate(id);\n        print();\n    }\n    return 0;\n}\n```\n\n","tags":["排列组合"],"categories":["算法"]},{"title":" Road(floyd+思维)","url":"/2018/08/02/Road(floyd+思维)/","content":"\n# [Road](https://nanti.jisuanke.com/t/28875)\n\n## 题意\n\n连通图，删去尽可能多的路，使得每个城市到第0号城市的最短路长度不变，求可能的方案数量。\n\n用floyd先求出每个城市之间的最短路，然后对每条0~i城市的最短路，判断0~j城市的距离加上i到j的原始距离是否还和最短路相等，相等的话，在j城市上的最短路径+1。最后将他们乘起来。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=350;\nconst long long MOD=1e9+7;\nint dist[maxn],g[maxn][maxn],f[maxn][maxn],N;\nlong long road[maxn];\nlong long floyd()\n{\n    long long ans=1;\n    memset(road,0,sizeof(road));\n\n    for (int k=0;k<N;k++)\n        for (int i=0;i<N;i++)\n            for (int j=0;j<N;j++)\n                if (i!=k&&i!=j&&j!=k)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    g[0][0]=0;\n    for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n        if(i!=j&&g[0][i]+f[i][j]==g[0][j])\n    {\n        road[j]++;\n    }\n    for(int i=1;i<N;i++)\n        if(road[i])\n            ans=(ans*road[i])%MOD;\n    return ans;\n\nint main()\n{\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        memset(g,INF,sizeof(g));\n        string s;\n        for(int i=0;i<N;i++)\n        {\n            cin>>s;\n            for(int j=0;j<s.size();j++)\n            {\n                if(s[j]=='0')\n                    f[i][j]=g[i][j]=INF;\n                else\n                \tf[i][j]=g[i][j]=s[j]-'0';\n            }\n        }\n        printf(\"%lld\\n\",floyd());\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":" Swaps and Inversions  (归并排序)","url":"/2018/08/02/Swaps-and-Inversions-(归并排序)/","content":"\n# [ Swaps and Inversions](http://acm.hdu.edu.cn/showproblem.php?pid=6318)  \n\n## 题意\n\n数逆序数对，再乘以min(x,y)即可。这里我发现逆序数对数有x个，就可以通过交换相邻数字x次使得它不存在逆序数。\n\n用归并排序可以得到逆序数对个数。\n\n## 看！代码\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nlong long sum;\nint a[500005];\nint temp[500005];\nvoid sort2(int a[],int l,int mid,int r)\n{\n    int i=l,j=mid+1,k=0;\n    while(i<=mid&&j<=r)\n    {\n        if(a[i]<=a[j])\n        {\n            temp[k++]=a[i++];\n        }\n        else\n        {\n            temp[k++]=a[j++];\n            sum+=mid-i+1;\n        }\n    }\n    while(i<=mid)  temp[k++]=a[i++];\n    while(j<=r)    temp[k++]=a[j++];\n\n    for(int i=l,k=0; i<=r; k++,i++)\n        a[i]=temp[k];\n}\n\nvoid sort1(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)/2;\n        sort1(a,l,mid);\n        sort1(a,mid+1,r);\n        sort2(a,l,mid,r);\n    }\n}\nint main()\n{\n    int n;\n    long long x,y;\n    while(scanf(\"%d%lld%lld\",&n,&x,&y)!=EOF)\n    {\n        sum=0;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort1(a,0,n-1);\n        printf(\"%lld\\n\",sum*min(x,y));\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Distinct Values (set思维构造)","url":"/2018/08/02/Distinct-Values-(set思维构造)/","content":"\n# [Distinct Values](http://acm.hdu.edu.cn/showproblem.php?pid=6301) \n\n## 题意\n\n给你一个n，一个q，表示数列中有n个元素，q个区间询问，每次一个[l,r]，表示此区间内的数字不能有重复，要求输出最小字典序的。\n\n## 思路\n\n先对区间进行排序，按照l从小到大，另外，如果有相同l的，按r从大到小。\n\n然后用set维护可以放在此区间的数字。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int,int>a,pair<int,int>b)\n{\n    if(a.first==b.first)\n        return a.second>b.second;\n    return a.first<b.first;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,q,l,r;\n        scanf(\"%d%d\",&n,&q);\n        set<int>val;\n        vector<pair<int,int> >p;\n        vector<int>x(n+5);\n        for(int i = 1 ;i <= n ; i++)\n            p.push_back( make_pair(i,i) );\n        for(int i=1;i<=n;i++)\n            val.insert(i);\n        for(int i=1;i<=n;i++)\n            x[i]=1;\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d\",&l,&r);\n            p.push_back(make_pair(l,r));\n        }\n        sort(p.begin(),p.end());\n        int left=1,cur=1;\n        set<int>::iterator it,bef;\n        for(int i=0;i<p.size();i++)\n        {\n            while(left<p[i].first)\n                val.insert(x[left++]);\n            for(it=val.begin();it!=val.end()&&cur<=p[i].second;)\n            {\n                x[cur++]=*it;\n                int s=*it;\n                it++;\n                val.erase(s);\n            }\n        }\n        for(int i=1;i<=n-1;i++)\n            printf(\"%d \",x[i]);\n        printf(\"%d\\n\",x[n]);\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Balanced Sequence (贪心)","url":"/2018/08/02/Balanced-Sequence-(贪心)/","content":"\n# [Balanced Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=6299) \n\n## 题意\n\n给你几个含有左右括号的串，你可以任意组合，求组合能得到的最大的括号匹配数量。\n\n贪心。\n\n具体贪心法可以见代码。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#pragma comment(linker, “/STACK:1024000000,1024000000”)\nusing namespace std;\nstruct node{\n    int left_no,right_no,yes;\n    node()\n    {\n        left_no=right_no=yes=0;\n    }\n};\nbool cmp(node a,node b)\n{\n    if(a.left_no>=a.right_no&&b.left_no<=b.right_no)//左少右多 + 左多右少 a前面\n        return true;\n    if(a.left_no<=a.right_no&&b.left_no>=b.right_no) //左少右多 + 左多右少 b前面\n        return false;\n    if(a.left_no<=a.right_no&&b.left_no<=b.right_no) //左少右多+左少右多 谁的左面数量多谁放前面\n        return a.left_no>b.left_no;\n    return a.right_no<b.right_no; // 左多右少 左多右少 谁的右边多谁放后面\n\n}\nchar s[5000010];\nint main()\n{\n    int n,t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        vector<node>a(n);\n        int len;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",s);\n            len=strlen(s);\n            long long left=0,right=0,ans=0;\n            for(int j=0;j<len;j++)\n            {\n                if(s[j]=='(')\n                    left++;\n                else\n                {\n                    if(left>0)  left--,ans++;\n                    else    right++;\n                }\n            }\n            a[i].left_no=left;\n            a[i].right_no=right;\n            a[i].yes=ans;\n        }\n        sort(a.begin(),a.end(),cmp);\n        long long left=0,right=0,ans=0;\n        for(int i=0;i<n;i++)\n        {\n            ans+=a[i].yes;\n            if(left>=a[i].right_no)\n                left-=a[i].right_no,ans+=a[i].right_no;\n            else\n                ans+=left,left=0;\n            left+=a[i].left_no;\n        }\n        printf(\"%lld\\n\",ans*2);\n    }\n    return 0;\n}\n```\n\n","tags":["-贪心"],"categories":["算法"]},{"title":"Divisions(大整数分解)","url":"/2018/08/02/Divisions(大整数分解)/","content":"\n# [Divisions](https://nanti.jisuanke.com/t/28395) \n\n## 思路\n\n输入一个整数，输出他的因子个数。n<=1e18\n\nPollard-Rho算法 随机算法 \n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nusing namespace std;\nconst int S=20;//随机算法判定次数，S越大，判错概率越小\n//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的\n//  a,b,c <2^63\nlong long mult_mod(long long a,long long b,long long c)\n{\n    a%=c;\n    b%=c;\n    long long ret=0;\n    while(b)\n    {\n        if(b&1){ret+=a;ret%=c;}\n        a<<=1;\n        if(a>=c)a%=c;\n        b>>=1;\n    }\n    return ret;\n}\n\n\n//计算  x^n %c\nlong long pow_mod(long long x,long long n,long long mod)//x^n%c\n{\n    if(n==1)return x%mod;\n    x%=mod;\n    long long tmp=x;\n    long long ret=1;\n    while(n)\n    {\n        if(n&1) ret=mult_mod(ret,tmp,mod);\n        tmp=mult_mod(tmp,tmp,mod);\n        n>>=1;\n    }\n    return ret;\n}\n\n\n//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数\n//一定是合数返回true,不一定返回false\nbool check(long long a,long long n,long long x,long long t)\n{\n    long long ret=pow_mod(a,x,n);\n    long long last=ret;\n    for(int i=1;i<=t;i++)\n    {\n        ret=mult_mod(ret,ret,n);\n        if(ret==1&&last!=1&&last!=n-1) return true;//合数\n        last=ret;\n    }\n    if(ret!=1) return true;\n    return false;\n}\n\n// Miller_Rabin()算法素数判定\n//是素数返回true.(可能是伪素数，但概率极小)\n//合数返回false;\n\nbool Miller_Rabin(long long n)\n{\n    if(n<2)return false;\n    if(n==2)return true;\n    if((n&1)==0) return false;//偶数\n    long long x=n-1;\n    long long t=0;\n    while((x&1)==0){x>>=1;t++;}\n    for(int i=0;i<S;i++)\n    {\n        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件\n        if(check(a,n,x,t))\n            return false;//合数\n    }\n    return true;\n}\n\n\n//************************************************\n//pollard_rho 算法进行质因数分解\n//************************************************\nmap<ll,int>factor;//质因数分解结果（刚返回时是无序的）\n\nlong long gcd(long long a,long long b)\n{\n    if(a==0)return 1;//???????\n    if(a<0) return gcd(-a,b);\n    while(b)\n    {\n        long long t=a%b;\n        a=b;\n        b=t;\n    }\n    return a;\n}\n\nlong long Pollard_rho(long long x,long long c)\n{\n    long long i=1,k=2;\n    long long x0=rand()%x;\n    long long y=x0;\n    while(1)\n    {\n        i++;\n        x0=(mult_mod(x0,x0,x)+c)%x;\n        long long d=gcd(y-x0,x);\n        if(d!=1&&d!=x) return d;\n        if(y==x0) return x;\n        if(i==k){y=x0;k+=k;}\n    }\n}\n//对n进行素因子分解\nvoid findfac(long long n)\n{\n    if(Miller_Rabin(n))//素数\n    {\n        factor[n]++;\n        return;\n    }\n    long long p=n;\n    while(p>=n)p=Pollard_rho(p,rand()%(n-1)+1);\n    findfac(p);\n    findfac(n/p);\n}\n\nint main()\n{\n    srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话\n    long long n;\n    scanf(\"%lld\",&n);\n    if(n==1){printf(\"1\\n\");return 0;}\n    findfac(n);\n    ll ans=1;\n    for(auto it=factor.begin();it!=factor.end();it++)\n        ans*=(it->second+1);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n","tags":["大数分解"],"categories":["算法"]},{"title":"Change of Scenery（次短路）","url":"/2018/08/02/Change-of-Scenery（次短路）/","content":"\n# [Change of Scenery](https://nanti.jisuanke.com/t/28394) \n\n# 题意\n\n求是否存在一条不同于最短路但长度相同的路。\n\n1. 求次短路是否等于最短路\n2. dijstra的时候标记一下\n\n## 看！代码\n\n```c++\n//求次短\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#define MAXN (10000 + 10)\n#define INF (5000*5000*2)\nusing namespace std;\n\nstruct edge\n{\n    int to, cost;\n    edge(int tv = 0, int tc = 0):\n        to(tv), cost(tc) {}\n};\ntypedef pair<int,int> P;\nint N, R;\nvector<edge> graph[MAXN];\nint dist[MAXN];     //最短距离\nint dist2[MAXN];    //次短距离\n\nvoid solve()\n{\n    fill(dist, dist+N, INF);\n    fill(dist2, dist2+N, INF);\n    //从小到大的优先队列\n    //使用pair而不用edge结构体\n    //是因为这样我们不需要重载运算符\n    //pair是以first为主关键字进行排序\n    priority_queue<P, vector<P>, greater<P> > Q;\n    //初始化源点信息\n    dist[0] = 0;\n    Q.push(P(0, 0));\n    //同时求解最短路和次短路\n    while(!Q.empty())\n    {\n        P p = Q.top();\n        Q.pop();\n        //first为s->to的距离，second为edge结构体的to\n        int v = p.second, d = p.first;\n        //当取出的值不是当前最短距离或次短距离，就舍弃他\n        if(dist2[v] < d) continue;\n        for(unsigned i = 0; i < graph[v].size(); i++)\n        {\n            edge &e = graph[v][i];\n            int d2 = d + e.cost;\n            if(dist[e.to] > d2)\n            {\n                swap(dist[e.to], d2);\n                Q.push(P(dist[e.to], e.to));\n            }\n            if(dist2[e.to] > d2 && dist[v] < d2)\n            {\n                dist2[e.to] = d2;\n                Q.push(P(dist2[e.to], e.to));\n            }\n        }\n    }\n}\nint main()\n{\n    int A, B, D,K;\n    scanf(\"%d%d%d\", &N, &R,&K);\n    while(K--)\n        scanf(\"%d\",&A);\n    for(int i = 0; i < R; i++)\n    {\n        scanf(\"%d%d%d\", &A, &B, &D);\n        graph[A-1].push_back(edge(B-1, D));\n        graph[B-1].push_back(edge(A-1, D));\n    }\n    solve();\n    if(dist2[N-1]==dist[N-1])\n        printf(\"yes\\n\");\n    else\n        printf(\"no\\n\");\n    return 0;\n}\n```\n\n","tags":["次短路"],"categories":["算法"]},{"title":"Bounty Hunter II（最小路径覆盖）","url":"/2018/08/02/Bounty-Hunter-II（最小路径覆盖）/","content":"\n# [Bounty Hunter II](https://nanti.jisuanke.com/t/28391) \n\n## 题意\n\n求最小路径覆盖数（不交叉），套最大流模板即可。\n\n结点总数-匹配数=覆盖数\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5010;\nconst int M=3000010;\nconst int inf=0x3f3f3f3f;\nstruct Edge\n{\n    int v,cap,nxt;\n}e[M];;//邻接表要开边数的两倍\nint src,des,dis[N],head[N],ecnt;  //memset dis,head-1 ecnt=0,src=0,des=2*n+1;\nint n,m;\nvoid Addedge(int u,int v,int w)\n{\n    e[ecnt].v=v;\n    e[ecnt].cap=w;\n    e[ecnt].nxt=head[u];\n    head[u]=ecnt++;\n    e[ecnt].v=u;\n    e[ecnt].cap=0;\n    e[ecnt].nxt=head[v];\n    head[v]=ecnt++;\n}\nbool Bfs()\n{\n    queue<int>q;\n    q.push(src);\n    memset(dis,-1,sizeof(dis));\n    dis[src]=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();\n        for(int i=head[u];~i;i=e[i].nxt)\n        {\n            int v=e[i].v;\n            if(e[i].cap>0&&dis[v]==-1)\n            {\n                dis[v]=dis[u]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[des]>=0;\n}\nint Dfs(int u,int a)\n{\n    if(u==des) return a;\n    for(int i=head[u];~i;i=e[i].nxt)\n    {\n        int v=e[i].v,t=0;\n        if(e[i].cap>0&&dis[v]==dis[u]+1&&(t=Dfs(v,min(a,e[i].cap))))\n        {\n            e[i].cap-=t;\n            e[i^1].cap+=t;\n            return t;\n        }\n    }\n    dis[u]=-1;\n    return 0;\n}\nint Dinic()\n{\n    int ans=0;\n    while(Bfs())\n    {\n        int t=0;\n        while(t=Dfs(src,inf)) ans+=t;\n    }\n    return ans;\n}\nint main()\n{\n    int num,u,v;\n    ecnt=0;\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&num);\n    src=0;des=2*num+1;\n    for(int i=1;i<=num;i++)\n        Addedge(0,i,1);\n    for(int i=num+1;i<=2*num;i++)\n        Addedge(i,2*num+1,1);\n    for(int i=1;i<=num;i++)\n    {\n        scanf(\"%d\",&u);\n        while(u--)\n        {\n            scanf(\"%d\",&v);\n            Addedge(i,num+v+1,1);\n        }\n    }\n    n=num+2;\n    printf(\"%d\\n\",num-Dinic());\n    return 0;\n}\n```\n\n","tags":["网络流"],"categories":["算法"]},{"title":"莫比乌斯题集（有丶意思）","url":"/2018/07/31/莫比乌斯题集/","content":"\n<h1>[YY的GCD](https://www.luogu.org/problemnew/show/P2257)</h1>\n\n## 题意\n\n给你一个n,m，求gcd(i,j)=质数的(x,y)有多少对？(1<=x<=N,1<=y<=M)\n\n## 思路\n\n题目实际上是要求：\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^Mgcd(i,j)=prim\n$$\n由莫比乌斯反演的基本公式：\n$$\nF(n)=\\sum_{n|d}f(d)\n$$\n\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)\n$$\n\n听说一般这种题都是设f(d)= gcd(i,j)==d的个数，F(n) =gcd(i,j)== d和d的倍数的个数 (那么对于上界N和M，就有$F(n)=\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor$，因为对于(i,j)，它们的上限为(N,M)，gcd(i,j)=n,而F(n)求的是d和d的倍数的个数，所以对于i，j来说，这样的搭配有N/n*M/n个）。\n\n所以我们可以得到下面的式子：\n$$\nf(d)=\\sum_{i=1}^N\\sum_{j=1}^M[gcd(i,j)==d]\n$$\n\n$$\nF(n)=\\sum_{n|d}f(d) =\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor\n$$\n\n带入莫比乌斯公式：\n\n\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)=\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor\\sum_{n|d}μ(\\frac{d}{n})\n$$\n\n$$\nans=\\sum_{i=1}^{N}\\sum_{j=1}^{M}[gcd==p]\n$$\n\n$$\n=\\sum_{p=prim}f(p)\n$$\n\n$$\n=\\sum_{p=prim}\\sum_{p|d}μ(\\frac{d}{p})\\lfloor\\frac{N}{p}\\rfloor \\lfloor\\frac{M}{p}\\rfloor\n$$\n\n枚举$\\lfloor\\frac{d}{p}\\rfloor$,或者说令d=dp，那么d就变成了p的倍数，所以sum枚举的值就变成了1~d(d最大可以取到N/p和M/p中的最小值，因为p是gcd(i,j)==p，那么就不可能取i，j中大的值)：\n$$\nans=\\sum_{p=prim}\\sum_{d=1}^{min(\\lfloor\\frac{N}{p}\\rfloor ,\\lfloor\\frac{M}{p}\\rfloor)}μ(d)\\lfloor\\frac{N}{dp}\\rfloor \\lfloor\\frac{M}{dp}\\rfloor\n$$\n将dp=T，则p∈{t|T%t==0&&t==prim}：\n$$\nans=\\sum_{T=1}^{min(N,M)}\\sum_{t|T,t∈prim}μ(\\lfloor\\frac{T}{t}\\rfloor)\\lfloor\\frac{N}{T}\\rfloor\\lfloor\\frac{M}{T}\\rfloor\n$$\n\n$$\n=\\sum_{T=1}^{min(N,M)}\\lfloor\\frac{N}{T}\\rfloor\\lfloor\\frac{M}{T}\\rfloor\\sum_{t|T,t∈prim}μ(\\lfloor\\frac{T}{t}\\rfloor)\n$$\n\n就可以做了。\n\n<h2>看！代码</h2>\n\n第一份O(n)直接求和的代码，当然会T。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000010;\nint prim[N];//316067\nbool vis[N];\nint mu[N];\nint cnt=0;\n//埃式筛法，这里没有用到\n//求n以内的质数的个数\nvoid get_list(int n)\n{\n    cnt=0;\n    memset(vis,false,sizeof(vis));\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]) prim[++cnt]=i;\n            for(int j=1;j<=cnt&&i*prim[j]<=n;j++){\n                   vis[i*prim[j]]=1;\n                   //合数标为1，同时，prime[j]是合数i*prime[j]的最小素因子\n                   if(i%prim[j]==0) break;\n                    //即比一个合数大的质数和该合数的乘积可用一个更大的合数和比其小的质数相乘得到\n             }\n       }\n}\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n}\nint main()\n{\n    get_mu(10000000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        long long ans=0;\n        for(int i=1;i<=Min;i++)\n        {\n            long long sum=0;\n            for(int j=1;j<=cnt&&prim[j]<=i;j++)\n            {\n                if(i%prim[j]==0)\n                    sum+=mu[i/prim[j]];\n            }\n            sum*=(n/i)*(m/i);\n            ans+=sum;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n第二份用了整数分块优化，写的我头真大，比如多加一个memset，T，int开了long long T，\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000010;\n\nbool vis[N];\nint prim[N],pre[N],mu[N];\nint cnt;\nlong long sum[N];\n\n/** 对于μ函数的线筛*/\nvoid get_mu(int n)\n{\n   // memset(vis,false,sizeof(vis));\n    cnt=0;\n\tmu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]){mu[i]=-1;prim[++cnt]=i;}\n        for(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n            vis[i*prim[j]]=1;\n            if(i%prim[j]==0)break;\n            else mu[prim[j]*i]=-mu[i];\n        }\n    }\n    sum[0]=0;\n\tfor(int j=1;j<=cnt;j++)\n        for(int i=1;i*prim[j]<=n;i++)\n        pre[i*prim[j]]+=mu[i];   //预处理对于某一个数，它的质数因子的mu（T/i）和\n    //为了得到区间i的mu和，通过求出前缀和来做\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+(long long)pre[i];\n}\nint main()\n{\n    get_mu(10000000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        long long ans=0;\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l)); //这里要注意\n            ans+=1ll*(m/l)*(n/l)*(sum[r]-sum[l-1]); \n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n<h1>POI2007[ZAP-Queries](https://www.luogu.org/problemnew/show/P3455)</h1>\n\n## 题意\n\n求$\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d] $，多组，$1\\le d\\le a,b\\le 50000$\n\n<h2>思路</h2>\n$$\nans=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d]\n$$\n\n我们假设：\n$$\nf(d)=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d]\n$$\n\n$$\nF(n)=\\sum_{d|n}f(d)=\\lfloor\\frac{a}{n}\\rfloor\\lfloor\\frac{b}{n}\\rfloor\n$$\n\n$$\nf(d)=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)F(n)\n$$\n\n发现原来f(d)=ans，那么有：\n$$\nans=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)F(n)=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)\\lfloor\\frac{a}{n}\\rfloor\\lfloor\\frac{b}{n}\\rfloor\n$$\n枚举$\\lfloor{\\frac{n}{d}\\rfloor}$=t：\n$$\nans=\\sum_{t=1}^{min(a,b)}μ(t)\\lfloor\\frac{a}{dt}\\rfloor\\lfloor\\frac{b}{dt}\\rfloor\n$$\n就能做了。\n\n因为前面已经做了一道比这题难的，所以就不写O(n)的写法了，直接上代码，一遍过，爽歪歪。\n\n<h2>看！代码</h2>\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=50010;\n\nbool vis[N];\nint prim[N],pre[N],mu[N];\nint cnt;\nlong long sum[N];\n\n/** 对于μ函数的线筛*/\nvoid get_mu(int n)\n{\n   // memset(vis,false,sizeof(vis));\n    cnt=0;\n\tmu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]){mu[i]=-1;prim[++cnt]=i;}\n        for(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n            vis[i*prim[j]]=1;\n            if(i%prim[j]==0)break;\n            else mu[prim[j]*i]=-mu[i];\n        }\n    }\n    sum[0]=0;\n    for(int i=1;i<=n;i++)\n        pre[i]+=mu[i]; \n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+(long long)pre[i];\n}\nint main()\n{\n    get_mu(50000);\n    int t,a,b,d;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d%d\",&a,&b,&d);\n        int Min=min(a,b);\n        long long ans=0;\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(a/(a/l),b/(b/l));\n            ans+=1ll*(a/(l*d))*(b/(l*d))*(sum[r]-sum[l-1]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n# <h1>[约数个数和](https://www.luogu.org/problemnew/show/P3327)</h1>\n\n## <h2>题意</h2>\n\n设d(x)为x的约数个数，给定N、M，求$\\sum_{i=1}^{N}\\sum_{j=1}^{M}d(ij)$\n\n多组，N,M。1<=N, M<=50000 \n\n## <h2>思路</h2>\n\n关于这个约数的个数d(x)，它其实有下面这样的函数式：\n$$\nd(ij)=\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\n$$\n接下来套路的设：\n$$\nf(d)=\\sum_{i=1}^N\\sum_{j=1}^{M}[gcd(i,j)==d]\n$$\n\n$$\nF(n)=\\sum_{n|d}f(d)=\\lfloor\\frac{N}{n}\\rfloor\\lfloor\\frac{M}{n}\\rfloor      --①\n$$\n\n由莫比乌斯反演可以得到：\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)\n$$\n因为：\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\n$$\n由于$∑_{d|n}μ(d)$的性质，即d=1的时候=1，其他都是0，可以将式子化为：\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} \\sum_{d|gcd(x,y)}μ(d)\n$$\n枚举d|gcd(x,y)的情况 ，d从1取到min(N,M)\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} \\sum_{d=1}^{min(N,M)}μ(d)*[d|gcd(x,y)]\n$$\n由于μ(d)与x，y，i，j无关，所以可以提到最前面\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} [d|gcd(x,y)]\n$$\n对于x|i，y|j的情况，可以由①得到$=\\lfloor\\frac{N}{x}\\rfloor\\lfloor\\frac{M}{y}\\rfloor$\n\n> 由**枚举i,j和它们的约数**改变为**枚举它们的约数**再直接乘上这些约数的倍数的个数。因为每一个约数都会对它的倍数产生贡献。 \n\n$$\nc\n$$\n\n为了将d|gcd(x,y)这个条件消去，我们更换枚举项x->dx，y->dy：\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{x=1}^{\\frac{N}{d}}\\sum_{y=1}^{\\frac{M}{d}}\\lfloor\\frac{N}{dx}\\rfloor\\lfloor\\frac{M}{dy}\\rfloor\n$$\n\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{x=1}^{\\frac{N}{d}}\\lfloor\\frac{N}{dx}\\rfloor\\sum_{y=1}^{\\frac{M}{d}}\\lfloor\\frac{M}{dy}\\rfloor\n$$\n\n就可以做了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint mu[50010];\nint prim[50010];\nbool vis[50010];\nlong long sum[50010],chu[50010];\nint cnt;\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n\t//这里是key\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+mu[i]; //第一个sum\n    for(int i=1;i<=n;i++)\n    {\n\n        long long ans=0;\n        for(int l=1,r;l<=i;l=r+1)\n        {\n            r=i/(i/l); \n            ans+=1ll*(r-l+1)*(i/l);\n        }\n        chu[i]=ans;//第2、3个sum，枚举n（n/d）来算\n    }\n\n}\nint main()\n{\n    get_mu(50000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        long long ans=0;\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l)); //右边的数应当取min，这里只有一个n就没关系\n            ans+=(sum[r]-sum[l-1])*(chu[n/l])*(chu[m/l]);\n            //三个sum相乘\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n# [problem b](https://www.luogu.org/problemnew/show/P2522)\n\n## 题意\n\n- 对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数。\n- 输入格式：\n  第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k\n- 输出格式：\n  共n行，每行一个整数表示满足要求的数对(x,y)的个数\n- 1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000 \n\n## 思路\n\n这里用了容斥的思想：\n$$\nans=\\sum_{i=a}^{b}\\sum_{j=c}^{d}[gcd(i,j)==k]\n$$\n实际上，（画个图就明白了）\n$$\nans=sum{(1,b)(1,d)}-sum(1,b)(1,c-1)-sum(1,a-1)(1,d)+sum(1,a-1)(1,c-1)\n$$\n所以还是老套路，ans的每一部分可以分别套入公式算出来，所以只要求出一个公式：\n$$\nans=\\sum_{t=1}^{min(X,Y)}μ(t)\\lfloor\\frac{X}{kt}\\rfloor\\lfloor\\frac{Y}{kt}\\rfloor\n$$\n将x、y分别用b、d；b、c-1；a-1、d；a-1，c-1带入公式加加减减就好了。\n\np.s.现在的题目都T的很。。。无聊。。。我把计算的式子用ans来接收返回的函数然后输出ans,T掉，直接输出结果。。。。就快一点。。话是这样说。。。但是这也太。。。。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint mu[50010];\nint prim[50010];\nbool vis[50010];\nlong long sum[50010],chu[50010];\nint cnt;\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n    mu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n    }\n    //这里是key\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+mu[i];\n\n}\nll cal(int n,int m,int k)\n{\n    ll ans=0;\n    int Min=min(n,m);\n    for(int l=1,r;l<=Min;l=r+1)\n    {\n        r=min(n/(n/l),m/(m/l)); //右边的数应当取min，这里只有一个n就没关系\n        ans+=(sum[r]-sum[l-1])*(n/(l*k))*(m/(l*k));\n            //这里根据情况改啊！r-（l-1）是因为这里的积性函数可以看作是μ(i)=1，n/l是后面的那个n/i\n    }\n   // printf(\"%lld\\n\",ans);\n    return ans;\n}\nint main()\n{\n    get_mu(50000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int a,b,c,d,k;\n        scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&k);\n        printf(\"%lld\\n\",cal(b,d,k)-cal(a-1,d,k)-cal(b,c-1,k)+cal(a-1,c-1,k));\n    }\n    return 0;\n}\n```\n\n# [crash的数字表格](https://www.luogu.org/problemnew/show/P1829)\n\n## 题意\n\n求$Ans=\\sum_{i=1}^{n}\\sum_{j=1}^{m}lcm(i,j) $\n\n- 输入格式：\n- 输入的第一行包含两个正整数，分别表示N和M。\n- 输出格式：\n- 输出一个正整数，表示表格中所有数的和mod20101009的值。\n\n## 思路\n\n由公式：$lcm(i,j)=\\frac{ij}{gcd(i,j)}$可以得到，\n$$\nans=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\frac{ij}{gcd(i,j)}\n$$\ngcd在分母中不好，枚举gcd=d，将其放到前面来：\n$$\nans=\\sum_{d=1}^{min(N,M)}\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\frac{ij}{d}[gcd(i,j)=d]\n$$\nd在分母中又不爽，还有gcd，枚举gcd（让i=di，j=dj）：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij[gcd(i,j)=1]\n$$\n由于性质$\\sum_{x|n}μ(x) = (n=1)$\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij \\sum_{x|gcd(i,j)}μ(x)\n$$\n要消去x|gcd(i,j)，因此枚举x：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{x=1}^{min(\\lfloor\\frac{N}{d}\\rfloor,\\lfloor\\frac{M}{d}\\rfloor)}μ(x)\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij[x|gcd(i,j)]\n$$\n为了消去那个[]的条件，我们让i=xi，j=xj：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{x=1}^{min(\\lfloor\\frac{N}{d}\\rfloor,\\lfloor\\frac{M}{d}\\rfloor)}x^2μ(x)\\sum_{i=1}^{\\lfloor\\frac{N}{dx}\\rfloor}i\\sum_{j=1}^{\\lfloor\\frac{M}{dx}\\rfloor}j\n$$\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"莫比乌斯反演","url":"/2018/07/30/莫比乌斯反演/","content":"\n## 整数分块\n\n比如：\n$$\n\\sum_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor\n$$\n$O(n)$的做法之外，还有一种$O(\\sqrt{n})$的做法。\n\n对于每个$\\lfloor\\frac{n}{i}\\rfloor$我们可以通过打表发现有许多的值是不断重复的，再继续寻找规律（不会找啊Orz）发现每一块的数字都是n/(n/i)，那么就可以利用分块的道理：\n\n```c++\nfor(int l=1,r;l<=n;l=r+1)\n{\n    r=n/(n/l); //右边的数应当取min，这里只有一个n就没关系\n    ans+=(r-l+1)*(n/l);\n    //这里根据情况改啊！r-（l-1）是因为这里的积性函数可以看作是μ(i)=1，n/l是后面的那个n/i\n}\n```\n\n有时候可能推出来的式子没有这么裸，它可能乘了一个积性函数$\\mu,\\varphi $，这时候就要对这些函数统计一个前缀和，因为当我们跳过一个分块的时候，就相当于跳过了这个块的函数值。\n\nP.S. 当$O(n)$也T，杜教筛？？？？？？？？？？？？\n\n## 莫比乌斯函数μ(d)\n\n**定义：**\n\n1. d = 1时，μ(d) = 1；\n2. d = $\\Pi_{i=1}^{k}p_i $ ，pi为互不相同的素数时，$μ(d) =(-1)^k$（也就是说，当用于乘积的某一个质因子的次数不大于1时，μ值由用于乘积的质因子个数决定）；\n3. 其他情况，都为0 。\n\n**性质：**\n\n1. $\\sum_{d|n}μ(d) = (n=1)$\n2. $\\sum_{d|n}\\frac{μ(d)}{d} = \\frac{φ(n)}{n}$,其中φ为小于n与n互质的数字的个数\n\n```c++\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n}\n```\n\n## 莫比乌斯反演\n\n定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：\n$$\nF(n)=\\sum_{d|n}f(d)\n$$\n 那么参考容斥的话，就能推出：\n$$\nf(n)=\\sum_{d|n}μ(d)F(\\frac{n}{d})\n$$\n一个更好用的形式，当满足：\n$$\nF(n)=\\sum_{n|d}f(d)\n$$\n有：\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(d)\n$$\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"在比赛中遇到的稀奇古怪的结论","url":"/2018/07/29/在比赛中遇到的稀奇古怪的结论/","content":"\n#稀奇古怪\n\n\n\n1. 将多边形对角线相连，其对角线最多被分割成多少段？\n\n\n$$\nmax=(n^4-6*n^3+17*n^2-24*n)/12\n$$\n\n2. 一个圆，一个圆的内接n边形，连接多边形对角线，求整个圆被分割成几块?\n\n\n$$\nmax=(n^4-6*n^3+23*n^2-18*n+24)/24\n$$\n\n3. 根号函数的性质：$\\sqrt{a+b+c+…}\\le\\sqrt{a}+\\sqrt{b}+\\sqrt{c}+…$\n\n   \n\n   ","categories":["算法"]},{"title":"拉格朗日插值法","url":"/2018/07/29/拉格朗日插值/","content":"\n可以求给定式子的前n项和。\n\n感觉可以求给定式子的前n项和。\n\n如：求3x^5+4x^3-5x+8;\n\n式子中最高项次数为5，则需要先计算出6个数字。\n\n板子的使用：\n\n先调用polysum::init(m); 这里的m要和D一起改，m<D;\n\n然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。\n\n模板（[求n^k的前n项和](https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1258)）：\n\n```c++\n/**\n先调用polysum::init(m); 这里的m要和D一起改，m<D;\n\n然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。\n\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int MOD=1e9+7;\ntypedef long long ll;\nnamespace polysum {\n\t#define rep(i,a,n) for (int i=a;i<n;i++)\n\t#define per(i,a,n) for (int i=n-1;i>=a;i--)\n\tconst int D=51000;\n\tll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D];\n\tll powmod(ll a,ll b){ll res=1;a%=mod;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\tll calcn(int d,ll *a,ll n) { // a[0].. a[d]  a[n]\n\t\tif (n<=d) return a[n];\n\t\tp1[0]=p2[0]=1;\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-i+mod)%mod;\n\t\t\tp1[i+1]=p1[i]*t%mod;\n\t\t}\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-d+i+mod)%mod;\n\t\t\tp2[i+1]=p2[i]*t%mod;\n         }\n\t\tll ans=0;\n\t\trep(i,0,d+1) {\n\t\t\tll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;\n\t\t\tif ((d-i)&1) ans=(ans-t+mod)%mod;\n\t\t\telse ans=(ans+t)%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init(int M) {\n\t\tf[0]=f[1]=g[0]=g[1]=1;\n\t\trep(i,2,M+5) f[i]=f[i-1]*i%mod;\n\t\tg[M+4]=powmod(f[M+4],mod-2);\n\t\tper(i,1,M+4) g[i]=g[i+1]*(i+1)%mod;\n\t}\n\tll polysum(ll m,ll *a,ll n) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]\n\t\tll b[D];\n\t\tfor(int i=0;i<=m;i++) b[i]=a[i];\n\t\tb[m+1]=calcn(m,b,m+1);\n\t\trep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod;\n\t\treturn calcn(m+1,b,n-1);\n\t}\n\tll qpolysum(ll R,ll n,ll *a,ll m) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]*R^i\n\t\tif (R==1) return polysum(n,a,m);\n\t\ta[m+1]=calcn(m,a,m+1);\n\t\tll r=powmod(R,mod-2),p3=0,p4=0,c,ans;\n\t\th[0][0]=0;h[0][1]=1;\n\t\trep(i,1,m+2) {\n\t\t\th[i][0]=(h[i-1][0]+a[i-1])*r%mod;\n\t\t\th[i][1]=h[i-1][1]*r%mod;\n\t\t}\n\t\trep(i,0,m+2) {\n\t\t\tll t=g[i]*g[m+1-i]%mod;\n\t\t\tif (i&1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod;\n\t\t\telse p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod;\n\t\t}\n\t\tc=powmod(p4,mod-2)*(mod-p3)%mod;\n\t\trep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod;\n\t\trep(i,0,m+2) C[i]=h[i][0];\n\t\tans=(calcn(m,C,n)*powmod(R,n)-c)%mod;\n\t\tif (ans<0) ans+=mod;\n\t\treturn ans;\n\t}\n} // polysum::init();\nll pow2(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    ll b[51000];\n    b[0]=0;\n    polysum::init(50000);\n    while(t--)\n    {\n        ll n,k;\n        scanf(\"%lld%lld\",&n,&k);\n        for(ll i=1;i<=k+1;i++)\n        {\n            b[i]=pow2(i,k);\n        }\n        printf(\"%lld\\n\",polysum::polysum(k,b,n+1));\n    }\n    return 0;\n}\n\n```\n\n---","categories":["算法"]},{"title":"HDU 6315 Naive Operations(线段树)","url":"/2018/07/29/HDU 6315 Naive Operations/","content":"\n\n\n[HDU 6315 Naive Operations](http://acm.hdu.edu.cn/showproblem.php?pid=6315)\n\nn个数，q个询问\n\n起始a、b数组都是n个元素，a数组全是0，b是1~n的全排列\n\nadd l r  ：a中【l，r】都加1\n\nquery l r ：询问∑floor(ai/bi) (i : l~r)\n\n思路：\n\n区间更新的线段树，维护区间最小值min（bi-ai%bi） 当min=0时sum++。\n\n具体看代码注释\n\n```c++\n#include <bits/stdc++.h>\n#define MAXN 100010\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct node{\n    long long l,r;//区间[l,r]\n    long long add;//区间的延时标记\n    long long sum;//区间和\n    long long mn; //区间最小值\n    long long bi; //对应bi\n}tree[MAXN<<2];//一定要开到4倍多的空间\n\nvoid pushup(int index)\n{\n    tree[index].sum = tree[index<<1].sum+tree[index<<1|1].sum;\n    tree[index].mn = min(tree[index<<1].mn,tree[index<<1|1].mn);\n}\nvoid pushdown(int index)\n{\n    //说明该区间之前更新过\n    //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新\n    if(tree[index].add)\n    {\n        tree[index<<1].mn -= tree[index].add;\n        tree[index<<1|1].mn -= tree[index].add;\n        tree[index<<1].add += tree[index].add;\n        tree[index<<1|1].add += tree[index].add;\n        tree[index].add = 0;\n    }\n}\nvoid print(int l,int r,int index) //测试数据 输出具体\n{\n    printf(\"l:%d r:%d bi:%lld min:%lld sum:%lld lazy:%d\\n\",l,r,tree[index].bi,tree[index].mn,tree[index].sum,tree[index].add);\n    if(tree[index].l==tree[index].r)\n    {\n         return;\n    }\n    int mid=(l+r)>>1;\n    print(l,mid,index<<1);\n    print(mid+1,r,index<<1|1);\n}\nvoid build(int l,int r,int index)\n{\n    tree[index].l = l;\n    tree[index].r = r;\n    tree[index].add = 0;//刚开始一定要清0\n    tree[index].sum=0;\n    if(l == r)\n    {\n        scanf(\"%lld\",&tree[index].bi);\n        tree[index].mn = tree[index].bi;\n        tree[index].sum=0;\n        return ;\n    }\n    int mid = (l+r)>>1;\n    build(l,mid,index<<1);\n    build(mid+1,r,index<<1|1);\n    pushup(index);\n}\nvoid updata(int l,int r,int index)\n{\n    if(l<=tree[index].l&&r>=tree[index].r&&tree[index].mn>1) \n    {\n        tree[index].mn--;\n        tree[index].add++;\n        return ;\n    }\n    if(tree[index].l==tree[index].r)\n    {\n        tree[index].mn--;\n        tree[index].add++;\n        if(tree[index].mn<=0)\n        {\n            tree[index].sum++;\n            tree[index].mn=tree[index].bi;\n        }\n        return ;\n    }\n    pushdown(index);\n    int mid = (tree[index].l+tree[index].r)>>1;\n\n    if (r <= mid) updata(l,r,index<<1);\n    else if (l>mid) updata(l,r,index<<1|1);\n    else {\n        updata(l,mid,index<<1);\n        updata(mid+1,r,index<<1|1);\n    }\n\n    pushup(index);\n}\nlong long query(int l,int r,int index)\n{\n    if(l == tree[index].l && r == tree[index].r)\n        return tree[index].sum;\n\n    pushdown(index);\n    int mid = (tree[index].l+tree[index].r)>>1;\n    long long ans = 0;\n    if(r<=mid) ans = query(l,r,index<<1);\n    else if(l>mid) ans = query(l,r,index<<1|1);\n    else{\n        return ans = query(l,mid,index<<1)+query(mid+1,r,index<<1|1);\n    }\n    pushup(index);\n    return ans;\n}\nint main()\n{\n    int n,m,q,x,y,z;\n    char s[100];\n    while(~scanf(\"%d%d\",&n,&m)){\n    build(1,n,1);\n    while(m--)\n    {\n        scanf(\"%s%d%d\",s,&x,&y);\n        if(s[0] =='q' )\n            printf(\"%lld\\n\",query(x,y,1));\n        else\n            updata(x,y,1);\n    //    print(1,n,1);\n     //   printf(\"m:%d\\n\",m);\n    }\n    }\n    return 0;\n}\n/*\n5 12\n1 5 2 4 3\nadd 1 4\nquery 1 4\nadd 2 5\nquery 2 5\nadd 3 5\nquery 1 5\nadd 2 4\nquery 1 4\nadd 2 5\nquery 2 5\nadd 2 2\nquery 1 5\n*/\n\n```\n\n","tags":["线段树"],"categories":["算法"]},{"title":"太菜辣","url":"/2018/07/29/太菜辣/","content":"\n<h2>动态规划</h2>\n\n​\t基础\n\t\t线性dp、区间dp，主要就是状态方程的设计和状态的转移\n\t\t背包dp，及其扩展 《背包九讲》是很好的学习资料\n\t\t用dp递推概率、期望（dp求期望一般分为两种。一种是dp状态保存的是概率，则期望=概率*花费。另一种是dp状态直接保存期望，这样一般都是逆推的。）\n\t\t树形dp（有些会套个背包dp，有些需要多次树形dp）\n\t\t状态压缩dp\n\t\t数位dp\n\t\tRMQ、二维RMQ\n\t进阶\n\t\tdp优化\n\t\t\t使用数据结构优化，如线段树、树状数组、单调队列、单调栈、维护前缀和 ...\n\t\t\t斜率优化（具有单调性可直接用单调队列或者二分，不具单调性要用平衡二叉树动态维护凸壳）\n\t\t\t四边形不等式优化\n\t\t插头dp\n\n<h2>数据结构</h2>\n\n​\t基础\n\t\t~~队列、栈~~\n\t\t~~树、图的存储、遍历 邻接表和邻接矩阵~~\n\t\t~~单调队列、单调栈~~\n\t\t~~线段树~~、~~树状数组~~\n\t\t~~并查集~~、带权并查集\n\t\t~~堆、优先队列~~\n\t\t~~平衡二叉树~~\n\t\t\tTreap\n\t\t\tSpaly必须会\n\t\t\t[红黑树]\n\t\t\t[AVL树]\n\t\t~~Hash散列表~~\n\t进阶\n\t\t分块数组（分块的思想很强大）\n\t\t二维线段树（就是线段树套线段树，其实还有个[矩形树]）、二维树状数组（就是树状数组套树状数组）\n\t\t树链剖分\n\t\t树套树，如线段树套平衡二叉树、树状数组套平衡二叉树 ...\n\t\tLink-Cut-Tree（解决一类动态树的问题，可以说是树的剖分+Splay）\n\t\t可持久化数据结构，如主席树、可持久化线段树、可持久化字典树、可持久化并查集、可持久化Treap ...\n\n<h2>搜索</h2>\n\n​\t基础\n\t\t~~深搜~~\n\t\t~~广搜~~\n\t\t记忆化搜索（也可以放到dp分类里）\n\t\t~~使用优先队列的广搜~~\n\t\t模拟退火、爬山算法\n\t进阶\n\t\t~~搜索剪枝~~\n\t\t双向广搜\n\t\tA*、IDA*\n\t\t舞蹈链\n\n<h2/>图论</h2>\n\n​\t基础\n\t\t~~最短路（Dijkstra、Spfa、Floyd）~~\n\t\t~~最小生成树（Prim、Kruskal）~~\n\t\t~~拓扑排序~~\n\t\t二分图最大匹配（匈牙利算法）\n\t\t\t二分图的最小顶点覆盖\n\t\t\t~~DAG图的最小路径覆盖~~\n\t\t\t二分图的最大独立集\n\t\t二分图最优匹配（KM算法）\n\t\t二分图多重匹配\n\t\t网络流\n\t\t\t~~最大流（Dinic~~、Sap）\n\t\t\t最小费用最大流\n\t\t\t带上下界的最大流\n\t\t~~有向图强连通分量的Tarjan算法~~\n\t\t最近公共祖先 Tarjan算法实现与RMQ实现各有千秋\n\t\t差分约束系统\n\t\t欧拉回路\n\t\t构造哈密顿回路\n\t\t最大团\n\t\t无向图全局最小割（StoerWagner）\n\t进阶\n\t\t次小生成树\n\t\t最优比率生成树\n\t\t[度限制生成树]\n\t\t[第k小生成树]\n\t\t次短路、第k短路\n\t\t网络流 胡伯涛的《最小割模型在信息学竞赛中的应用》是很好的学习资料\n\t\t\t最大权闭合图\n\t\t\t最大密度子图\n\t\t\t二分图最小点权覆盖集\n\t\t\t二分图最大点权独立集\n\t\t\t区间k覆盖的模型\n\t\t\t平面图网络流\n\t\t无向图的割点和桥、边双联通分量、点双联通分量\n\t\t2-SAT\n\t\t最小树形图\n\t\t一般图匹配\n\t\t生成树计数、最小生成树计数\n\n<h2>数学</h2>\n\n​\t基础\n\t\t数论\n\t\t\t~~欧几里得算法、扩展欧几里得算法~~\n\t\t\t~~乘法逆元~~\n\t\t\t中国剩余定理\n\t\t\t~~欧拉函数~~\n\t\t\t~~欧拉定理~~\n\t\t\t~~Miller_Rabin大素数判定~~\n\t\t\t~~Pollard_rho大整数拆分~~\n\t\t线性代数\n\t\t\t~~矩阵乘法&快速幂~~\n\t\t\t~~高斯消元~~\n\t\t组合数学\n\t\t\t容斥原理\n\t\t\t鸽巢原理\n\t\t\t~~[母函数]~~\n\t\t\t[稳定婚姻问题]\n\t\t概率统计\n\t\t群论\n\t\t\t置换群\n\t\t\tBurnSide引理\n\t\t\tPolya定理\n\t进阶\n\t\t~~莫比乌斯反演~~\n\t\tBSGS\n\t\tFFT\n\t\t......\n\t\t数学的进阶内容太多了\n\n<h2>字符串</h2>\n\n​\t基础\n\t\t~~KMP、扩展KMP~~\n\t\t~~字典树~~\n\t\t最长回文子串的Manacher算法\n\t\t字符串最小/最大表示法\n\t\t许多字符串问题可以用dp甚至贪心求解\n\t进阶\n\t\t~~AC自动机、Trie图~~\n\t\t回文树\n\t\t后缀数组、后缀自动机、后缀树\n\t\t序列自动机\n\n<h2>计算几何</h2>\n\n​\t基础\n\t\t向量的点积、叉积\n\t\t极角排序\n\t\tGraham扫描法\n\t\t二维最近点对\n\t\t最小覆盖圆\n\t\t圆面积并\n\t\t......\n\t\t计算几何的题目各种各样\n\t进阶\n\t\t半平面交\n\t\t旋转卡壳\n\t\t三维凸包\n\t\t......\n\t\t计算几何的题目各种各样\n\n<h2>杂</h2>\n\n​\t博弈\n\t\t一些经典的博弈、SG函数、必胜必败态搜索\n\tSTL\n\t\tvector、set/mutiset、map、queue、stack、deque、string、rope...\n\t排序\n\t\t虽然都用sort但是堆排序的原理还是要知道的\n\t分治\n\t\t普通的分治\n\t\tCDQ分治\n\t\t整体二分\n\t\t树分治\n\t二分、三分\n\t2-points\n\t01分数规划\n\t构造\n\t树的同构（树的hash）\n\t~~莫队算法~~、[树上莫队]\n\t找规律、打表\n\n带[]的感觉没必要学","categories":["算法"]},{"title":"组合数学（QAQ）","url":"/2018/07/27/组合数学/","content":"\n[TOC]\n\n\n\n## 组合\n\n$C_n^r=C_{n-1}^r+C_{n-1}^{r-1}$ 对于第n个元素，不取时，相当于前n-1个元素中取r个，取时，是前n-1个元素中取r-1个。\n\n像个杨辉三角：\n\nC(0,0)\n\nC(1,0)   C(1,1)\n\nC(2,0)   C(2,1)   C(2,2)\n\nC(3,0)   C(3,1)   C(3,2)   C(3,3)\n\n.....        .....        .....\n\n如果要求解C(n,r)，可以先求解出C(n-1,r) 和 C(n-1,r-1)；再运用公式相加即可。很明显，这是一个与[Fib数列](http://www.cnblogs.com/hapjin/p/5571352.html)类似的递归计算。只不过求Fib(n)时，只有一个参数，而这里有二个参数而已。（还是直接求把。。还有用dp的方法）\n\n\n\n## Cayley公式\n\n> 一个完全图K_n有$n^{n-2}$棵生成树，即n个有标号1~n的顶点的树的个数为：$n^{n-2}$\n\n证明：你画个图\n\n> 给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n>2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。\n\n简化为：n个数字可重复的排列到n-2个位置上去。\n\n## 不全相异的排列\n\nn个元素组成的多重集，$a_i$重复$n_i$次，$n=∑_{i=1}^kn_i$,从n个元素中选取r个排列，求不同的排列数。\n\n若r=n ,为：$\\frac{n!}{n_1!n_2!…n_k!}$\n\n## 重复排列和重复组合\n\n排列：在n个不同物体中可重复选取r个排列：$n^r$\n\n组合：…… 组合：$C_{n+r-1}^r$\n\n证明组合：对于1~n的x集合中选取r个元素，然后对应的构造r个y集合中的元素，对应关系为：$y_i=x_i+i-1$，\n\n故……\n\n## 圆周排列\n\n> a、b、c、d，普通排列：24，圆周排列：6 = 24/4 也就说；普通数量/个数 = （n-1）！\n\n\n\n<h2>生成全排列</h2>\n\n### 序数法\n\n任何  $m=a_{n-1}(n-1)!+a_{n-2}(n-2)!+a_{n-3}(n-3)!+……+a_2*2!+a_1*1!$ ①\n\n其中a1 = m%2， a2=(m/2)%3 , a3=(m/2/3)%4 ……直到m/……=0；\n\n那么！a集合（$a_{n-1}~a_1$）共有n！种排列对不对！那么怎样把1,2，……n的一个排列和①联系起来呢？\n\n> 某一个n阶排列的序号是m，那么将m转换为阶乘进制数后，阶乘进制数的第i位就是在i右面比i小的元素个数。例如4阶排列中（从0开始计数的）第19个排列的序号是19，将19转换成阶乘进制数是3010，那么，第一位是0，表明1的右面没有比1小的元素，而第二位是1，则2的右面有一个元素小于2，第三位是0，即3的右面没有比它小的元素，第四位是3，4的右面有3个元素小于它。显然，这个排列是4 2 1 3。\n\n### 字典序法\n\n> 很简单就是1234 、 1243、 1324、 1342、……这样的全排列生成顺序\n\n方法是：eg：上一个排列数为：3421 (p.s.以下的i j k都是下标) 1~n\n\n1. 求$ i = max ( j|a_j-1<a_j ) = 2$\n2. 求$ j = max(k|a_i-1<a_k)= 2$\n3. 交换$a_i-1$ 和 $a_j$ ，得：4321\n4. 将$a_ia_{i+1}a_{i+2}……a_n$逆序：得4123。\n\n[Poj 1833](http://poj.org/problem?id=1833) 可以使用stl中的next_permutation(op1,op2)自动生成字典序的下一个全排列。\n\nop1是放排列的数组首地址a，op2是排列的长度a+n。\n\n到最后一个排列时返回为false。\n\n但是这一题卡输出，用stl的<iterator>中的\n\n```c++\ncopy(a,a+n-1,ostream_iterator<int>(cout,\" \"));\ncout<<a[n-1]<<endl;\n```\n\n参考用法：\n\n```c++\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <iterator>\nusing namespace std;\nint n;\nint main()\n{\n    int a[1300];\n    int m,k;\n    scanf(\"%d\",&m);\n    while(m--)\n    {\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<k;i++)\n            next_permutation(a,a+n);\n        for(int i=0;i<n;i++)\n            printf(\"%d \",a[i]);\n        copy(a,a+n-1,ostream_iterator<int>(cout,\" \"));\n        cout<<a[n-1]<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n### 邻位互换法\n\n计蒜客构造题 [[bellring]](https://nanti.jisuanke.com/t/28877)\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1;\t\t1\n\nn=2;\t\t12 , 21\n\nn=3;\t\t123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n```c++\n/**\n\t本算法的思想也是希望以（12…n）作为n个元素1，2，…，n的第一个排列，\n\t然后按照某种方法，由一个排列（p）＝（p1p2…pn）直接生成下一个排列，\n\t直到全部排列生成完毕为止。\n\n\t以n＝4为例，开始在排列1234的各数上方加一个左箭头“←”，\n\t当一个数上方箭头所指的一侧，相邻的数比该数小时，便称该数处于活动状态。\n\t从排列（p）＝（p1p2…pn）生成下一个排列的算法如下：\n\t（1）若排列（p）＝（p1p2…pn）中无一数处于活动状态，则停止，否则转（2）；\n\t（2）求所有处于活动状态的数中的最大者，设为k，\n\t\tk和它的箭头所指的一侧的相邻数互换位置，转（3）；\n\t（3）令比k大的所有数的箭头改变方向，转（1）。\n*/\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nenum DIR{LEFT=-1,RIGHT=1};\n\n\n/*\t函数功能：判断下标i所指p中元素是否处于活动状态\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir\tin,标记p中每个元素的箭头方向\n *\t\t\ti\tin,待判定元素的下标\n *\t\t\tN\tin,待排列字符的个数\n *\t返回值：\ttrue 表示待判定元素为活动状态，\n *\t\t\tfalse 表示待判定元素处于非活动状态\n */\nbool IsActive(const char *p,const DIR *dir,const int i,const int N)\n{\n\tif(i+dir[i] < 0 || i+dir[i] >= N)\n\t\treturn false;\n\tif(p[i+dir[i]] < p[i])\t//箭头所指一侧相邻的数比该数小\n\t\treturn true;\n\telse return false;\n}\n\n\n/*\t函数功能：找到p中处于活动状态的数中的最大者\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir in,标记p中每个元素的箭头方向\n *\t\t\tN\tin,待排列字符的个数\n *\t返回值：上述最大者的下标，-1表示调用参数有误,N表示没有活动者\n */\nint MaxActive(const char *p,const DIR *dir,const int N)\n{\n\tint k=N;\n\tfor(int i=0;i<N;i++)\n\t\tif(IsActive(p,dir,i,N) && (p[i] > p[k]))\n\t\t\tk = i;\n\treturn k;\n}\n\n\n/*\t函数功能：交换下标i所指元素与其箭头方向所指元素,原位交换\n *\t输入参数：p\tinout,指向n个字符的一个当前排列\n *\t\t\tdir inout,标记p中每个元素的箭头方向\n *\t\t\ti\tin,待交换元素的下标\n *\t返回值：\ttrue 表示交换成功\n *\t\t\tfalse 表示交换失败，失败原因为调用参数有误。\n */\nbool Swap(char *p, DIR *dir, int *i)\n{\n\tif(p == NULL || dir == NULL)\n\t\treturn false;\n\n\n\t//交换相邻的元素；\n\tchar temp = p[*i];\n\tp[*i] = p[*i+dir[*i]];\n\tp[*i+dir[*i]] = temp;\n\n\n\t//元素相关的箭头也得交换\n\tDIR T = dir[*i];\n\tdir[*i] = dir[*i+T];\n\tdir[*i+T] = T;\n\n\n\t*i = *i + T;\t//使*i依旧是未交换前*i所指元素的下标\n\treturn true;\n}\n\n\n/*\t函数功能：上述算法思路第三步，修改所以比k大的元素的箭头方向，原位修改\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir\tinout,标记p中每个元素的箭头方向\n *\t\t\tk\tin,p中处于活动状态的最大者的下标，由MaxActive函数求出\n *\t\t\tN\tin,缓冲区p的长度,也是待排列字符的个数\n *\t返回值：\ttrue 表示函数执行成功\n *\t\t\tfalse 表示函数执行失败，失败原因为调用参数有误\n */\nbool ModifyDir(const char *p,DIR *dir,const int k,const int N)\n{\n\tif(p == NULL || dir == NULL)\n\t\treturn false;\n\tfor(int i=0;i<N;i++)\n\t\tif(p[i]>p[k])\n\t\t\tdir[i] = (dir[i] == LEFT ? RIGHT : LEFT);\n\treturn true;\n}\nint main()\n{\n\tint N =0;\n\tcin>>N;\n\tchar *p = new char [N+1];\n\tDIR *dir = new DIR [N];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tp[i] = '1'+i;\n\t\tdir[i] = LEFT;\n\t}\n\tp[N]='\\0';\n\tint k=0;\n\tfor(int i=0;i<strlen(p)-1;i++)\n            printf(\"%d \",p[i]-'0');\n        printf(\"%d\\n\",p[strlen(p)-1]-'0');\n\tint c = 1;\n\tdo\n\t{\n\t\tk = MaxActive(p,dir,N);\n\t\tif(k == N)\n\t\t\tbreak;\n\t\tSwap(p,dir,&k);\n\t\tModifyDir(p,dir,k,N);\n\t\tfor(int i=0;i<strlen(p)-1;i++)\n            printf(\"%d \",p[i]-'0');\n        printf(\"%d\\n\",p[strlen(p)-1]-'0');\n\n\t} while (1);\n\tdelete []p;\n\tdelete []dir;\n\treturn 0;\n}\n\n```\n\n## 卡特兰数\n\n$$\na_{n}=\\frac{4n-2}{n+1}a_{n-1}\n$$\n\n1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... …\n\n该递推关系的解是：\n$$\na_{n}=\\frac{C_{2n}^{n}}{n+1}   (n=1,2,3,…)\n$$\neg. 出栈的种数与卡特兰数：\n\n**① 对于出栈序列中的每一个数字，在它后面的、比它小的所有数字，一定是按递减顺序排列的。**\n\n**② 给定一个入栈顺序：1  2  3 .... n，一共有多少种合法的出栈顺序？**\n\n答案是 卡特兰数。即一共有：$h(n)=\\frac{C_{2n}^{n}}{n+1}   $ 种合法的出栈顺序。\n\n如果仅仅只需要求出一共有多少种合法的出栈顺序，其实就是求出组合 C(2n,n)就可以了。\n\n## 组合数模板\n\n### n,m大，MOD小\n\n```c++\n#define ll long long  \nconst int N=1000100;  \nconst int MOD=99991;  \nll f[N];  \nll Fp(ll a,ll n)  \n{  \n    ll ans=1;  \n    while(n)  \n    {  \n        if(n&1) ans=(ans*a)%MOD;  \n        a=a*a%MOD;  \n        n>>=1;  \n    }  \n    return ans;  \n}  \nll Lucas(ll a,ll k)  \n{  \n    ll ans=1;  \n    while(a&&k)  \n    {  \n        ll a1=a%MOD;  \n        ll b1=k%MOD;  \n        if(a1<b1) return 0;  \n        ans=ans*f[a1]*Fp(f[b1]*f[a1-b1]%MOD,MOD-2)%MOD;  \n        a/=MOD;  \n        k/=MOD;  \n    }  \n    return ans;  \n}  \nvoid Init()  \n{  \n    f[0]=1;  \n    for(int i=1;i<=MOD;i++)  \n    {  \n        f[i]=f[i-1]*i%MOD;  \n    }  \n}  \nint main()  \n{  \n    Init();  \n    printf(\"%I64d\\n\",Lucas(5,2));  \n}  \n```\n\n### n，m小，mod大\n\n```c++\n#define ll long long  \nconst int MOD=1e9+7;  \nconst int N=1000100;  \nll f[N];  \nll Fp(ll a,ll n)  \n{  \n    ll ans=1;  \n    while(n)  \n    {  \n        if(n&1) ans=ans*a%MOD;  \n        a=a*a%MOD;  \n        n>>=1;  \n    }  \n    return ans;  \n}  \nll C(int n,int m)  \n{  \n    if(n<m) return 0;  \n    return f[n]*Fp(f[m],MOD-2)%MOD*Fp(f[n-m],MOD-2)%MOD;  \n}  \nvoid Init()  \n{  \n    f[0]=1;  \n    for(int i=1;i<N;i++) f[i]=f[i-1]*i%MOD;  \n}  \nint main()  \n{  \n    Init();  \n    printf(\"%I64d\\n\",C(5,2));  \n}  \n```\n\n### n，m很小\n\n```c++\n#define ll long long \nconst int MOD=1000000007;  \nconst int N=20;  \nll C[N][N];  \nint main()  \n{  \n    C[0][0]=C[1][0]=C[1][1]=1;  \n    for(int i=2;i<N;i++)  \n    {  \n        C[i][0]=1;  \n        for(int j=1;j<N;j++)  \n        {  \n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;  \n        }  \n    }  \n}  \n```\n\n\n\n\n\n## 母函数\n\n> 定义：对于序列$a_0,a_1,a_2 … $构造一个函数：\n\n\n$$\nG(x)=a_0+a_1x+a_2x^2+…\n$$\n\n> 则，函数G(x)就是序列$a_0,a_1,a_2…$的母函数。\n\n比如说一个普通型母函数的应用：\n\n有质量为1,2,3的砝码各一枚：\n\n（1）可以称出多少种不同的质量？\n\n解：1个1g砝码可以用1+x表示，1表示不用，x表示用1g砝码\n\n​\t1个2g砝码可用$1+x^2$表示……\n\n​\t1个3g砝码$1+x^3$……\n\n​\t则其母函数$G(x)=(1+x)(1+x^2)(1+x^3)=1+x+x^2+2x^3+x^4+x^5+x^6$\n\n​\tx上的指数表示质量，x前的系数表示搭配种类。\n\n​\t故可以称出6种。\n\n（2）若砝码有无穷个？\n\n解：以2g砝码为例，那么2g砝码可以组成：$(1+x^2+x^4+x^6……)$\n\n因此：$G(x)=(1+x+x^2+x^3+……)(1+x^2+x^4+x^6+……)(1+x^3+x^6+x^9+……)$\n\n\n\n模板：\n\n```c++\n//这个比较快速\n/**\nK对应具体问题中物品的种类数。\nv[i]表示该乘积表达式第i个因子的权重，对应于具体问题的每个物品的价值或者权重。\nn1[i]表示该乘积表达式第i个因子的起始系数，对应于具体问题中的每个物品的最少个数，即最少要取多少个。\nn2[i]表示该乘积表达式第i个因子的终止系数，对应于具体问题中的每个物品的最多个数，即最多要取多少个。\n对于表达式(1+x+x^2)(x^8+x^10)(x^5+x^10+x^15+x^20)，v[3]={1,2,5}，n1[3]={0,4,1}，n2[3]={2,5,4}。\n解题的关键是要确定v、n1、n2数组的值。\n通常n1都为0，但有时候不是这样。\nn2有时候是无限大。\nP是可能的最大指数。\n如果n2为无穷大，那么第二层循环条件j<=n2[i]可以去掉。\na[i],i为指数，内容为系数。\n*/\n//初始化a，因为有last，所以这里无需初始化其他位\n\na[0]=1;\nint last=0;\nfor (int i=0;i<K;i++)\n{\n\tint last2=min(last+n2[i]*v[i],P);//计算下一次的last\n\tmemset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n\tfor (int j=n1[i];j<=n2[i]&&j*v[i]<=last2;j++)//这里是last2\n\t\tfor (int k=0;k<=last&&k+j*v[i]<=last2;k++)//这里一个是last，一个是last2\n\t\t\tb[k+j*v[i]]+=a[k];\n\tmemcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n\tlast=last2;//更新last\n}\n```\n\n例题：[HDU2082](http://acm.hdu.edu.cn/showproblem.php?pid=2082)\n\n示例代码:\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint v[100],n[100],a[100],b[100],last,last2,sum;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        for(int i=0; i<26; i++)\n        {\n            scanf(\"%d\",&n[i]);\n            v[i]=i+1;\n        }\n        a[0]=1;last=0;\n        //初始化a，因为有last，所以这里无需初始化其他位\n        for (int i=0; i<26; i++)\n        {\n            int last2=min(last+n[i]*v[i],50);//计算下一次的last\n            memset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n            for (int j=0; j<=n[i]&&j*v[i]<=last2; j++) //这里是last2\n                for (int k=0; k<=last&&k+j*v[i]<=last2; k++) //这里一个是last，一个是last2\n                    b[k+j*v[i]]+=a[k];\n            memcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n            last=last2;//更新last\n        }\n        int ans=0;\n        for(int i=1; i<=50; i++)\n            if(a[i])   ans+=a[i];\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## 整数拆分\n\n//大整数分解模板\n\n```c++\ntypedef long long ll;\nmap<ll, int>m;\nconst int mod = 10000019;\nconst int times = 50;//测试50次\nll mul(ll a, ll b, ll m)\n//求a*b%m\n{\n    ll ans = 0;\n    a %= m;\n    while(b)\n    {\n        if(b & 1)ans = (ans + a) % m;\n        b /= 2;\n        a = (a + a) % m;\n    }\n    return ans;\n}\nll pow(ll a, ll b, ll m)\n//a^b % m\n{\n    ll ans = 1;\n    a %= m;\n    while(b)\n    {\n        if(b & 1)ans = mul(a, ans, m);\n        b /= 2;\n        a = mul(a, a, m);\n    }\n    ans %= m;\n    return ans;\n}\nbool Miller_Rabin(ll n, int repeat)//n是测试的大数，repeat是测试重复次数\n{\n    if(n == 2 || n == 3)return true;//特判\n    if(n % 2 == 0 || n == 1)return false;//偶数和1\n\n    //将n-1分解成2^s*d\n    ll d = n - 1;\n    int s = 0;\n    while(!(d & 1)) ++s, d >>= 1;\n    //srand((unsigned)time(NULL));在最开始调用即可\n    for(int i = 0; i < repeat; i++)//重复repeat次\n    {\n        ll a = rand() % (n - 3) + 2;//取一个随机数,[2,n-1)\n        ll x = pow(a, d, n);\n        ll y = 0;\n        for(int j = 0; j < s; j++)\n        {\n            y = mul(x, x, n);\n            if(y == 1 && x != 1 && x != (n - 1))return false;\n            x = y;\n        }\n        if(y != 1)return false;//费马小定理\n    }\n    return true;\n}\nll gcd(ll a, ll b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\nll pollard_rho(ll n, ll c)//找到n的一个因子\n{\n    ll x = rand() % (n - 2) + 1;\n    ll y = x, i = 1, k = 2;\n    while(1)\n    {\n        i++;\n        x = (mul(x, x, n) + c) + n;//不断调整x2\n        ll d = gcd(y - x, n);\n        if(1 < d && d < n)\n            return d;//找到因子\n        if(y == x)\n            return n;//找到循环，返回n，重新来\n        if(i == k)//一个优化\n        {\n            y = x;\n            k <<= 1;\n        }\n    }\n}\nvoid Find(ll n, ll c)\n{\n    if(n == 1)return;//递归出口\n\n    if(Miller_Rabin(n, times))//如果是素数，就加入\n    {\n        //factor[index++]=n;\n        m[n]++;\n        return;\n    }\n\n    ll p = n;\n    while(p >= n)\n        p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到\n\n    Find(p, c);\n    Find(n / p, c);\n}\nint main()\n{\n    ll n;srand((unsigned)time(NULL));\n    while(cin >> n)\n    {\n        m.clear();\n        Find(n, rand() % (n - 1) + 1);//这是自己设置的一个数\n        cout<<n<<\" = \";\n        for(map<ll ,int>::iterator it = m.begin(); it != m.end();)\n        {it->first<<\" ^ \"<<it->second;\n            if((++it) != m.end())\n               cout<<\" * \";\n            cout<<\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n## Ferrrs图像\n\n> 一个自上而下的n层各自组成的图像，$m_i$为第i层的格子数。当$m_i≥m{i+1}$，即上层的格子数不少于下层的格子数时，称之为Ferrers图像。\n\n绕$y=-x$旋转得到的图像仍然是Ferrers图像，这样两个称为一对共轭Ferrers图像。\n\n整数的拆分也可以用这个图像来表示。\n\n可根据图像证明定理：整数n拆分成k个数的和的拆分数，与数n拆分成最大数为k的拆分数相等。\n\neg：24=5+5+5+4+3+2 的图像 共轭图像的话，24=6+6+5+4+3，\n\n可以看出，24拆分成6个数的最大数=24拆分成最大数为6的拆分数\n\n\n\n……\n\n## 指数型母函数\n\n在不全相异的排列那一p里面，r=n可以容易求出，但是当r一般情况的时候就复杂了。\n\n对于给定的数列$a_0,a_1,a_2,…,a_n,…，$通常称为形式幂级数，即：\n$$\nΣ_{n=0}^∞\\frac{a_n}{n!}x^n=a_0+a_1x+\\frac{a_2}{2!}x^2+\\frac{a_3}{3!}x^3+…+\\frac{a_n}{n!}x^n+…\n$$\n为数列$a_0,a_1,a_2,…,a_n,…$的指数型母函数，这里规定0！=1。\n\n这样，对于一个多重集，其中$a_i$重复了$n_i$次，$n=∑_{i=1}^nn_i$，从n个元素中取r个元素排列，不同的排列数对应的指数型母函数：\n$$\nG(x)=(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_1}}{n_1!})(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_2}}{n_2!})+…+(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_k}}{n_k!})\n$$\n例题：有1,2,3,4,个数字组成的五位数中，要求数1出现次数不超过2次，但不能不出现；2不超过1次；3最多3次，可以不出现；4出现次数为偶数。求满足上述条件的数的个数。\n\n解：$C_r$对应的指数型母函数为\n$$\nG(x)=(\\frac{x}{1!}+\\frac{x^2}{2!})(1+\\frac{x}{1!})(1+\\frac{x}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!})(1+\\frac{x^2}{2!}+\\frac{x^4}{4!})\n$$\n解得x上指数为5的系数为215。\n\np.s.4的偶数次之所以到$x^4$是因为再多也不满足条件啊。\n\nHDU[排列组合](http://acm.hdu.edu.cn/showproblem.php?pid=1521) 题\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\ntypedef long long LL;\nusing namespace std;\nconst int N = 11;\ndouble c1[N],c2[N];     //注意类型\nLL fac[N];\n \nvoid cal()\n{\n    fac[0]=1;           //0!会被用到\n    for(int i=1;i<N;i++)\n        fac[i]=i*fac[i-1];\n}\n \nint main()\n{\n    cal();\n    int n,r;\n    while(~scanf(\"%d%d\",&n,&r))\n    {\n        memset(c1,0,sizeof(c1));\n        memset(c2,0,sizeof(c2));\n \n        c1[0]=1;\n        int num;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&num);\n            if(num==0) continue;\n            for(int j=0;j<=r;j++)\n            {\n                for(int k=0;k<=num&&k+j<=r;k++)\n                {\n                    c2[k+j]+=c1[j]/fac[k];\n                }\n            }\n            for(int j=0;j<=r;j++)\n            {\n                c1[j]=c2[j];\n                c2[j]=0;\n            }\n        }\n\n        printf(\"%.0lf\\n\",c1[r]*fac[r]);\n    }\n \n\treturn 0;\n}\n```\n\n\n\n## 递推关系\n\n\n\n## 斐波那契\n\n\n\n## 斯特林数 Stiring\n\n###第一类斯特林数\n\n> 有正负，其绝对值是包含n个元素的集合分作k个环排列的方法数目\n\n递推公式：\n\n​\t\t\t\t\t\t\tS（n，0）= 0\n\n​\t\t\t\t\t\t\tS（1，1） = 1\n\n​\t\t\t\t\t\t\tS（n+1，k）= S（n，k-1) + nS（n，k）\n\n第三个式子是这样的，n+1个元素分成k个环，可以理解为前n个元素分成k-1个环，第n+1个自成一个环的种类数量，加上前n个元素分成k个环，第n+1个元素插入到第i个元素左边。\n\n### 模板\n\n```c++\n//第一类Stirling数s(p,k)计数的是把p个对象排成k个非空循环排列的方法数\n#define ll long long\nconst int N=1000;\nconst int MOD=1e9+7;\nll s[N][N];//存放要求的Stirling数\nvoid Init()\n{\n    s[1][1]=1;\n    for(int i=2;i<N;i++)\n    {\n        for(int j=1;j<=i;j++)\n        {\n            s[i][j]=(s[i-1][j-1]+(i-1)*s[i-1][j])%MOD;\n        }\n    }\n}\n```\n\n\n\n### 第二类斯特林数\n\n> 将包含n个元素的集合划分为正好k个非空子集方法的数目\n\n递推公式：\n\n​\t\t\t\t\t\t\tS（n，k）= 0（n<k ||k==0）\n\n​\t\t\t\t\t\t\tS（n，n） = S（n，1） = 1 \n\n​\t\t\t\t\t\t\tS（n，k）= S（n-1，k-1) + kS（n-1，k）\n\n第三个式子是这样的，n个元素分成k集合，可以理解为前n-1个元素分成k-1个集合，第n个自成一个集合的种类数量，加上前n-1个元素分成k个环，第n个元素在k个集合中选择放到里面去。\n\n### 模板\n\n```c++\n/*\n第二类Stirling数S(p,k)计数的是把p元素集合划分到k个不可区分的盒子里且没有空盒子的划分个数。\n*/\n#define ll long long\nconst int N=1000;\nconst int MOD=1e9+7;\nll s[N][N];//存放要求的Stirling数\nvoid Init()\n{\n    s[1][1]=1;\n    for(int i=2;i<N;i++)\n    {\n        for(int j=1;j<=i;j++)\n        {\n            s[i][j]=(s[i-1][j-1]+j*s[i-1][j])%MOD;\n        }\n    }\n}\n```\n\n","tags":["数学"]},{"title":"2018暑期训练题解","url":"/2018/07/08/2018暑期集训/","content":"\n##<h2>7.7 [BAPC 2014 Preliminary](https://www.jisuanke.com/contest/1403)</h2> \n\nA. 思维题，重点在于当剩余的n<k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那n=1，当然ok。\n\nB. dijkstra最短路一下\n\nD. Dp，结束后想了一下，dp[i]表示第i层停下来的所有怨气，dp[i]=min(dp[i],dp[j] + val(j->i)) ,（j<i）i之前电梯停在j层，然后从j直接到i 的话，加上这一部分的怨气就好了val，而valij的怨气就是i的前缀和加上若每一层都停的怨气，再减去了j层停下来的人消失的这部分怨气。\n\n<img src=\"\\mdpicture\\20180712A.jpg\" alt=\"20180712A\"/>\n\nF. 飞行航道 水\n\nJ. 找单词，八方找，正反找。看了题解 好像是先判断了一下回文减少了一下长度？\n\n\n\n##<h2>7.10 [ Benelux Algorithm Programming Contes](https://www.jisuanke.com/contest/1404)</h2> \n\nB.  最少按下的按钮次数\n\n用bfs，时间小于0，变成0，大于3600，变为3600。vis[i]记录时间为i的最少步骤数目。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nint n,sum;\nint a[20],vis[3610];\nstruct node{\n    int val;\n    int step;\n};\nvoid solve()\n{\n    queue<node>q;\n    node temp,tp;\n    temp.val=0;\n    temp.step=0;\n    q.push(temp);\n    vis[0]=0;\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        for(int i=0;i<n;i++)\n        {\n            int cur=temp.val+a[i];\n            if(cur<0) cur=0;\n            else if(cur>3600) cur=3600;\n            if(vis[cur]==-1)\n            {\n                vis[cur]=temp.step+1;\n                tp.step=temp.step+1;\n                tp.val=cur;\n                q.push(tp);\n            }\n        }\n    }\n}\nint main()\n{\n    int t;\n\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&sum);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        memset(vis,-1,sizeof(vis));\n        solve();\n        for(int i=sum;i<=3600;i++)\n            if(vis[i]!=-1)\n        {\n            printf(\"%d %d\\n\",vis[i],i-sum);\n            break;\n        }\n    }\n    return 0;\n}\n\n```\n\nG. 水\n\nI. 计算组成n的最小的两个斐波那契数a b，其中按b小来排，且a<b\n\n\n\n<img src=\"\\mdpicture\\180710I.jpg\" alt=\"180710I.jpg\"/>\n\n由上可知，先计算出最大的两个相邻数相加小于n的地方，设为x，y（x<y），然后xa+yb=n,从b=1开始求满足条件的a，且a<b。\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[1000];\nconst int INF=0x3f3f3f3f;\nint main()\n{\n    a[0]=a[1]=1;\n    for(int i=2;i<44;i++)\n        a[i]=a[i-1]+a[i-2];\n    //小于1e9的斐波那契\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        int loc;\n        //计算出最大的两个相邻数相加小于n的地方\n        for(int i=43;i>=1;i--)\n        {\n            if((a[i]+a[i-1])<=n)\n            {\n                loc=i;break;\n            }\n        }\n        int ai_1;\n        while(loc>0)\n        {\n            for(int i=1;i*a[loc]<n;i++)\n            {\n                if((n-a[loc]*i)%a[loc-1]==0&&(n-a[loc]*i)/a[loc-1]<=i)\n                {\n                    ai_1=i;goto out;\n                }\n            }\n            loc--;\n        }\n    out:\n        printf(\"%d %d\\n\",(n-a[loc]*ai_1)/a[loc-1],ai_1);\n    }\n    return 0;\n}\n```\n\nJ. 把迷宫设置大，然后从中间模拟\n\n\n\n##<h2>7.12</h2>\n\nB. 最小路径覆盖，网络流，最大流\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5010;\nconst int M=3000010;\nconst int inf=0x3f3f3f3f;\nstruct Edge\n{\n    int v,cap,nxt;\n}e[M];;//邻接表要开边数的两倍\nint src,des,dis[N],head[N],ecnt;  //memset dis,head-1 ecnt=0,src=0,des=2*n+1;\nint n,m;\nvoid Addedge(int u,int v,int w)\n{\n    e[ecnt].v=v;\n    e[ecnt].cap=w;\n    e[ecnt].nxt=head[u];\n    head[u]=ecnt++;\n    e[ecnt].v=u;\n    e[ecnt].cap=0;\n    e[ecnt].nxt=head[v];\n    head[v]=ecnt++;\n}\nbool Bfs()\n{\n    queue<int>q;\n    q.push(src);\n    memset(dis,-1,sizeof(dis));\n    dis[src]=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();\n        for(int i=head[u];~i;i=e[i].nxt)\n        {\n            int v=e[i].v;\n            if(e[i].cap>0&&dis[v]==-1)\n            {\n                dis[v]=dis[u]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[des]>=0;\n}\nint Dfs(int u,int a)\n{\n    if(u==des) return a;\n    for(int i=head[u];~i;i=e[i].nxt)\n    {\n        int v=e[i].v,t=0;\n        if(e[i].cap>0&&dis[v]==dis[u]+1&&(t=Dfs(v,min(a,e[i].cap))))\n        {\n            e[i].cap-=t;\n            e[i^1].cap+=t;\n            return t;\n        }\n    }\n    dis[u]=-1;\n    return 0;\n}\nint Dinic()\n{\n    int ans=0;\n    while(Bfs())\n    {\n        int t=0;\n        while(t=Dfs(src,inf)) ans+=t;\n    }\n    return ans;\n}\nint main()\n{\n    int num,u,v;\n    ecnt=0;\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&num);\n    src=0;des=2*num+1;\n    for(int i=1;i<=num;i++)\n        Addedge(0,i,1);\n    for(int i=num+1;i<=2*num;i++)\n        Addedge(i,2*num+1,1);\n    for(int i=1;i<=num;i++)\n    {\n        scanf(\"%d\",&u);\n        while(u--)\n        {\n            scanf(\"%d\",&v);\n            Addedge(i,num+v+1,1);\n        }\n    }\n    n=num+2;\n    printf(\"%d\\n\",num-Dinic());\n    return 0;\n}\n```\n\n\n\nE. 求次短路是否等于最短路长。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#define MAXN (10000 + 10)\n#define INF (5000*5000*2)\nusing namespace std;\n\nstruct edge\n{\n    int to, cost;\n    edge(int tv = 0, int tc = 0):\n        to(tv), cost(tc) {}\n};\ntypedef pair<int,int> P;\nint N, R;\nvector<edge> graph[MAXN];\nint dist[MAXN];     //最短距离\nint dist2[MAXN];    //次短距离\n\nvoid solve()\n{\n    fill(dist, dist+N, INF);\n    fill(dist2, dist2+N, INF);\n    //从小到大的优先队列\n    //使用pair而不用edge结构体\n    //是因为这样我们不需要重载运算符\n    //pair是以first为主关键字进行排序\n    priority_queue<P, vector<P>, greater<P> > Q;\n    //初始化源点信息\n    dist[0] = 0;\n    Q.push(P(0, 0));\n    //同时求解最短路和次短路\n    while(!Q.empty())\n    {\n        P p = Q.top();\n        Q.pop();\n        //first为s->to的距离，second为edge结构体的to\n        int v = p.second, d = p.first;\n        //当取出的值不是当前最短距离或次短距离，就舍弃他\n        if(dist2[v] < d) continue;\n        for(unsigned i = 0; i < graph[v].size(); i++)\n        {\n            edge &e = graph[v][i];\n            int d2 = d + e.cost;\n            if(dist[e.to] > d2)\n            {\n                swap(dist[e.to], d2);\n                Q.push(P(dist[e.to], e.to));\n            }\n            if(dist2[e.to] > d2 && dist[v] < d2)\n            {\n                dist2[e.to] = d2;\n                Q.push(P(dist2[e.to], e.to));\n            }\n        }\n    }\n}\nint main()\n{\n    int A, B, D,K;\n    scanf(\"%d%d%d\", &N, &R,&K);\n    while(K--)\n        scanf(\"%d\",&A);\n    for(int i = 0; i < R; i++)\n    {\n        scanf(\"%d%d%d\", &A, &B, &D);\n        graph[A-1].push_back(edge(B-1, D));\n        graph[B-1].push_back(edge(A-1, D));\n    }\n    solve();\n    if(dist2[N-1]==dist[N-1])\n        printf(\"yes\\n\");\n    else\n        printf(\"no\\n\");\n    return 0;\n}\n```\n\nF. 求大数因子个数，用大数分解求出质因数\n\n7-12[German Collegiate Programming Contes...](https://www.jisuanke.com/contest/1405) \n\n7-14 [https://www.jisuanke.com/contest/1444](qq://txfile/#) \n\n7-17[The 2018 ACM-ICPC Chinese Collegiate...](https://www.jisuanke.com/contest/1406) \n\n7-19[ German Collegiate Programming Contes...](https://www.jisuanke.com/contest/1407) \n\n##<h2>7.23 [多校1 ](http://acm.hdu.edu.cn/contests/contest_show.php?cid=802)</h2> \n\n1001 [ Maximum Multiple](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&cid=802)  水。\n\n1002 [ Balanced Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=6299) 贪心题。对于左右括号的情况分类，然后按照规则排序。具体见代码。\n\n```c++\n#include <bits/stdc++.h>\n#pragma comment(linker, “/STACK:1024000000,1024000000”)\nusing namespace std;\nstruct node{\n    int left_no,right_no,yes;\n    node()\n    {\n        left_no=right_no=yes=0;\n    }\n};\nbool cmp(node a,node b)\n{\n    if(a.left_no>=a.right_no&&b.left_no<=b.right_no)//左少右多 + 左多右少 a前面\n        return true;\n    if(a.left_no<=a.right_no&&b.left_no>=b.right_no) //左少右多 + 左多右少 b前面\n        return false;\n    if(a.left_no<=a.right_no&&b.left_no<=b.right_no) //左少右多+左少右多 谁的左面数量多谁放前面\n        return a.left_no>b.left_no;\n    return a.right_no<b.right_no; // 左多右少 左多右少 谁的右边多谁放后面\n\n}\nchar s[5000010];\nint main()\n{\n    int n,t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        vector<node>a(n);\n        int len;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",s);\n            len=strlen(s);\n            long long left=0,right=0,ans=0;\n            for(int j=0;j<len;j++)\n            {\n                if(s[j]=='(')\n                    left++;\n                else\n                {\n                    if(left>0)  left--,ans++;\n                    else    right++;\n                }\n            }\n            a[i].left_no=left;\n            a[i].right_no=right;\n            a[i].yes=ans;\n        }\n        sort(a.begin(),a.end(),cmp);\n        long long left=0,right=0,ans=0;\n        for(int i=0;i<n;i++)\n        {\n            ans+=a[i].yes;\n            if(left>=a[i].right_no)\n                left-=a[i].right_no,ans+=a[i].right_no;\n            else\n                ans+=left,left=0;\n            left+=a[i].left_no;\n        }\n        printf(\"%lld\\n\",ans*2);\n    }\n    return 0;\n}\n```\n\n1003 [ Triangle Partition](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=802) 水。 对x,y按照升序排序再每次取三个就好了。\n\n1004 [  Distinct Values](http://acm.hdu.edu.cn/showproblem.php?pid=6301) 给你一个n，一个q，表示数列中有n个元素，q个区间询问，每次一个[l,r]，表示此区间内的数字不能有重复，要求输出最小字典序的。用set维护一下区间内的数字出现情况就好了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int,int>a,pair<int,int>b)\n{\n    if(a.first==b.first)\n        return a.second>b.second;\n    return a.first<b.first;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,q,l,r;\n        scanf(\"%d%d\",&n,&q);\n        set<int>val;\n        vector<pair<int,int> >p;\n        vector<int>x(n+5);\n        for(int i = 1 ;i <= n ; i++)\n            p.push_back( make_pair(i,i) );\n        for(int i=1;i<=n;i++)\n            val.insert(i);\n        for(int i=1;i<=n;i++)\n            x[i]=1;\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d\",&l,&r);\n            p.push_back(make_pair(l,r));\n        }\n        sort(p.begin(),p.end());\n        int left=1,cur=1;\n        set<int>::iterator it,bef;\n        for(int i=0;i<p.size();i++)\n        {\n            while(left<p[i].first)\n                val.insert(x[left++]);\n            for(it=val.begin();it!=val.end()&&cur<=p[i].second;)\n            {\n                x[cur++]=*it;\n                int s=*it;\n                it++;\n                val.erase(s);\n            }\n        }\n        for(int i=1;i<=n-1;i++)\n            printf(\"%d \",x[i]);\n        printf(\"%d\\n\",x[n]);\n    }\n    return 0;\n}\n```\n\n1007 [ Chiaki Sequence Revisited](http://acm.hdu.edu.cn/showproblem.php?pid=6304)  数学题。\n\n```c++\n#include <bits/stdc++.h>\n#define mst(a,b) memset(a,b,sizeof(a))\n#define ALL(x) x.begin(),x.end()\n#define pii pair<int,int>\n#define eps 1e-4\ninline long long lowbit(long long x){return x&-x;}\nconst int N = 1e6+10;\nconst long long mod = (long long)1e9+7;\nconst int INF=0x3f3f3f3f;\nconst long long LINF=(1LL<<62);\ntypedef long long LL;\ntypedef unsigned long long ULL;\n//#define LOCAL\nconst double PI = acos(-1.0);\nusing namespace std;\n\nLL n,inv2,p[63];\n\nLL q_pow(LL base, LL b){\n  LL res = 1;\n  while(b){\n    if(b&1) res = res*base%mod;\n    base = base*base%mod;\n    b>>=1;\n  }\n  return res;\n}\nbool check(LL x){   //为什么要这么写呢，看上面打的表，除以每个2^i就可以得出2^i有多少个，这样子加完就得到对应的a[x]是多少。\n  LL temp = 0;\n  for(int i = 0; i <= 62; i++){\n    temp += x/p[i];\n    if(temp >= n-1) return true;\n  }\n  return temp >= n-1;\n}\nLL cal(LL x){\n  LL temp = 0;\n  for(int i = 0; i <= 62; i++) temp += x/p[i];\n  return temp;\n}\nint main(){\n#ifdef LOCAL\n    freopen(\"out.txt\", \"w\", stdout);\n#endif // LOCAL\n    inv2 = q_pow(2,mod-2);  //2的逆元，等下等差数列求和的时候要用\n    p[0] = 1;\n    for(int i = 1; i <= 62; i++) p[i] = p[i-1]*2; //预处理2^i\n    int T; scanf(\"%d\",&T);\n    while(T--){\n      scanf(\"%lld\",&n);\n      if(n==1){\n        printf(\"1\\n\");\n        continue;\n      }\n      LL l = max(1LL,n/2-30), r = min(n,n/2+30), mid, pos;\n      while(l<=r){\n        mid = (l+r)>>1;\n        if(check(mid)){   //二分找n对应的a[n]；\n          pos = mid;      //pos即为a[n]\n          r = mid-1;\n        }else l = mid+1;\n      }\n      LL res = pos-1, now = 0;  //这里pos-1是因为在a[n]位置的n可能不是刚好符合2^i，所以要找前面一个，前面一个必定是符合2^i个的。\n      for(int i = 0; i <= 62; i++){\n        if(p[i]>res) break;\n        LL temp = res/p[i];\n        temp %= mod;\n        now = (now+p[i]%mod*(temp+1)%mod*temp%mod*inv2%mod)%mod;  //等差数列求和，不要忘记Mod\n      }\n      now = (now+(n-1-cal(res)%mod)%mod*pos%mod)%mod;  //剩下这里就是那些不完整的a[n]了\n      printf(\"%lld\\n\",(1+now)%mod);\n    }\n    return 0;\n}\n```\n\n1011 [ Time Zone](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1011&cid=802)  水。\n\n\n\n##<h2>7.25  [ 多校二](http://acm.hdu.edu.cn/contests/contest_show.php?cid=803)</h2> \n\n1003 [Cover](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=803)  没看题，听了题解，大概是给你一个无向图，让你求至少要多少一笔画才能把它画完。一笔画有两种情况，一种是欧拉路，一种是欧拉回路，也就是说，对于图中的所有点，度数为奇数的要么是0（回路），要么是2（一个进来的点，一个出去的点）。所以要把一个图构造成欧拉路/回路的话，就意味着要在图中x个奇数度的点中连接x/2条边，然后在对于新生成的图，找欧拉路，然后再把添上去的x/2条边删去，分成的几条路就是一笔画的结果。\n\n1004 [ Game](http://acm.hdu.edu.cn/showproblem.php?pid=6312)  水题，先手必赢。先手可以取或者不取1。\n\n1005 [ Hack It](http://acm.hdu.edu.cn/showproblem.php?pid=6313)  不知所措的构造题。要求是构造出一个n*n(n<=2000)的矩阵，你可以在里面填黑点，但是你不能让任意四个黑点组成一个矩形（四个角），要求是至少包含85000个黑点。老实说，我无法理解构造方法。\n\n1007 [Naive Operations](http://acm.hdu.edu.cn/showproblem.php?pid=6315) 线段树 [题解](http://xheartbeat.top/2018/07/29/HDU%206315%20Naive%20Operations/)\n\n1010[ Swaps and Inversions](http://acm.hdu.edu.cn/showproblem.php?pid=6318)  水题。数逆序数对，再乘以min(x,y)即可。这里我发现逆序数对数有x个，就可以通过交换相邻数字x次使得它不存在逆序数。\n\n用归并排序可以得到逆序数对个数。\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nlong long sum;\nint a[500005];\nint temp[500005];\nvoid sort2(int a[],int l,int mid,int r)\n{\n    int i=l,j=mid+1,k=0;\n    while(i<=mid&&j<=r)\n    {\n        if(a[i]<=a[j])\n        {\n            temp[k++]=a[i++];\n        }\n        else\n        {\n            temp[k++]=a[j++];\n            sum+=mid-i+1;\n        }\n    }\n    while(i<=mid)  temp[k++]=a[i++];\n    while(j<=r)    temp[k++]=a[j++];\n\n    for(int i=l,k=0; i<=r; k++,i++)\n        a[i]=temp[k];\n}\n\nvoid sort1(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)/2;\n        sort1(a,l,mid);\n        sort1(a,mid+1,r);\n        sort2(a,l,mid,r);\n    }\n}\nint main()\n{\n    int n;\n    long long x,y;\n    while(scanf(\"%d%lld%lld\",&n,&x,&y)!=EOF)\n    {\n        sum=0;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort1(a,0,n-1);\n        printf(\"%lld\\n\",sum*min(x,y));\n    }\n    return 0;\n}\n```\n\n\n\n##<h2>7.24 [ The 2018 ACM-ICPC China JiangSu Prov..](https://www.jisuanke.com/contest/1408)</h2> \n\nA. [Plague Inc](https://nanti.jisuanke.com/t/28865) 水题暴力，遍历每个点到感染源的路求最远。\n\nB. [Array](https://nanti.jisuanke.com/t/28866)  n个数，k对逆序数，求可能的方案数。这是一道DP 。\n\nD.  [Persona5](https://nanti.jisuanke.com/t/28868) 公式题\n\nE.  [Massage](https://nanti.jisuanke.com/t/28869) 公式结论题\n\nI. [T-shirt](https://nanti.jisuanke.com/t/28873)  ////////////////////////////////////\n\nJ.  [Set](https://nanti.jisuanke.com/t/28874) 结论是(n+1)!-1，用java写\n\nK.  [Road](https://nanti.jisuanke.com/t/28875) 连通图，删去尽可能多的路，使得每个城市到第0号城市的最短路长度不变，求可能的方案数量。\n\n用floyd先求出每个城市之间的最短路，然后对每条0~i城市的最短路，判断0~j城市的距离加上i到j的原始距离是否还和最短路相等，相等的话，在j城市上的最短路径+1。最后将他们乘起来。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=350;\nconst long long MOD=1e9+7;\nint dist[maxn],g[maxn][maxn],f[maxn][maxn],N;\nlong long road[maxn];\nlong long floyd()\n{\n    long long ans=1;\n    memset(road,0,sizeof(road));\n\n    for (int k=0;k<N;k++)\n        for (int i=0;i<N;i++)\n            for (int j=0;j<N;j++)\n                if (i!=k&&i!=j&&j!=k)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    g[0][0]=0;\n    for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n        if(i!=j&&g[0][i]+f[i][j]==g[0][j])\n    {\n        road[j]++;\n    }\n    for(int i=1;i<N;i++)\n        if(road[i])\n            ans=(ans*road[i])%MOD;\n    return ans;\n\nint main()\n{\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        memset(g,INF,sizeof(g));\n        string s;\n        for(int i=0;i<N;i++)\n        {\n            cin>>s;\n            for(int j=0;j<s.size();j++)\n            {\n                if(s[j]=='0')\n                    f[i][j]=g[i][j]=INF;\n                else\n                \tf[i][j]=g[i][j]=s[j]-'0';\n            }\n        }\n        printf(\"%lld\\n\",floyd());\n    }\n    return 0;\n}\n\n```\n\n##<h2>7.26 [ Nordic Collegiate Programming Contes...](https://www.jisuanke.com/contest/1410)<h2> \n\nA. [Adjoin the Networks](https://nanti.jisuanke.com/t/28876)  回头补把。\n\nB. [Bell Ringing](https://nanti.jisuanke.com/t/28877)  用生成全排列的邻位互换法：（具体方法解释可以看排列组合的文章）\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1; 1\n\nn=2; 12 , 21\n\nn=3; 123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint A[15];\nint dir[15];\n\nvoid print()\n{\n    for(int i=1;i<n;i++)\n        printf(\"%d \",A[i]);\n    printf(\"%d\\n\",A[n]);\n}\nbool IF_Active(int i) //判断是否活跃（前面的数字比它小就是活跃）\n{\n    if(i+dir[i]<=0||i+dir[i]>n)\n        return false;\n    if(A[i+dir[i]]<A[i])\n        return true;\n    return false;\n}\n\nint MAX_Active() //找到最大的活跃数字\n{\n    int id=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(IF_Active(i)&&A[id]<A[i])\n            id=i;\n    }\n    return id;\n}\nint Swap(int i) //交换最大的活跃数字和它前面的那个数字，注意方向也要交换\n{\n    int c=A[i];\n    A[i]=A[i+dir[i]];\n    A[i+dir[i]]=c;\n\n    c=dir[i];\n    dir[i]=dir[i+c];\n    dir[i+c]=c;\n\n    return i+c;\n}\nvoid UPdate(int index)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(A[index]<A[i])\n            dir[i]=-dir[i];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        A[i]=i;\n        dir[i]=-1;\n    }\n    print();\n    \n    while(1)\n    {\n        int id=MAX_Active();\n        if(id==n+1) break;\n        id=Swap(id);\n        UPdate(id);\n        print();\n    }\n    return 0;\n}\n```\n\nC. [Cryptographer's Conundrum](https://nanti.jisuanke.com/t/28878) 水\n\nD. [Disastrous Downtime](https://nanti.jisuanke.com/t/28879) 水，取最大的ai~ai+1000范围内的数字个数即可。\n\nE.[Entertainment Box](https://nanti.jisuanke.com/t/28880)  n个节目，k个录像带，给出每个节目的播放时间，求最多能录几个节目。\n\n用multiset维护当前正在录制的所有节目的结束时间，二分找到最接近下一个要录的节目的起始时间且小于起始时间的录像带，把这个录像带中的r替换成下一个要录的节目，cnt++，如果没有找到并且集合的size还不到k个的话，就直接把r放进去，cnt++。最后输出cnt。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstruct node\n{\n    int l,r;\n} nn[N];\nbool cmp(node a,node b)\n{\n    if(a.r==b.r)\n        return a.l<b.l;\n    return a.r<b.r;\n}\n\nmultiset<int>q;\nmultiset<int>::iterator pos;\nint main()\n{\n    int n,k;\n    int cnt=0;\n    int i;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d\",&nn[i].l,&nn[i].r);\n    sort(nn,nn+n,cmp);\n    for(i=0; i<n; i++)\n    {\n        if(q.empty())\n        {\n            cnt++;q.insert(nn[i].r);\n            continue;\n        }\n        if(*q.begin()>nn[i].l)\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n            continue;\n        }\n        pos=q.upper_bound(nn[i].l);\n        pos--;\n        if(*pos<=nn[i].l)\n        {\n            cnt++;\n            q.erase(pos);\n            q.insert(nn[i].r);\n        }\n        else\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    return 0;\n}\n```\n\nG.[Goblin Garden Guards](https://nanti.jisuanke.com/t/28882)  给n个哥布林的位置（x，y），给出m个圆，对于每一个圆，输出最大的不在圆内的哥布林数目。\n\n由于哥布林的位置是整数，那么对于圆，可以预处理出距离圆心0~r范围内的x最大偏差值和y的最大偏差值，如果哥布林的x，y与圆心的偏差值有一者在最大偏差值之外，就cnt++。\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nstruct point\n{\n    int x,y;\n}p[100010];\nbool cmp(point a,point b)\n{\n    return a.y<b.y;\n}\nvector<int>v[100010];\nvector<int>d[110];\nvoid init()\n{\n    for(int r=1;r<=100;r++)\n        for(int i=0;i<=r;i++)\n            d[r].push_back((int)floor(sqrt(1.0*r*r-i*i)));\n}\nint main()\n{\n    init();\n    int g,m,x,y,r;\n    scanf(\"%d\",&g);\n    for(int i=0;i<g;i++)\n        scanf(\"%d%d\",&p[i].x,&p[i].y);\n    sort(p,p+g,cmp);\n    for(int i=0;i<g;i++)\n        v[p[i].x].push_back(p[i].y);\n    scanf(\"%d\",&m);\n    int ans=0;\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&r);\n        int left=max(0,x-r),right=min(10000,x+r);\n        for(int dd=left;dd<=right;dd++)//横坐标\n        {       \n            int c=abs(dd-x);\n            int yl=max(0,y-d[r][c]),yr=min(10000,y+d[r][c]);\n            int pos1=lower_bound(v[dd].begin(),v[dd].end(),yl)-v[dd].begin();\n            int pos2=upper_bound(v[dd].begin(),v[dd].end(),yr)-v[dd].begin();\n            v[dd].erase(v[dd].begin()+pos1,v[dd].begin()+pos2);\n            ans+=pos2-pos1;\n        }\n    }\n    printf(\"%d\\n\",g-ans);\n    return 0;\n}\n```\n\n##<h2>7.28 teemo场</h2>\n\nA. [Teemo's bad day](https://nanti.jisuanke.com/t/29203)  裸的并查集，判断两个数字的根是否一样，不一样就cnt++，顺便union即可。（好久没写并查集find都写炸）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[500010],b[500010];\nint fa[100010];\nint Find(int x)\n{\n    if(fa[x]==x)return x;\n    return fa[x]=Find(fa[x]);\n}\nvoid Union(int p,int q)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n        fa[rp]=rq;\n}\nvoid init(int n)\n{\n    for(int i=0;i<100010;i++)\n        fa[i]=i;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,cnt=0;\n        scanf(\"%d\",&n);\n        init(n);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d\",&b[i]);\n            if(a[i]==b[i]) continue;\n            if(Find(a[i])!=Find(b[i]))\n            {\n                cnt++;Union(a[i],b[i]);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n```\n\nB. [Teemo's hard problem](https://nanti.jisuanke.com/t/29204) 题目意思是给你一个数列，你可以任意反转[L,R]，使得这个数列的非递减序列最长。\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint a[2010];\nint pre[2010];//1的前缀长度（包括自己）\nint suf[2010];//2的后缀长度（包括自己）\nint dp[2005][2005][4];//[i,j]中以k结尾的最长非递增序列长度\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        memset(pre,0,sizeof(pre));\n        memset(suf,0,sizeof(suf));\n        memset(dp,0,sizeof(dp));\n        for(int i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&a[i]);\n            if(a[i]==1)pre[i]=pre[i-1]+1;\n            else pre[i]=pre[i-1];\n        }\n        for(int i=n; i>=1; i--)\n        {\n            if(a[i]==2)suf[i]=suf[i+1]+1;\n            else suf[i]=suf[i+1];\n        }\n        for(int i=1; i<=n; i++)\n        {\n            dp[i][i][a[i]]=1;\n            for(int j=i+1; j<=n; j++)\n            {\n                if(a[j]==1)\n                {\n                    dp[i][j][1]=max(dp[i][j-1][1],dp[i][j-1][2])+1;\n                    dp[i][j][2]=dp[i][j-1][2];\n                }\n                else if(a[j]==2)\n                {\n                    dp[i][j][1]=dp[i][j-1][1];\n                    dp[i][j][2]=dp[i][j-1][2]+1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1; i<=n; i++)\n            for(int j=i; j<=n; j++)\n            {\n                ans=max(ans,pre[i-1]+max(dp[i][j][1],dp[i][j][2])+suf[j+1]);\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nC. [Teemo's tree problem](https://nanti.jisuanke.com/t/29228) 又是一个dp \n\nF. [Teemo's dream](https://nanti.jisuanke.com/t/29245)  没看题\n\nG .[Teemo's convex polygon](https://nanti.jisuanke.com/t/29294)  将多边形对角线相连，其对角线最多被分割成多少段？\n$$\nmax=(n^4-6*n^3+17*n^2-24*n)/12\n$$\nJ. [Teemo's formula](https://nanti.jisuanke.com/t/29324) 结论是$Σ_{k=1}^nk^2C_n^k=2^{n-2}n(n+1)$\n\nK.[Teemo's reunited](https://nanti.jisuanke.com/t/29326) 求的是其他所有的点到某一点的距离和的最小值，就是曼哈顿距离。[HDU 4311Meeting point-1](http://acm.hdu.edu.cn/showproblem.php?pid=4311) \n\n> 这题也是用“分治”，虽说题目要求的是曼哈顿距离，但是我们为什么真的就要一步到位的求呢，可以横纵坐标分开求，先x排序，然后遍历一遍，求出横坐标的距离，然后y排序，遍历一遍求出坐标的距离加在刚才求得的x的距离上，就是曼哈顿距离了。\n>\n> 这里有一个非常巧妙但是其实很显而易见的东西：假定现在我们已经按x排好序了分别是ABC三个点，那么C到AB的距离和是|C-A|+|C-B|，又因为已经排序了，那么绝对值可以去掉，得(C-A)+(C-B)，那么就是2*C-(A+B)，也就是说一个点到它前面的点的距离的和等于它前面的点的个数乘以它的自己再减去前面所有点的和，到这里你是不是想到求一个数列的和的时候我们遍历一遍数列就得到了，通过这个方法我们用O(n)就得到了一个点到它前面的点的距离和，然后再倒着遍历一遍数列用相似的思想把它到它后面的点的距离再加上就行了。\n>\n> 还有一种也是分开x,y排序求和，不过可以这么做：先直接求出最前面的点到所有点的距离，然后依次遍历数列，通过后面一个点跟前面一个点的关系，找出差值相减，就是了。不明白的话仔细想想或者画图看看。\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1000000000000007\nusing namespace std;\nstruct node{\n\tlong long x,y;\n\tlong long sum;\n}a[100005];\nbool cmp1(node a,node b)\n{\n\treturn a.x<b.x;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.y<b.y;\n}\nint main(){\n\tint t,n;\n\tscanf(\"%d\",&n);\n\tlong long ans=INF;\n\tmemset(a,0,sizeof(0));\n\tfor(int i=0;i<n;i++)  \n        scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tsort(a,a+n,cmp1);\n\tlong long sum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum=i*a[i].x-sum;\n\t\tsum+=a[i].x;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].x;\n\t\tsum+=a[i].x;\n\t}\n\tsort(a,a+n,cmp2);\n\tsum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum+=i*a[i].y-sum;\n\t\tsum+=a[i].y;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].y;\t\t\t\n\t\tsum+=a[i].y;\n\t\tans=min(ans,a[i].sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n##<h2>7.29</h2>\n\nA.  [Coins](https://nanti.jisuanke.com/t/28960) 概率dp....不懂不懂\n\nB. [The Difference](https://nanti.jisuanke.com/t/28961) 水题\n\nD. [Fence Building](https://nanti.jisuanke.com/t/28963)  一个圆，一个圆的内接n边形，连接多边形对角线，求整个圆被分割成几块。\n\nOEIS大法好。。。\n\n```c++\n#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<time.h>\n#include<stdlib.h>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\n#define MAXN 10000000\nusing namespace std;\ntypedef long long ll;\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)   //a,b都为正整数\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    for(int cs=1;cs<=t;cs++)\n    {\n        scanf(\"%lld\",&n);\n        n%=MOD;\n        ll temp1=n,temp2=(temp1*n)%MOD,temp3=(temp2*n)%MOD,temp4=(temp3*n)%MOD;\n        temp1=(temp1*18ll)%MOD,temp2=(temp2*23ll)%MOD,temp3=(temp3*6ll)%MOD;\n        ll temp=inverse(24ll,MOD);\n        //printf(\"%lld %lld %lld %lld %lld\\n\",temp1,temp2,temp3,temp4,temp);\n        ll fz=(temp4-temp3+MOD)%MOD;\n        fz=(fz+temp2)%MOD;\n        fz=(fz-temp1+24+MOD)%MOD;\n        ll ans=(fz*temp)%MOD;\n        printf(\"Case #%d: %lld\\n\",cs,ans);\n    }\n    return 0;\n}\n```\n\nG.[The Mountain](https://nanti.jisuanke.com/t/28966)  水\n\nI. [A Possible Tree](https://nanti.jisuanke.com/t/28968) 给你一棵树，q个询问，问的是x->y路径上的异或和为val , 问你最多有几个询问是真的？\n\n带权并查集。由于异或的特点，假设某个点为根，比如0，那么比如2->5的异或值，就是2->1的异或值和5->1的异或值异或一下。所以我们用yihuo[i]来表示i到源点的异或和。如果两个数的源点已经一样，那么判断一下val==yihuo[i]^yihuo[j]即可，若是不一样，就把他们union，同时yihuo[rootp]=yihuo[p]^yihuo[q]^val。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint fa[100010],yihuo[100010];\nint Find(int x)\n{\n    if(x!=fa[x])\n    {\n        int tmp=fa[x];\n        fa[x]=Find(fa[x]);\n        yihuo[x]^=yihuo[tmp];\n        return fa[x];\n    }\n    return x;\n}\n\nbool Union(int p,int q,int val)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n    {\n        fa[rp]=rq;\n        yihuo[rp]=yihuo[p]^yihuo[q]^val;\n        return true;\n    }\n    if((yihuo[p]^yihuo[q])!=val)\n        return false;\n    return true;\n}\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        fa[i]=i;yihuo[i]=0;\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,k,u,v,val;\n        scanf(\"%d%d\",&n,&k);\n        init(n);\n        for(int i=0;i<n-1;i++)\n            scanf(\"%d%d\",&u,&v);\n        int flag=1,ans=0;\n        for(int i=0;i<k;i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&val);\n            if(!Union(u,v,val)&&flag)\n            {\n                flag=0;\n                ans=i;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nK.   [Sum of the Line](https://nanti.jisuanke.com/t/28970) 给你一个n，分析之后发现求的是所有gcd(n,i)=1（i<=n）的数的平方和。\n\n用容斥，先用公式$\\frac{n(n+1)(2n+1)}{6}$求出1~n的平方和，然后筛出sqrt(n)内的素数，并求出n的所有质因数，然后对于质因数的乘积tot，如果质因数的个数是奇数，就加上$tot^2*(1^2+2^2+3^2……+(n/tot)^2)$，是偶数就减去。\n\n或者用莫比乌斯反演来做\n\n（补莫比乌斯反演做法）\n\n```c++\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 998244353\n#define MAXN 10000\nusing namespace std;\ntypedef long long ll;\nll pri[10010],num=0;\nbool vis[10010];\nvector<ll>pr;\nvoid init()\n{\n    ll i,j;\n    for(i=2;i<MAXN;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAXN&&i%pri[j]!=0;j++)\n            vis[i*pri[j]]=true;\n    }\n}\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    init();\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        pr.clear();\n        ll xs=inverse(6ll,MOD);\n        ll tot=(((n*(n+1))%MOD*(2*n+1))%MOD*xs)%MOD;\n        ll temp=n;\n        for(int i=0;i<num;i++)\n        {\n            if(temp%pri[i]==0)\n            {\n                pr.push_back(pri[i]);\n                while(temp%pri[i]==0)\n                    temp/=pri[i];\n            }\n        }\n        if(temp>1)pr.push_back(temp);\n        int len=pr.size();\n        ll ans=0;\n        for(int i=1;i<(1<<len);i++)\n        {\n            int cnt=0;//有几个1\n            ll d=1;\n            for(int j=0;j<len;j++)\n            {\n                int temp=i>>j&1;\n                if(temp==1)\n                {\n                    cnt++;d=d*pr[j];\n                }\n            }\n            ll gs=n/d;\n            ll g=(((gs*(gs+1))%MOD*(2*gs+1))%MOD*xs)%MOD;\n            if(cnt%2==0)ans=(ans-((d*d)%MOD*g)%MOD+MOD)%MOD;\n            else ans=(ans+((d*d)%MOD*g))%MOD;\n            }\n        }\n        printf(\"%lld\\n\",(tot-ans+MOD)%MOD);\n    }\n    return 0;\n}\n```\n\n##<h2>7.30 多校三</h2>\n\nA. [  Problem A. Ascending Rating](http://acm.hdu.edu.cn/showproblem.php?pid=6319) 输入n,m,k,p,q,r,MOD,表示一个长度为n的数列，给你前k个数字，（后面的要根据递推式自己写），然后m表示一个[l,l+m]的区间，从l=1开始，在这个区间中有两个值，一个是MAX，一个是CNT，起始都为0，从区间的第一个数开始扫，如果扫到的数字比MAX大，让MAX=ai，并且CNT++。求的是$A =\\sum_{i=1}^{n-m+1}{MAX_i 异或i}$ , $B=\\sum_{i=1}^{n-m+1}{CNT_i 异或i}$\n\n思路是用一个单调队列从最后一个区间往前倒着维护，如果队列为空，则直接放入ai，若ai>=队首元素，则将队列中的元素全部弹出，同时将ai放入，若ai小于队首元素，则将队尾中小于ai的元素弹出，将ai放入队尾中，每一个区间的cnt值即为队列中元素的个数，而MAX值则为队首元素。如果队首元素的位置不在下一个区间范围内，则弹出。注意STL的双端队列会被卡，这里可以用数组直接模拟。（可以补一个正向写的，但是我WA到死，主要就是用单调栈来维护每一个数字右边的第一个比他大的位置，最后一个栈里的数的stack设为n+1，然后从右到左，dp[n-1]=1，dp[i]=dp[stack[i]]+1，………然后单调队列维护区间最大值）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nlong long a[10000010];\nlong long que[20000010];\nint main()\n{\n    int t,n,m,k,p,q,r,MOD;\n    int size,front,rear;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        size=0;\n        front=rear=1e7+5;\n        scanf(\"%d%d%d%d%d%d%d\",&n,&m,&k,&p,&q,&r,&MOD);\n        for(int i=1;i<=k;i++)\n            scanf(\"%lld\",&a[i]);\n        for(int i=k+1;i<=n;i++)\n            a[i]=(1LL*p*a[i-1]+1LL*q*i+r)%MOD;\n        long long MAX=0,CNT=0;\n        for(int i=n;i>=1;i--)\n        {\n            if(size==0)\n            {\n                que[front]=i;size=1;\n            }\n            else\n            {\n                if(a[que[front]]<=a[i])\n                {\n                    front=rear=1e7+5;\n                    que[front]=i;\n                    size=1;\n                }\n                else\n                {\n                    while(size>0&&a[que[rear]]<=a[i])\n                        size--,rear--;\n                    que[rear+1]=i;rear++;\n                    size++;\n                }\n            }\n            if(i<=n-m+1)\n            {\n                MAX+=a[que[front]]^i;\n                CNT+=size^i;\n                while(que[front]>=(i+m-1))\n                    front++,size--;\n            }\n        }\n        printf(\"%lld %lld\\n\",MAX,CNT);\n    }\n    return 0;\n}\n```\n\nC. [ Problem C. Dynamic Graph Matching](http://acm.hdu.edu.cn/showproblem.php?pid=6321)  在一个图中，任意k条不共点的边可以构成一个匹配。给你n个点，有q个操作，操作分两种，一种是+ u v，在u v中间连线，一个是- u v，删边，两点之间可以连多条路线。问你对于每一次操作，k=1,2，…… n/2的匹配方案分别有多少？\n\n思路：树状DP。（补）\n\nD. [Problem D. Euler Function](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=804)  水。求φ(n)为合数的第k个数。根据规律可看到，从第7个开始就都是偶数。\n\nF. [ Problem F. Grab The Tree](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1006&cid=804) 水。很容易看出sum=0时平手，否则就是先手赢。\n\nL. [ Problem L. Visual Cube](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1012&cid=804)  水。直接写。\n\n## <h2>7.31 [ACM-ICPC 2015 Shenyang Preliminary C...](https://www.jisuanke.com/contest/1466)</h2> \n\nB.  [Best Solver](https://nanti.jisuanke.com/t/29121)  （补）\n\n\n\nC. [Minimum Cut](https://nanti.jisuanke.com/t/29122)  （补）\n\nF.  [Fang Fang](https://nanti.jisuanke.com/t/29125)  水。\n\nJ.  [Jesus Is Here](https://nanti.jisuanke.com/t/29129) 有、搞的题。把递推关系算出来……表示不想再写一编代码，就那个意思反正。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 530600414\ntypedef long long ll;\nll sum[210000];\nll num[210000];\nll pre[210000],suf[210000],ans[210000];\nvoid init()\n{\n    sum[1]=5;sum[2]=8;num[1]=1;num[2]=2;\n    for(int i=3;i<=201314;i++)\n    {\n        sum[i]=(sum[i-1]+sum[i-2])%MOD;\n        num[i]=(num[i-1]+num[i-2]+1)%MOD;\n        if(i%2==1)sum[i]=(sum[i]+5)%MOD;\n        else sum[i]=(sum[i]+3)%MOD;\n    }\n    pre[1]=5;pre[2]=11;suf[1]=5;suf[2]=13;\n    for(int i=3;i<=201314;i++)\n    {\n        ll x;\n        if(i%2==1)x=5;else x=3;\n        pre[i]=((((num[i-1]+1)*(sum[i-2]+x))%MOD+pre[i-2])%MOD+pre[i-1])%MOD;\n        suf[i]=((((num[i-2]+1)*(sum[i-1]+x))%MOD+suf[i-2])%MOD+suf[i-1])%MOD;\n    }\n    ans[1]=5;ans[2]=16;\n    for(int i=3;i<=201314;i++)\n    {\n        ll x;\n        if(i%2==1)x=5;else x=3;\n        ll temp1=((num[i-1]+1)*suf[i-2])%MOD;\n        ll temp2=((num[i-2]+1)*pre[i-1])%MOD;\n        ll temp3=(((num[i-1]+1)*(num[i-2]+1))%MOD*x)%MOD;\n        ans[i]=((((temp1+temp2)%MOD+temp3)%MOD+ans[i-2])%MOD+ans[i-1])%MOD;\n    }\n}\nint main()\n{\n    init();\n    int t,n;\n    scanf(\"%d\",&t);\n    for(int kase=1;kase<=t;kase++)\n    {\n        scanf(\"%d\",&n);\n        if(n<5)printf(\"0\\n\");\n        else\n        {\n            n-=4;\n            printf(\"Case #%d: %lld\\n\",kase,ans[n]);\n        }\n    }\n    return 0;\n}\n```\n\nM.  [Largest Point](https://nanti.jisuanke.com/t/29131)  写的我脑子有点不清楚了……\n\n# <h1>8.1多校4</h1>\n\nB. [Harvest of Apples](http://acm.hdu.edu.cn/showproblem.php?pid=6333)  题意是从n个苹果里面选取最多m个苹果的方案数量。m、n、t<=1e5\n\n思路：莫队分块+组合预处理，原来莫队中的区间[l,r]在这里用n、m代替了。\n\n接下来是推公式部分：\n\nS(n,m)表示$\\sum_{i=1}^n\\sum_{j=1}^mC_i^j$\n\n我们可以得出$S(n,m)=S(n,m-1)+C_n^m$ ,-------①\n\n又因为有$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$（组合数学的一个基本公式），因此又可以推出：$S(n,m)=S(n-1,m)+S(n-1,m-1)=2S(n-1,m)-C_{n-1}^m$--------②\n\n有了①②两个式子，我们就可以得到S(n,m)和S(n-1,m)、S(n+1,m)、S(n,m-1)、S(n,m+1)之间的关系，先预处理出n！和相应的需要的逆元，然后把输入的查询分块，按照代码中所示的“套路”排序法，排一排，然后对于每个n，m开始处理，分四种情况这样。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nll multi[N];\nll devide[N];\nll ans[N];\nll pos[N];\nll er;\nint D=(int)sqrt(1.0*N);\nstruct node{\n    int n,m;\n    int id;\n    bool operator <(const node& p) const{\n        if(pos[n]==pos[p.n]) return m<p.m;\n        return n<p.n;                           //N大的排前面\n    }\n};\nnode qujian[N];\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll n)//乘法逆元,n取模\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\nvoid init(int n)\n{\n    multi[0]=1;\n    multi[1]=1;\n    for(int i=2;i<=n;i++)\n        multi[i]=multi[i-1]*i%MOD;\n    devide[n]=mod_inverse(multi[n],MOD);\n    for(int i=n-1;i>=0;i--)\n        devide[i]=devide[i+1]*(i+1)%MOD;\n}\nll cal(int n,int m)\n{\n    return ((multi[n]*devide[m])%MOD*devide[n-m])%MOD;\n}\nvoid operation1(int n,int m,ll &res)\n{\n    res=((2ll*res)%MOD-cal(n,m)%MOD+MOD)%MOD;\n}\nvoid operation2(int n,int m,ll &res)\n{\n    res=(res+cal(n-1,m))%MOD*er%MOD;\n}\nvoid operation3(int n,int m,ll &res)\n{\n    res=(res+cal(n,m+1))%MOD;\n}\nvoid operation4(int n,int m,ll &res)\n{\n    res=(res-cal(n,m)+MOD)%MOD;\n}\nint main()\n{\n    init(100000);\n    int t;\n    int n,m;\n    er=mod_inverse(2ll,MOD);\n    scanf(\"%d\",&t);\n    for(int i=1;i<=t;i++)\n    {\n        scanf(\"%d%d\",&qujian[i].n,&qujian[i].m);\n        qujian[i].id=i;\n        pos[i]=i/D;\n    }\n    sort(qujian+1,qujian+t+1);\n    int curl,curr;\n    curl=curr=1;\n    ll res=2;\n    for(int j=1;j<=t;j++)\n    {\n        while(curl<qujian[j].n) operation1(curl++,curr,res);\n        while(curr<qujian[j].m) operation3(curl,curr++,res);\n        while(curl>qujian[j].n) operation2(curl--,curr,res);\n        while(curr>qujian[j].m) operation4(curl,curr--,res);\n        ans[qujian[j].id]=res;\n    }\n    for(int i=1;i<=t;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\nD. [Nothing is Impossible](http://acm.hdu.edu.cn/showproblem.php?pid=6335) 水，按占比来算就好。\n\nE. [Matrix from Arrays](http://acm.hdu.edu.cn/showproblem.php?pid=6336)  讲一下思想吧，再写一边代码的话可能又要写一万年。对于这个块的计算，比如这个块的四个角顺时针分别叫：a,b,c,d，将(0,0)点到(i,j)点的里面所有的数字和叫做pre，那么就是pre[b]-pre[b]-pre[d]+pre[a]。分析一下就可以得到，对于所有的无限大的矩阵，他都是重复某个特定的矩阵来的。这些矩阵有以下长度规律：（L为给定数组的长度，L从1~10，）\n\nlen[1]=1,len[2]=4,len[3]=3,len[4]=8,len[5]=10,len[6]=12,len[7]=14,len[8]=16,len[9]=18,len[10]=20。\n\n矩阵为n*n。\n\n故对于给定的L和数组可以先处理出重复矩阵的样子，然后再进行分块和的计算。\n\n关于分块和的计算（pre），把块内完整的小矩阵的个数算出来求个和，除了完整的还有不完整的，不完整的其实也好看，就是矩阵最左边和最上面的部分，也用pre算出来就行。\n\nJ. [Let Sudoku Rotate](http://acm.hdu.edu.cn/showproblem.php?pid=6341)  数独，有一个16*16的数独 数独内的数字从0~E，一开始数独是完美的，可是有个人逆时针旋转了数独中的某几块（4x4），导致数独不完美了，给你这个旋转后的数独，要求还原他至少要再旋转几步？\n\ndfs+剪枝。\n\n写出下列几个操作：\n\n1. 顺时针旋转4*4的方块；\n2. 判断每行的总和是否都为120；\n3. 判断每行和每列的元素是否都不重复；\n4. dfs，由于一行块有4个分块，因此四重循环，同一个x分别对应y的起始：0，4，8，12，循环+1表示旋转次数+1，如果在2、3的判断中都满足这写要求，说明可以进行下一个x+4（起始行）块的旋转操作dfs，step+本次旋转的操作（i，j，k，l四重循环），要是不满足还是要继续。当x==16或者是step比当前已知的最小ans要大的时候都可以return。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst int INF = 0x3f3f3f3f;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nchar m[20][20];\nchar cop[4][4];\nint ans=64;\nvoid print()\n{\n    printf(\"\\n\");\n    for(int i=0;i<16;i++,printf(\"\\n\"))\n        for(int j=0;j<16;j++)\n            printf(\"%c\",m[i][j]);\n    printf(\"\\n\");\n}\nint rol(int x,int y)\n{\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            cop[i][j]=m[x+3-j][y+i];\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            m[i+x][j+y]=cop[i][j];\n}\nbool sum(int x)\n{\n    for(int j=x;j<x+4;j++)\n    {\n        int temp=0;\n        for(int i=0;i<16;i++)\n        {\n            temp=temp+((m[x][i]>='0'&&m[x][i]<='9')?(m[x][i]-'0'):(m[x][i]-'A'+10));\n        }\n        if(temp!=120) return false;\n    }\n    return true;\n}\nbool multi(int x)\n{\n    int vis[16]={0};\n    for(int j=x;j<x+4;j++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<16;i++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n\n    for(int i=0;i<16;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int j=0;j<=x+3;j++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n    return true;\n}\nvoid dfs(int x,int step)\n{\n    if(step>ans) return;\n    if(x==16)\n    {\n        ans=min(ans,step);return;\n    }\n    for(int i=0;i<4;i++,rol(x,0))\n    for(int j=0;j<4;j++,rol(x,4))\n    for(int k=0;k<4;k++,rol(x,8))\n    for(int l=0;l<4;l++,rol(x,12))\n    {\n        if(!(sum(x)&&multi(x))) continue;\n        dfs(x+4,step+i+j+k+l);\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        getchar();\n        for(int i=0;i<16;i++)\n            scanf(\"%s\",m[i]);\n        ans=64;\n        dfs(0,0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nK. [Expression in Memories](http://acm.hdu.edu.cn/showproblem.php?pid=6342)  表达式中有一些是用？代替的，问你这个表达式能否符合正确的要求，能的话输出任意成立的表达式（不含？）。注意细节，一开始对“+0?”单独扫，？填运算符号。完了之后就按顺序扫，判断是否符合。（注意细节，容易wa）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        string a;\n        cin>>a;\n        int flag=1;\n        int len=a.size();\n        for(int i=2;i<len;i++)\n        {\n            if(a[i]=='?'&&a[i-1]=='0'&&(a[i-2]=='+'||a[i-2]=='*'))\n                a[i]='+';\n        }\n        for(int i=0;i<len&&flag;i++)\n        {\n            if(a[i]=='?') {a[i]='1';continue;}\n            if(a[i]=='+'||a[i]=='*')\n            {\n                if(i==len-1||i==0) flag=0;\n                else if(a[i+1]=='+'||a[i+1]=='*') flag=0;\n            }\n            else if(a[i]=='0')\n            {\n                if(i==0&&len>1&&(a[i+1]!='+'&&a[i+1]!='*'&&a[i+1]!='?')) {flag=0;continue;} \n                if((i-1)<0||a[i-1]=='+'||a[i-1]=='*') \n                    if(i+1<len)\n                    {\n                        if(a[i+1]=='?') a[i+1]='+'; \n                        else if(a[i+1]!='+'&&a[i+1]!='*') flag=0;\n                    }\n            }\n        }\n        if(!flag)\n            printf(\"IMPOSSIBLE\\n\");\n        else\n            cout<<a<<endl;\n    }\n    return 0;\n}\n```\n\nL. [ Graph Theory Homework](http://acm.hdu.edu.cn/showproblem.php?pid=6343) 水，得到结论：根号函数的性质：$\\sqrt{a+b+c+…}\\le\\sqrt{a}+\\sqrt{b}+\\sqrt{c}+…​$\n\n\n\n"},{"title":"飞行员配对(最大流模板)","url":"/2018/05/11/2018-05-11-飞行员配对(最大流模板)/","content":"\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MAXN = 201;\n\nint g[MAXN][MAXN];        //残留网络，初始为原图\nint flow[MAXN][MAXN];\nint nodeNum;            //节点总数量\nint pre[MAXN];\n\n//bfs找增广路\nint bfs(const int &s, const int &t)\n{\n    int que[201],p,q,v,i;\n    for (i=0;i<=nodeNum+1;i++)\n        pre[i]=-1;\n    que[0]=s;\n    pre[s]=s;\n    p=0,q=1;\n    while(p<q)\n    {\n        v=que[p++];\n        for(i=0;i<=nodeNum+1;i++)\n            if (pre[i]==-1&&(flow[v][i]<g[v][i]||flow[i][v]>0))\n            {\n                pre[i]=v;\n                que[q++]=i;\n                if (i==t) return 1;\n            }\n    }\n    return 0;\n}\n\n//修改残留矩阵和增广路\nvoid track_back(const int &s, const int &t)\n{\n    int i=t,v,MIN=INF;\n    while (i!=s)\n    {\n        v = pre[i];\n        if (flow[v][i]<g[v][i])\n        {\n            if(MIN>g[v][i]-flow[v][i])\n                MIN=g[v][i]-flow[v][i];\n        }\n        else if (flow[i][v]>0)\n        {\n            if(MIN>flow[i][v])\n                MIN=flow[i][v];\n        }\n        i=v;\n    }\n    i=t;\n    while (i!=s)\n    {\n        v = pre[i];\n        if (flow[v][i]<g[v][i])\n            flow[v][i]+=MIN;\n        else if (flow[i][v]>0)\n            flow[i][v]-= MIN;\n        i = v;\n    }\n}\n\n//返回 从节点s到节点t的最大流\nint max_flow(const int &s, const int &t)\n{\n    while (bfs(s,t))\n        track_back(s,t);\n    int res=0,i;\n    for (i=0;i<=nodeNum+1;i++)\n        if (i!=s)res+=flow[s][i];\n    return res;\n}\n\nint main()\n{\n    int m,b,e,c;\n    scanf(\"%d%d\",&m,&nodeNum);\n    memset(g,0,sizeof(g));\n    memset(flow,0,sizeof(flow));\n    while (scanf(\"%d%d\",&b,&e))\n    {\n        if(b==-1&&e==-1) break;\n        g[e][b]=1;\n    }\n    for(int i=1;i<=m;i++)\n        g[i][nodeNum+1]=1;\n\n    for(int i=m+1;i<=nodeNum;i++)\n        g[0][i]=1;\n\n    printf(\"%d\\n\",max_flow(0,nodeNum+1));\n    return 0;\n}\n\n\n```\n\n","tags":["网络流"],"categories":["算法"]},{"title":"我依赖成瘾了的你","url":"/2018/04/24/2018-04-24-我依赖成瘾了的你/","content":"\n<img src=\"\\mdpicture\\他.jpg\" alt=\"我依赖成瘾了的你，想念你，记挂你\">\n\n他回家了，从今天开始，我们两个人就是半个小时的异地恋。\n\n在一起的这一年，我们吵过无数次的架，觉得自己委屈，觉得他没有那么爱自己了，为什么他要乱发脾气，好多好多的想起来就头疼的回忆，也后悔过很多，怎么两个人在一起久了，就变得有些小单调了呢？我还是很爱吃醋，不喜欢你身边围着太多的人，又希望你玩的开心，又希望你也能时时刻刻想起我，只做我一个人的小可爱。啊，变得自私又刻薄。还是心甘情愿。\n\n也是他让我的大学生活与众不同。我们看很多很多部电影，吃不一样的美食，在家里烧烤到烟雾缭绕，煮着火锅，吃着水泡饭就着酱瓜，还有黄豆酱，没钱的时候买了一大筒挂面，连吃几天的雪菜面，我们去不同的地方，做不同的事情，走在街上，光明正大的牵你的手，晚上一起骑车回家，路过跳着广场舞的大妈，在网吧过夜，在车上睡觉，和他在一起，做了数不清的稀奇古怪的事情，又是那么意义非凡，一桩桩一件件，是我的最美好的一年。尤其是在寒冷的夜晚相拥而眠，比较遗憾的是某人是屁精，总是放很臭很臭的屁给我闻，早上醒来第一眼看到的人，晚上最后说晚安的人，三百六十五天过的飞快，我都反应不过来。\n\n中午下了他的车，看着车屁股离开，心里陈杂，然后又匆匆赶去教室，没有想他的机会，直到晚上选修课看了那部电影《托斯卡纳艳阳下》，在漆黑的教室里挂不住的眼泪流下来，赶紧擦去了，怕身旁的人看到，是没有泪点的片段，可我却看得感同身受，“我一个人住这么大的房子干什么呢”，又羡慕着他们的幸福。然后一回到出租屋就哭了，想念是一件止不住的事。然后哭的停不下来才发现，他是我活到这把年纪，头一个，让我想到掉眼泪的人。\n\n哭泣的时候，我有好多好多好多好多的话想要说，想要写下来，听他讲了那么多之后，写到这里，我就不知道下一句应该接什么了。\n\n他真的很好很好，我没有选错人。\n\n“想要告诉身边每一个人，我在和你谈恋爱”\n\n“我心里是真的好爱你”\n\n“在一起不觉得什么，只是平常，一分开好难受”\n\n“一直想要你不要难过，想要你自己一个人好好过”\n\n“可是我都劝不住自己的心，空荡荡的”\n\n“既然分开，以后一定会给你幸福的生活，每天都抱在一起睡，肉贴肉”\n\n“想要什么我都会给你”\n\n“谢谢你一直以来忍受我那么久的坏脾气”\n\n“或许是因为知道你很爱我，不会离开我，才那么肆无忌惮”\n\n“可是真的离开了，真想以前要对你好一点”\n\n“我现在一无所有，什么都不能给你，不能一直这样”\n\n“以后我们的日子还很长很长，我要让你在以后的日子里，都很幸福”\n\n“坐自行车，在出租房，那不是幸福”\n\n“我要和你有一个完整的家”\n\n“晚安，我的老婆”\n\n恩，老公是生命之光，晚安，我的小可爱。\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"网络流 【待续】","url":"/2018/04/23/2018-04-23-网络流/","content":"\n例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：\n\n<img src=\"\\mdpicture\\水管流量.jpg\" alt=\"水管流量最大该是多少呢\"/>\n\n## 网络流的定义\n\n在有向图G=（V,E）中：\n\n1、有唯一的一个源点S（入度为0：出发点）\n\n2、有唯一的一个汇点（出度为0：结束点）\n\n3、图中的每条弧（u,v）都有一个非负的容量c（u,v）\n\n满足上述条件的图G称为网络流图。\n\n记为：G=（V,E,C）\n\n<!--more-->\n\n### 可行流\n\n每条管道中可以通过的流量。\n\n<img src=\"\\mdpicture\\可行流.JPG\" alt=\"可行流\"/>\n\n### 最大流\n\n在所有的可行流中，流量最大的一个流。（最大流可能不止一个）\n\n解决最大流的问题常用到Ford-Fulkerson方法（在此方法下，存在着若干种不同时间复杂度下的实现）\n\n#### Ford-Fulkerson和Edmonds-Karp\n\n1、残存网络\n\n第一个图是流网络，边上的12/16,12指的是流量，16是容量。\n\n第二个图是残存网络，可能会存在一对相反的边，如刚刚12/16在残存网络中，体现为 v1->s = 12，s->v1 = 16-12。与流网络中对应的边代表的是该边的残余容量，流网络中不存在的边是一条反向的已有流量边，这部分流量**可以通过回流减少**。（残存网络中值为0的边不画出）\n\n<img src=\"\\mdpicture\\残余网络.JPG\" alt=\"残存网络和流网络对比\">\n\n2、增广路径\n\n假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量<容量，注意，是严格的<,而不是<=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。\n\n3、方法\n\n我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。**当找不到增广路的时候，当前的流量就是最大流**，这个结论非常重要。\n\n<!--而Ford-Fulkerson方法和Edmonds-Karp的区别就是在寻找增广路时，前者是随便找一条，dfs深搜，后者找一条节点数最少的，bfs广搜-->\n\n寻找增广路的时候我们可以简单的从源点开始做bfs，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。\n\n4、代码\n\n```c++\nint c[MAX][MAX];  //残留网络容量\nint pre[MAX];  //保存增广路径上的点的前驱顶点\nbool visit[MAX];\n\nint Ford_Fulkerson(int src,int des,int n){   //src：源点 des：汇点 n：顶点个数\n     int i,_min,total=0;\n     while(true){\n         if(!Augmenting_Path(src,des,n))return total; //如果找不到增广路就返回，在具体实现时替换函数名\n         _min=(1<<30);\n         i=des;\n         while(i!=src){   //通过pre数组查找增广路径上的边，求出残留容量的最小值\n             if(_min>c[pre[i]][i])_min=c[pre[i]][i];\n             i=pre[i];\n         }\n         i=des;\n         while(i!=src){    //再次遍历，更新增广路径上边的流值\n             c[pre[i]][i]-=_min;\n             c[i][pre[i]]+=_min;\n             i=pre[i];\n         }\n         total+=_min;     //每次加上更新的值\n     }\n}\n\n```\n\n```c++\nint dfs(int u,int t,int f)\n{\n\tif(u==t)\n\t  return f;\n\t  used[u]=1;\n\tfor(int i=0;i<g[u].size();i++)\n\t{\n\t\tEdge &e=g[u][i];\n\t\tint v=e.to;\n\t\tif(!used[v]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(v,t,min(e.cap,f));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{\n\tint res=0,f;\n\twhile(1)\n\t{\n\t\tf=INF;\n\t\tmemset(used,0,sizeof(used));\n\t\tint d=dfs(s,t,f);\n\t\tif(d<=0)\n\t\t\tbreak;\n\t\tres+=d;\n\t}\n\treturn res;\n}\n```\n\n```c++\n--*\n    Ford-fulkerson最短扩充路\n    调用前输入残余矩阵 g[][]\n    直接调用max_flow(源点, 汇点) 返回最大流\n    \n    注意初始化：nodeNum（节点总数量）\n    注意节点标号： 0 - (nodeNum-1)\n*/\n//pku1273\n#include <stdio.h>\n#include <string.h>\n\nconst int MAXN = 201;\n\nint g[MAXN][MAXN];        //残留网络，初始为原图\nint flow[MAXN][MAXN];\nint nodeNum;            //节点总数量\nint pre[MAXN];\n\n//bfs找增广路\nint bfs(const int &s, const int &t)\n{\n    int que[201], p, q, v, i;\n    for (i = 0; i < nodeNum; i++)\n        pre[i] = -1;  \n    que[0] = s;\n    pre[s] = s;\n    p = 0, q = 1;\n    while (p < q)\n    {\n        v = que[p++];\n        for (i = 0; i < nodeNum; i++)\n            if (pre[i] == -1 && (flow[v][i] < g[v][i] || flow[i][v] > 0))\n            {\n                pre[i] = v;\n                que[q++] = i;\n                if (i == t) return 1;\n            }\n    }\n    return 0;\n}\n\n//修改残留矩阵和增广路\nvoid track_back(const int &s, const int &t)\n{\n    int i = t, v, min = 0x7fffffff;\n    while (i != s)\n    {\n        v = pre[i];\n        if (flow[v][i] < g[v][i])\n        {\n            if(min > g[v][i] - flow[v][i])\n                min = g[v][i] - flow[v][i];\n        }\n        else\n            if (flow[i][v] > 0)\n            {\n                if(min > flow[i][v])\n                    min = flow[i][v];\n            }\n        i = v;\n    }\n    i = t;\n    while (i != s)\n    {\n        v = pre[i];\n        if (flow[v][i] < g[v][i])\n            flow[v][i] += min;\n        else\n            if (flow[i][v] > 0)\n                flow[i][v] -= min;\n        i = v;\n    }\n}\n\n//返回 从节点s到节点t的最大流\nint max_flow(const int &s, const int &t)\n{\n    while (bfs(s, t))\n        track_back(s, t);\n    int res = 0, i;\n    for (i = 0; i < nodeNum; i++)\n        if (i != s) res += flow[s][i];\n    return res;\n}\n\nint main()\n{\n    int m, b, e, c;\n    while(scanf(\"%d%d\", &m, &nodeNum)!=EOF)\n    {\n        memset(g, 0, sizeof(g));\n        memset(flow, 0, sizeof(flow));\n        while (m--)  \n            scanf(\"%d %d %d\", &b, &e, &c), g[b - 1][e - 1] += c;\n        printf(\"%d\\n\", max_flow(0, nodeNum-1));\n    }\n    return 0;\n} \n```\n\n### 最小割\n\n就是从图G(V,E)中去除一些边，使得图G中源点S到终点T不连通。如果去除的这些边的权和最小，就是最小割。这个权和可以证明等于网络的最大流量！因此，最大流等价于最小割。求解最大流问题，也可以转化为最小割。求最大流和求最小割集是两类不同的算法。求解最小割集普遍采用**Stoer-Wagner**算法。\n\n#### Stoer-Wagner\n\n```c++\nint min_cut(int now)\n{\n    int ret = INF;\n    for(int i = 0; i < n; i++) node[i] = i;\n    while(now > 1) {\n        int k, pre = 0;\n        memset(vis, 0, sizeof(vis));\n        memset(dis, 0, sizeof(dis));\n        for(int i = 1; i < now; i++) {\n            k = -1;\n            for(int j = 1; j < now; j++) if(!vis[node[j]]) {\n                dis[node[j]] += G[node[pre]][node[j]];\n                if(k == -1 || dis[node[k]] < dis[node[j]]) {\n                    k = j;\n                }\n            }\n            vis[node[k]] = true;\n            if(i == now - 1) {\n                ret = min(ret, dis[node[k]]);\n                for(int j = 0; j < now; j++) {\n                    G[node[pre]][node[j]] += G[node[j]][node[k]];\n                    G[node[j]][node[pre]] = G[node[pre]][node[j]];\n                }\n                node[k] = node[--now];\n            }\n            pre = k;\n        }\n    }\n    return ret;\n}\n```","tags":["网络流"],"categories":["算法"]},{"title":"Clever King (最大权闭合子图模板)","url":"/2018/04/23/2018-04-23-Clever-King-(最大权闭合子图模板)/","content":"\n# [Clever King](https://nanti.jisuanke.com/t/26172)\n\n## 题意\n\nT组数据，有n个产品，m个矿坑。接下来n个数字happiness[i]表示第i个产品的幸福指数，接下来m个数字，ori[i]表示第i个矿坑的开发费用。接下来n行，每行先输入两个数字n1，n2，分别表示第i号产品需要开发的矿坑，和需要的原材料产品。（矿坑开发后材料无限，产品生产后幸福指数一定会增加，不管是作为产品本身还是原材料），要求 幸福指数 - 费用  的最大值。\n\n## 思路\n\n最大权闭合子图模板。[【关于网络流】](https://blog.csdn.net/jingmiaa/article/details/52814814)（ND）\n\n### 定义\n\n一个子图（点集）， 如果它的所有的出边都在这个子图当中，那么它就是闭合子图。 \n点权和最大的闭合子图就是最大闭合子图。\n\n简单说就是有一些点，每个点有一些点权（正负都有），要选一个点，就必须要选它所连向的点。\n\n有可能连成一条链，像这样：x->y->z->…\n\n求合法的点集的最大的点权和。\n\n### 构图\n\n设s为源点，t为汇点。\n\n使s连向所有的正权点（非负权点），边权为点权。\n\n使所有非负权点（负权点）连向t，边权为点权的绝对值。\n\n若需要选y才能选x，连一条由x到y的边，边权是∞。\n\n**最大点权和 = 正权点和 - 最小割**\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\nstruct node{\n    int to,next,flow;\n}e[maxn*maxn*2];\nint cur[maxn],co[maxn],d[maxn],Final[maxn],tot,s,t;\n// s源点 t终点\n\nvoid link(int x,int y,int z)\n{\n    e[++tot].to=y,e[tot].next=Final[x],e[tot].flow=z,Final[x]=tot;\n    e[++tot].to=x,e[tot].next=Final[y],e[tot].flow=0,Final[y]=tot;\n}\nint dg(int x,int flow) //模板 \n{\n    if(x==t) return flow;\n    int use=0;\n    for(int i=cur[x];i;i=e[i].next)\n    {\n        cur[x]=i;\n        if(e[i].flow>0&&d[e[i].to]+1==d[x])\n        {\n            int c=dg(e[i].to,min(flow-use,e[i].flow));\n            use+=c;\n            e[i].flow-=c;\n            e[i^1].flow+=c;\n            if(flow==use) return use;\n        }\n    }\n    cur[x]=Final[x];\n    if(!(--co[d[x]])) d[0]=t;\n    ++co[++d[x]];\n    return use;\n}\nint main()\n{\n    int T,n1,n2,temp,n,m;\n    int ans;\n    long long sum;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        sum=0;tot=1;s=t=0;\n        memset(cur,0,sizeof(cur));\n        memset(co,0,sizeof(co));\n        memset(d,0,sizeof(d));\n        memset(Final,0,sizeof(Final));\n        scanf(\"%d%d\",&n,&m);\n        ans=n+m;s=ans+1;t=ans+2;\n        for(int i=1;i<=n;i++) //s和正权相连\n        {\n            scanf(\"%d\",&temp);\n            sum+=temp;\n            link(s,i,temp);\n        }\n        for(int i=1;i<=m;i++)  //t和负权相连\n        {\n            scanf(\"%d\",&temp);\n            link(i+n,t,temp);\n        }\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d\",&n1,&n2);\n            for(int j=1;j<=n1;j++)  //i个点需要j的话，就把i->j，边权是inf\n            {\n                scanf(\"%d\",&temp);\n                link(i,temp+n,1<<30);\n            }\n            for(int j=1;j<=n2;j++)\n            {\n                scanf(\"%d\",&temp);\n                link(i,temp,1<<30);\n            }\n        }\n        co[0]=t;\n        for(;d[0]<t;) sum-=dg(s,1<<30); //最小割\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}\n\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"Goldbach （Miller Rabin模板+埃氏筛模板)","url":"/2018/04/23/2018-04-23-Goldbach-（Miller-Rabin模板+埃氏筛模板)/","content":"\n# [Goldbach](https://nanti.jisuanke.com/t/25985)\n\n## 题意\n\n哥德巴赫猜想：输入一个T（100），输入一个偶数n（2<n<2^63），输出任意一组素数a，b，使得a+b=n。\n\n## 思路\n\na和b必定为一大一小，从小的入手，用埃氏筛筛出1e6内的所有素数prim[]（猜想到小的那个素数一定不超过1e6），然后遍历prim[]，算出n-prim[i]，用基于概率的素数测试算法MillerRabin判断它是不是素数即可。\n\n[【Miller Rabin素数判定】](https://blog.csdn.net/sunshine_cfbsl/article/details/52425798)\n\n这里注意，由于2^63次过大，在相乘得过程中会超longlong，因此要改用unsigned long long。\n\n> 做题的时候，遇到范围是2^63，取模2^64的这种题目。遇到这种限制条件时就要想到用unsigned long long类型。这样，如果ull类型的整数溢出了，就相当于取模2^64了。因为ull的范围是[0,2^64-1]。而ll的范围是[-2^63,2^63-1]，因为有符号的第63位表示“正负”而不表示数值。\n\n**附一个公式：(1+a1)(1+a2)(1+a3)……(1+an-1)(1+an) = 1+sum{ai}+sum{ai·aj}+sum{ai·aj·ak}+……+sum{a1·a2·…·an}**\n\n## 看！代码\n\n```C++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 65;\nconst int MAX=1e6;\ntypedef ULL ULL;\nULL n, x[MAXN];\n\nULL pri[MAX+5],num=0;\nbool vis[MAX+5];\n\nvoid init()\n{\n    int i,j;\n    for(i=2;i<MAX;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAX;j++)\n            vis[i*pri[j]]=true;\n    }\n}\n\nULL multi(ULL a, ULL b, ULL p) {\n    ULL ans = 0;\n    while(b) {\n        if(b&1LL) ans = (ans+a)%p;\n        a = (a+a)%p;\n        b >>= 1;\n    }\n    return ans;\n}\n\nULL qpow(ULL a, ULL b, ULL p) {\n    ULL ans = 1;\n    while(b) {\n        if(b&1LL) ans = multi(ans, a, p);\n        a = multi(a, a, p);\n        b >>= 1;\n    }\n    return ans;\n}\n\nbool Miller_Rabin(ULL n) {\n    if(n == 2) return true;\n    int s = 20, i, t = 0;\n    ULL u = n-1;\n    while(!(u & 1)) {\n        t++;\n        u >>= 1;\n    }\n    while(s--) {\n        ULL a = rand()%(n-2)+2;\n        x[0] = qpow(a, u, n);\n        for(i = 1; i <= t; i++) {\n            x[i] = multi(x[i-1], x[i-1], n);\n            if(x[i] == 1 && x[i-1] != 1 && x[i-1] != n-1) return false;\n        }\n        if(x[t] != 1) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int t;\n    ULL n,temp;\n    init();\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        for(int i=0;i<num;i++)\n        {\n            if(Miller_Rabin(n-pri[i]))\n            {\n                printf(\"%lld %lld\\n\",pri[i],n-pri[i]);break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["素数"],"categories":["算法"]},{"title":"ACM-ICPC & U","url":"/2018/04/19/2018-04-19-ACM-ICPC-&-U/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=32574246&auto=0&height=66\"></iframe>\n\n<img  src=\"\\mdpicture\\ACM.jpg\" arc=\"ACM-ICPC :) \">\n\nworld final的直播，窝在图书馆的角落看了一下午，这种感觉真的很棒，真的让我有一种ACM即是力量的冲动。看着这么多的队伍们提交，Pending的进度条一点一点增加，然后高亮，切到队伍的镜头，一阵紧张，最后AC后的欢呼和击掌，然后匆匆进入下一题。\n\n代码的力量是什么呢？\n\nACM的力量是什么呢？\n\n让我明明笨拙到坚持不下去，却又不舍得放弃它。\n\n大概是等待pending的期待的心情，WA了之后自言自语的不服，TLE绞尽脑汁优化的苦恼，或者是看着队友疯狂输出的感叹，大家叽里呱啦实在是很吵闹的讨论 …… 以及最后出现的世界上最好看的单词Accept的欣喜若狂。\n\n真是充满着魔力的一切。\n\n<img src=\"\\mdpicture\\键盘上的秘密.jpg\" arc=\"键盘上的星星点点\">\n\n----\n\n<img src=\"\\mdpicture\\西装和狗毛.jpg\" arc=\"西装领带，狗毛\">\n\n> 四月十九号，倒计时：三天。\n\n----\n\n<img src=\"\\mdpicture\\JJ圣所.jpg\" arc=\"丹宁执着\">\n\n> 许下演唱会的心愿。\n\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"木棒切割（二分+DP+滚动数组优化）","url":"/2018/04/18/2018-04-18-木棒切割（二分+DP+滚动数组优化）/","content":"\n# [木棒切割](https://vjudge.net/problem/HYSBZ-1044)\n\n## 题意\n\n有n个木棒，最多能切m下，接下来n行，给出n个木棒的长度，求出切割后最大长度的最小值，并求出有多少种切割方式，取模10007\n\nn<=50000，0<=m<=min(n-1,1000)，1<=Li<=1000\n\n## 思路\n\n二分答案，low=0，high=sum[n]。\n\n得到最小值ans。\n\n接下来用DP，求出切割种数。\n\n**dp[i][j]表示前i个木棒切割j下的种数，设sum[i] 是前i个木棒的长度和 ，那么dp[i][j]=求和{ dp[k][j-1] }，满足条件：k<i && sum[i] - sum[k]<=ans** 。\n\n但是写完之后，我们发现，诶，这个时间复杂度……O(n^2 * m)，这不超时有鬼……\n\n于是我们可以进行下面的优化：\n\n### 1、空间\n\n由于当前的dp[][j]只与dp[][j-1]有关，所以呢，我们可以用滚动数组，用dp[][now]代替dp[i][j]，用dp[][pre]代替dp[][j-1]，其中pre=now^1。\n\n这样空间就小啦~\n\n### 2、时间\n\n这个好难理解啊我觉得……大概是太笨了哼唧\n\n对于dp[i][now],其实是dp[Mink][pre]……dp[i-1][Mink]的和！！Mink 就是满足 k<i && sum[i]-sum[k]<=ans的最小的k。那么，对于从 1 到 n 枚举的 i ，相对应的 Mink 也一定是非递减的（因为 Sum[i] 是递增的）。我们记录下 dp[1][pre]...dp[i-1][pre] 的和 S ，Mink 初始设为 1，每次对于 i 将 Mink 向后推移，推移的同时将被舍弃的 p 对应的 dp[p][pre] 从 S 中减去。那么 dp[i][Now] 就是 S 的值。\n\n时间复杂度O(nm)。\n\n接下来请欣赏代码——\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=10007;\nint n,m,ans;\nint a[50010],sum[50010];\nint cnt=0;\n\nint check(int mid) //看看有没有单比mid还大的 或者分割不了的\n{\n    int s=0,cnt=0;\n    for(int i=1;i<=n;i++)\n    {\n        s+=a[i];\n        if(s>mid) cnt++,s=a[i];\n        if(cnt>m) return 0;\n        if(a[i]>mid) return 0;\n    }\n    return 1;\n}\n\nvoid solve() //二分答案\n{\n    int l=0,r=sum[n];\n    int mid;\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(check(mid)) ans=mid,r=mid-1; \n        else l=mid+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    sum[0]=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        sum[i]=sum[i-1]+a[i];\n    }\n    solve();\n    int dp[50010][2]={0}; //滚动数组，前i块切j下的数量\n    int now=0,pre=1,s,Mink; //mink 最小的满足k<j && s[i]-s[k]<=ans 的\n    int res=0;\n    for(int i=0;i<=m;i++) //切i下\n    {\n         s=0,Mink=1; \n         for(int j=1;j<=n;j++) //前j块\n         {\n             if(i==0) //如果一下不割\n             {\n                 if(sum[j]<=ans) dp[j][now]=1; //如果这块东西比要求的要小，就前j块割0下是1钟\n                 else dp[j][now]=0;\n             }\n             else\n             {\n                 //s=sum{dp[k][j-1]} k<j&&s[i]-s[k]<=ans ，sum也相当于减去那些不满足条件的，\n                 //因为这东西肯定单调非递减，所以一直找到最小的满足的k就好\n                 while(Mink<j&&(sum[j]-sum[Mink])>ans) //找到最小的满足条件的k\n                 {\n                     s-=dp[Mink][pre]; //减去前mink块不符合条件的 切了i-1下的\n                     s=(s+MOD)%MOD;\n                     Mink++;\n                 }\n                 dp[j][now]=s%MOD; //别忘了取模\n             }\n             s=(s+dp[j][pre])%MOD; // s加上前j块割i-1下的\n         }\n         res=(res+dp[n][now])%MOD; //总数相当于总数加上n块割i下的\n         now^=1; //滚动数组\n         pre=now^1;\n    }\n    printf(\"%d %d\\n\",ans,res);\n    return 0;\n}\n```\n\n","tags":["滚动数组"],"categories":["算法"]},{"title":"Buy a ticket (最短路SPFA)","url":"/2018/04/18/2018-04-18-Buy-a-ticket-(最短路SPFA)/","content":"\n# Buy a ticket\n\n## 题意\n\n给你n个城市，m条无向路，每条路有vi的权值（>0），每个城市有ai的音乐会花费。\n\n某人想去看音乐会，如果她在i城，他要去j城看演出，那么要花费的钱相当于来回的路费加上j城的演唱会的钱（也可以在自家看演出）。求的是，每个城市的人看一场音乐会的最少花费。\n\n## 思路\n\n很熟悉的思路，定义一个超级原点，将超级原点和每个城市连起来，路的权值设为该城市的音乐会花费，同时加其他的路的权值设为原来的两倍（来回的花费），那么从原点到每个城市的最小花费就是每个城市的人看音乐会的最小花费。（最短路）\n\n开头用dijkstra写，看了一下复杂度肯定会T，o(n^2)的样子，然后交了一发。后来换用SPFA，队列啥的，还是T，然后看了一下过的人的代码，发现他们用优先队列优化，将花费大的放在了前面。\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nint n,m;\nstruct  node{\n    int to; //目的\n    long long val; //花费\n};\nstruct  Node{\n    int to;   \n    long long val;\n    bool operator<(const Node k)const{\n        return val>k.val; \n    }\n};\nvector<node>Next[200005]; //路\nint vis[200005]={0}; //在Q里的情况\nlong long dis[200005];  //距离原点的最短距离\nvoid SPFA()\n{\n    memset(dis,INF,sizeof(dis)); \n    priority_queue<Node> Q; //修改成优先队列，默认路径花费大的放前面，是的\n    Node temp;\n    temp.to=0;temp.val=0;\n    Q.push(temp);  //把原点先入队\n    vis[0]=1;dis[0]=0; //原点到原点当然是0啦  \n    int now,a;\n    while(!Q.empty())\n    {\n        temp=Q.top();\n        Q.pop();\n        now=temp.to;\n        vis[now]=0;  //出队的点vis更新\n        for(int i=0;i<Next[now].size();i++)  //遍历连接的城市\n        {\n            a=Next[now][i].to;  \n            if(dis[a]>(dis[now]+Next[now][i].val)) //如果从原点到这个城市的距离比中间接这个城市跳转要远\n            {\n                dis[a]=dis[now]+Next[now][i].val;\n                if(vis[a]==0) //如果a不在队列里\n                {\n                    vis[a]=1;temp.to=a;temp.val=dis[a];\n                    Q.push(temp);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int ori,to;\n    node temp;\n    scanf(\"%d%d\",&n,&m);\n    while(m--)\n    {\n        scanf(\"%d%d%lld\",&ori,&to,&temp.val);\n        temp.to=to;\n        temp.val*=2;\n        Next[ori].push_back(temp);\n        temp.to=ori;\n        Next[to].push_back(temp);\n    }\n    dis[0]=0;\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lld\",&dis[i+1]);\n        temp.to=i+1;temp.val=dis[i+1];\n        Next[0].push_back(temp);\n    }\n    SPFA();\n    for(int i=1;i<=n-1;i++) printf(\"%lld \",dis[i]);\n    printf(\"%lld\\n\",dis[n]);\n    return 0;\n}\n```\n\n","tags":["图论"],"categories":["算法"]},{"title":"Cashback (DP 区间最小值)","url":"/2018/04/18/2018-04-18-Cashback-(DP-区间最小值)/","content":"\n# Cashback\n\n## 题意\n\n输入n和c。接下来给出长度为n的数组A。你可以将数组A划分成任意个子数组，假设其中一个子数组的长度为k，那么可以减去这个子数组内前k/c个（向下取整）小的数。要使划分后数组内的元素和最小，问最小的和为多少？\n\n## 思路\n\n预感到是DP，但是没有什么L用……\n\n分析一下：如果其中一个子数组的长度k< c，那么这个数组就一个也不能减少；如果长度k=c，那么就刚好减少一个；如果长度在c< k< 2c之间，并没有任何贡献，还是只能少一个。也就是说，长度正好为c的数组是优秀的。那么长度为2c的数组呢？我们假设[0,c-1]内，最小的数字为min1，第二小的是min2，[c,2c-1]内，最小的数字为min3，那么，如果min2< min3，对于划分（2个长度为c）来说，消去的数字是min1+min3，而对于划分（1个长度为2c），消去的数字就是min1+min2，显然是两个c长度的划算。如果min2>=min3，对于划分成（2个长度为c）来说，消去的数字就是min1+min3，对于划分（一个长度为2c），消去的数字为min1+min3，两者是相等的。因此综上而言，将数组划分成长度为c的小数组更划算一些。\n\n那么就用到dp了，dp[i]指 前i个数字的最小和。\n\n对于一个数字a[i]来说，（i>c）dp[i] 要么是接受前一个数字的dp再加上自己的大小，要么就是重新进入一个长度是c的数组，起始index为i-c+1，dp[i]=dp[i-c] (前i-c的最小和）+sum[i]-sum[i-c] （这一段新的长度为c的数组的总和）- min{a[i-c+1], … , a[i] }（这一段长度是c的区间里的最小值），即：\n\n**dp[i] = min(dp[i-1]+a[i] , dp[i-c] + sum[i] - sum[i-c] -  min{a[i-c+1], … , a[i] } )**\n\n对于区间最小值min，用一个multiset维护就好了。multiset里只放当前i为最后一个数字的c个数字。而multiset中的.begin() 会返回容器中最小的数的指针。如果去掉最前面一个放进来的数字呢？. erase( .find(a[i-c+1]))就好了。\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=100010;\nint n,c;\nlong long dp[MAX],a[MAX]; //dp[i]指前i个元素相加的最小和\nlong long sum[MAX]; //前i个元素和\nmultiset<long long>s; //s用来维护长度为c的区间内的最小值\nint main()\n{\n\tscanf(\"%d%d\",&n,&c);\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&a[i]);\n\t\tdp[i]=sum[i]=sum[i-1]+a[i]; \n\t\t//初始化dp值，显然长度不足c的dp值为前i个数之和，其他的默认初始值为前i个数之和\n    }\n    for(int i=1;i<c;i++)\n        s.insert(a[i]);\n    for(int i=c;i<=n;i++)\n    {\n        s.insert(a[i]);\n        dp[i]=min(dp[i-1]+a[i],dp[i-c]+sum[i]-sum[i-c]-*s.begin());\n        //前一个数加上自己的和，前一个c区间及之前的最小和加上这个新的c区间的总和，减去这个区间的最小值\n        s.erase(s.find(a[i-c+1]));//删去下一步到了区间外的数字\n    }\n\tprintf(\"%lld\",dp[n]);\n\treturn 0;\n}\n\n```\n\n","tags":["DP"],"categories":["算法"]},{"title":"二数(就没啥)","url":"/2018/04/15/2018-04-15-二数(就没啥)/","content":"\n# [二数](https://www.nowcoder.com/acm/contest/91/I)\n\n## 题意\n\n一个T<=100,一个n, 1<=n<=10^100000-1 \n\n二数：十进制下每一位都是偶数的数\n\n求离n最近的二数\n\n## 思路\n\n用字符串存。\n\n思考可以得到，对于n要么向小了变，要么向大了变。\n\n遍历，对于遇到的第一个奇数k，\n\n1、变小：k-- \n\n​      然后其他所有的数字都变成‘8’\n\n2、变大：k++\n\n​     然后其他所有数字变成’0‘\n\n对于k=='9'的情况，直接取变小就好了，因为变小的代价肯定小于变大的代价。\n\n然后比较谁更近的话，从高位开始一位一位的比较差值大小就好了……\n\n输出的时候去掉前导0，就好了……\n\n（代码依旧丑，其实很多地方可以改进，但我也懒得……）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t,len,flag;\n    cin>>t;\n    string s,sm,sb;\n    while(t--)\n    {\n        cin>>s;\n        len=s.size(),flag=0;\n        if(len==1&&(s[0]=='1'||s[0]=='0')) { printf(\"0\\n\");continue; } //1 0特判一下\n        sm=sb=s;\n        for(int i=0;i<len;i++) //向下,\n        {\n            if((sm[i]-'0')%2==1)\n            {\n                if(flag==0) sm[i]--,flag=1; //第一个数变小\n                else  //后面的数变大\n                    if(sm[i]=='9') sm[i]='8'; //9变8\n                    else sm[i]='8'; //其他数字变8\n                continue;\n            }\n            if(flag==1)\n                sm[i]='8'; //其他数字变8\n        }\n        flag=0;\n        for(int i=0;i<len;i++) //向上\n        {\n            if((sb[i]-'0')%2==1)\n            {\n                if(sb[i]=='9'&&flag==0) //9同sm\n                {\n                    sb=sm;break;\n                }\n                if(flag==0)  sb[i]++,flag=1;//第一个变大\n                else sb[i]='0';\n                continue;\n            }\n            if(flag==1) sb[i]='0';\n        }\n        //比较\n\n        flag=0;\n        for(int i=0;i<len;i++)\n        {\n            if((s[i]-sm[i])<(sb[i]-s[i])) //前者小\n            {\n                flag=-1;break;\n            }\n            else if((s[i]-sm[i])>(sb[i]-s[i])) //后者小\n            {\n                flag=1;break;\n            }\n        }\n        if(flag==1) s=sb;\n        else s=sm;\n        flag=0;\n        for(int i=0;i<len;i++)\n            if(s[i]!='0') { flag=1; printf(\"%c\",s[i]); }\n            else\n                if(flag==0) continue;\n                else printf(\"%c\",s[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"K序列（DP）","url":"/2018/04/15/2018-04-15-K序列（DP）/","content":"\n# [K序列](https://www.nowcoder.com/acm/contest/91/L)\n\n\n\n## 题目\n\n给一个数组 a，长度为 n，若某个子序列中的和为 K 的倍数，那么这个序列被称为“K 序列”。对数组 a 求出最长的子序列的长度，满足这个序列是 K 序列。 \n\n输入一个n，k，接下来输入n个整数，表示A[1]~A[n] ,1<=n<=1e5,1<=a[i]<=1e9,1<=nK<=1e7。输出最长子序列的长度。\n\n## 思路\n\n又一道DP。\n\ndp[i][j] : 表示前i个数中，对k取模余数为j的最长的子序列长度\n\ndp[i][j] =max (dp[i-1][j],dp[i-1][(k-a[i]%k+j)%k]+1) \n\n解释一下，指的是上一层（前i-1个数字）余数一样的，和上一层再加上a[i]（前i个数字）[余数]+1。\n\n这里有个条件是要判断一下这个取模的余数是否已经存在了，不然就不能比较。\n\n讲的不太清楚，看代码吧。\n\n（这里用二维 vector存dp）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    vector<vector<int> >dp(n+5);\n    for(int i=0;i<=n;i++)\n        dp[i].resize(k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<k;j++)\n        {\n            if(a[i]%k==j) dp[i][j]=1;\n            dp[i][j]=max(dp[i-1][j],dp[i][j]);\n            if(dp[i-1][(j-a[i]%k+k)%k]!=0)\n                dp[i][j]=max(dp[i][j],dp[i-1][(j-a[i]%k+k)%k]+1);\n        }\n    printf(\"%d\\n\",dp[n][0]);\n    return 0;\n}\n```\n\n","tags":["DP"],"categories":["算法"]},{"title":"1+2=3?(奇怪的斐波那契规律题)","url":"/2018/04/15/2018-04-15-1+2=3(奇怪的斐波那契规律题)/","content":"\n# [1+2=3？](https://www.nowcoder.com/acm/contest/91/F)\n\n## 题目\n\n输入一个T，接下来T行，每行一个N，输出满足 x异或2x== 3x 的第N个数字。\n\nT<=100,N<=1e12\n\n## 思路\n\n打了表，[整数数列百科全书](http://oeis.org/?language=english)中找到符合规律的数列，观察二进制形式后发现：\n\n<img src=\"\\mdpicture\\FB.jpg\"  alt=\"规律\" />\n\n斐波那契数列：\n\n1 2 3 5 8 13 21 34 55 ……\n\n题中若N=60，则60= 55 + 5 （第9项+第4项）\n\n则第60个满足条件的数为：1(9)00001(4)000 = 264 (4、9号位数为1，其他都是0)\n\n由于1e12小于斐波那契的第59项，故开一个59大的数组，里面存斐波那契数，然后对于每一个N寻找最少的组成它的斐波那契数，找到他是第x项，那么ans+2^x即可。\n\n（问题是我的代码怎么这么丑= =）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    vector<long long>fei; //算斐波那契 1 2 3 5这样的\n    fei.push_back(1);fei.push_back(2);\n    while(fei[fei.size()-1]<(1e12+5)) fei.push_back(fei[fei.size()-1]+fei[fei.size()-2]);\n \n    while(t--)\n    {\n        long long n,temp;\n        scanf(\"%lld\",&n);\n        temp=n;\n        long long weishu[100],x=1,ans=0;\n        for(int i=0;i<60;i++)\n            weishu[i]=x,x*=2; //计算2的i次\n      \n        for(int i=57;i>=0;i--)\n            if(temp>=fei[i]) //找能组成他的斐波那契数，直接算\n                temp-=fei[i],ans+=weishu[i];\n      \n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["规律"],"categories":["算法"]},{"title":"归途","url":"/2018/04/05/归途/","content":"\n<img src=\"\\mdpicture\\拉杆箱会飞吗.jpg\"  alt=\"如果拉杆箱会飞\" />\n\n回家，带着我的拉杆箱。\n\n拉杆箱好沉啊，下着雨，要撑伞。红色的卫衣，薄荷绿的伞。\n\n<br/>\n\n## 城隍百味\n\n<img src=\"\\mdpicture\\城隍百味.jpg\"  alt=\"城隍庙地铁站\" />\n\n### 食\n\n和小可爱在一起。\n\n\"我要吃三色杯！\"\n\n\"上口爱！\"\n\n\"给我尝一口！\"\n\n\"好冷呐哥！\"\n\n\"我要吃炸鱿鱼！\"\n\n\"好脆呀！\"\n\n\"别扯呀别扯！\"\n\n\"我没我咬不动！\"\n\n\"看你满嘴！\"\n\n\"哼！\"\n\n\"老板来三根肉串！\"\n\n\"还吃……\"\n\n\"臭豆腐要吗！\"\n\n\"……要！\"\n\n\"来一口！\"\n\n\"哇呜是香菜！！TOT \"\n\n\"很香！\"\n\n\"哦这个味道！\"\n\n\"这才是真正的臭豆腐！\"\n\n\"霉的很完美！\"\n\n\"……\"\n\n<br/>\n\n<img src=\"\\mdpicture\\臭豆腐.jpg\"  alt=\"城隍庙臭豆腐\" />\n\n<br/>\n\n\n\n### 遇\n\n老地方，又遇见了一个乞讨的老爷爷，但是好像没有人愿意给他钱。\n\n以前也遇到过一次，等饮料的时候，他伸出破烂的碗，看着我，上下颠一颠，几块钱硬币在碗里面当啷响。\n\n我犹豫着响掏出一点碎钱，被小可爱制止了。\n\n貌似有些残酷的冲老爷爷摆摆手，然后拿了饮料转身离开，给他一个背影。\n\n后来我们往下走，在风很大的路口遇见了一个卖报纸的老婆婆，忘记了多少钱一份，两块还是三块？只记得小可爱二话不说就买了一份。报纸还是过期的，早就不知道哪儿去了。\n\n记得他当时这样说：\n\n\"如果我们刚才给了那个乞丐钱，那对这个辛苦卖报的老婆婆是不是不公平？\"\n\n<br/>\n\n## 归途\n\n> 不断更新着的一切\n>\n> 高楼 大厦\n>\n> 人\n\n<img src=\"\\mdpicture\\高樓.jpg\"  alt=\"萬達新樓\" />\n\n<br/>\n\n> 清明时节雨 纷纷\n\n<img src=\"\\mdpicture\\我.jpg\"  alt=\"潮湿的\" />\n\n<br/>","tags":["随想"],"categories":["Life & Story"]},{"title":"Missing Leslie","url":"/2018/04/01/2018-04-01-Missing-Leslie/","content":"\n<img src=\"\\mdpicture\\Leslie1.jpg\"  alt=\"春天该很好，你若尚在场\" />\n\n\n\n> 春天该很好，你若尚在场。\n\n<br/>","tags":["随想"]},{"title":"CF 957C Three-level Laser (二分)","url":"/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(二分)/","content":"\n# [Three-level Laser](http://codeforces.com/contest/957/problem/C) \n\n## 题意\n\n输入一个n，m，n代表接下来有n个数字（从小到大），\n\n接下来从n个数字中选3个数字i，j，k（i<j<k），\n\n使得k-j/k-i 最大，且（k-i）<=m。(n<1e5)\n\n## 思路\n\n开头直接写，j=1开始遍历，要让值最大，i=j-1,（必定），k为可允许内最大的值。\n\n用for找k，会T，于是改用二分，输出用.15f（精度限制，double到.6）。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\nint a[N];\nint main()\n{\n    int n,U;\n    scanf(\"%d%d\",&n,&U);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    double res=-1.0;\n    for(int i=1;i<=n-2;i++) \n    {\n        int t1=a[i],t2=a[i+1],up=U+t1;\n        int k=upper_bound(a+1,a+1+n,up)-a-1;\n        if(k<i+2) continue;\n        res=max(res,(a[k]-t2*1.0)/(a[k]-t1));\n    }\n    printf(\"%.15f\\n\",res);\n    return 0;\n}\n```\n\n","tags":["二分"],"categories":["算法"]},{"title":"Yilia","url":"/2018/03/31/Change/","content":"\n\n\n<img src=\"\\mdpicture\\18033102.jpg\"  alt=\"回老家的时候，在奶奶家旁边的荒地前拍的，一轮小小的月亮， 好像一个小小的我\" />\n\n<br/>\n\nHexo 找如何搭建相册的时候，发现的一个主题，yilia，简洁，充满魅力。\n\n创作这个主题的作者Litten是鹅厂的一名前端。\n好奇心的驱使，让我开始翻看着他的随笔，生活中的点点滴滴，却感叹于他的心思和文笔的细腻。\n\n他写凛冬将至，说人的老去，很多是因为忘记了年轻。\n他写生病，说意外的中断是多么可爱，欢乐可放歌，悲伤可饮酒。\n要是心情郁闷的话，就用手托腮，手臂会因为帮上忙而开心。\n…\n\n以及各种稀奇古怪的专业文章，\n讲反爬虫的，讲Unicode，\n…\n\n他的相册里的照片，\n我实在是喜欢。\n非常的生活，和触动。\n\n我想了想，换掉了我执念的透明色主题。\n毕竟看多了还是觉得花里胡哨。\n博客嘛，\n回到内容上来，还是更好。\n我想谢谢这位陌生的，\n不知道怎么称呼，\n在这些天茫然的夜晚，我又重新感受到了，\n生活该是什么样，就是什么样。\n\n<br/>\n\n> 事情无非是let，变化历历；或者是const，永恒安息。","tags":["随想"],"categories":["Life & Story"]},{"title":"文章置顶","url":"/2018/03/31/文章置顶/","content":"\n1、Hexo bash ：\n\n```\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n\n2、在需要置顶的文章的`Front-matter`中加上：`top: true`\n\n完毕。\n\n3、置顶的文章添加置顶标志\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"聚餐","url":"/2018/03/31/聚餐/","content":"&nbsp;&nbsp;&nbsp;&nbsp;长辈一代的遥远的许久未见的亲戚，如今因为后代重新联系在一起，对于后代来说，忽然承受了很大的责任与压力，自己仿佛变成了维系这种关系的纽带。\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;有时候想也不是，不想也不是，去也不是，不去也不是，只能默默地做好自己身为纽带的职责。\n\n&nbsp;&nbsp;&nbsp;&nbsp;虽然对方长辈待自己不薄，但是底下的子子孙孙确实不关他们什么事情了，于是家庭聚会这种事情，大概就是名为尴尬的存在吧。\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"日常反省","url":"/2018/03/31/反省/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哎呀，其实也是昨天的事情了。\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是觉得，自己很犹豫不决，凡事一下子解决不了，又喜欢拖着，结果就导致最后处理不好两边的结果，会有一种左右不是人的味道，但是毕竟也是自己的错啊，明明心里想着这样这样，但是又不跟人家讲清楚，太**失败**了吧！\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后要学会**果断**和**决绝**，不要把心思放在人后面去讨论。\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，反省自己。\n<br/>\n\n---------\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由这两个词语我还想到，我爸的事情。你说他要是果敢一点，哪里会折腾这么个来回。\n\n&nbsp;&nbsp;&nbsp;&nbsp;    我们爷俩就是在这性格的薄弱方面，特别像了。\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"MoonLight","url":"/2018/03/31/MoonLight/","content":"\n**We go about our daily lives understanding almost nothing of the world.**\n\n**We give little thought of the machinery that generates the sunlight that makes life possible.**\n\n**To the gravity that glues us to the earth that would otherwise send us spinning off into the space.**\n\n**Or to the atoms, which we are made, and on who's stability we  fundamentally depend.**\n\n**Few of us spend much time wondering why nature is the way it is.**\n\n**where the cosmos came from.**\n\n**Whether it was always there.**\n\n**If time will one day flow backward.**\n\n**Or whether there are ultimate limits to what humans can know.**\n\n**What is the smallest piece of the matter.**\n\n**Why  we remember the past and not the future.**\n\n***AND WHY THERE IS A UNIVERSE ?***\n\n<br/>\n\n<a href=\"https://download.sublimetext.com/Sublime%20Text%20Build%203143%20x64%20Setup.exe\"> If  The Moon Were Only 1 Pixel . </a>\n\n<br/>","tags":["Universe"],"categories":["English Matters"]},{"title":"Everything","url":"/2018/03/31/Everything/","content":"\n**The void, is like a space.**\n\n**Now space contains everything,**\n\n**the mountains, the oceans, the stars,  the good  people and the bad people,**\n\n**the plants, the animals, everything.**\n\n**Now the mind in us, the true mind is like that.**\n\n**You will find that when bullists use the word \"mind\",** \n\n**they've several words for \"mind\",**\n\n**But I'm not going into the technicality at the monment.**\n\n**They mean space.**\n\n**See,  SPACE IS YOUR MIND.**\n\n\n\n","tags":["English"],"categories":["English Matters"]},{"title":"无题，仅记","url":"/2018/03/30/无题，仅记/","content":"\n其实自己的心里不知道是什么滋味，感觉很复杂，很奇怪。\n\n<!--more-->\n\n努力的想挣脱出来，跳出来。\n\n或许是太肤浅？\n\n用别的话说，见识的太少，\n\n没有看过这个世界……\n\n所以心始终狭隘，多的是芥蒂，即使是现在，\n\n还是心照不宣，脑袋里的想法和内心的，好像差了很多。\n\n我想要变得理性，\n\n不要把自己捆绑在一个人的身上，\n\n独立的个体……\n\n开朗……\n\n积极……\n\n充满自己的个性……\n\n自由自在的样子，\n\n很美。\n\n可既要这样，\n\n我又该如何是好？\n\n红肿的眼睛，\n\n隐隐作痛的太阳穴，\n\n厌弃这样的自己，\n\n有时候就像尘埃，\n\n很低……\n\n很低……\n\n要多学、多看、多闻、多思……\n\n你啊，\n\n笨死了啊……\n\n不要再悸动了，\n\n不要再那么感情用事了，\n\n没有好处的，\n\n已经……\n\n二十一了啊。\n\n年龄在增长，\n\n心智，也该慢慢成熟了。\n\n天很热，\n\n很热。\n\n很丧。\n\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"LiveRe 留言板 GET(适用于第一个主题，改变中)","url":"/2018/03/29/LiveRe-留言板-GET/","content":"\n\n\n在正式开始之前！\n\n容我先大笑三声！\n\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！\n\n<!--more-->\n\n在尝试了Valine一直失败之后，\n\nLiveRe终于赐予了我成功的喜悦！\n\n看了很多乱七八糟的安装指南，就是合不到我的网站上来，\n\n很多人都是next主题，导致很多步骤其实跟我自己的都是不搭嘎的，所以我现在来记录一下这个过程吧：\n\n1、首先，当然是注册LiveRe啦！<a href=\"https://livere.com/\"> 来必力 </a>\n\n2、选择安装板块，这里我们安装的是City版~\n\n<img src=\"\\mdpicture\\1803291.JPG\" width=\"511\" height=\"646\" alt=\"City\" />\n\n3、接下来填写一些关于你想将LiveRe用于的博客的一些信息：（图片来自网络）\n\n<img src=\"\\mdpicture\\1803292.JPG\" width=\"875\" height=\"593\" alt=\"填写\" />\n\n4、填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来：\n\n<img src=\"\\mdpicture\\1803293.JPG\" width=\"794\" height=\"756\" alt=\"代码\" />\n\n5、在个人博客中加入LiveRe代码，首先去如路径：*hexo_bolg/themes/your-theme/layout/_partial/post*下创建livere.ejs代码。livere.ejs的内容就是上一步中获取的代码。\n\n6、然后修改路径：hexo_bolg/themes/your-theme/layout/_partial下的article.ejs文件，在`<% if (!index && post.comments){ %>` 代码块下添加如下代码：\n\n```js\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/livere') %>\n  <% } else { %>\n    <div class=\"lv-container\"></div>\n  <% } %>\n<% } %>\n```\n\n如图：\n\n<img src=\"\\mdpicture\\1803294.JPG\" width=\"593\" height=\"765\" alt=\"修改\" />\n\n7、git g，git d~\n\n完成！！！\n\n我先去试用一波啦哈哈哈哈哈！！！！\n\n:laughing:\n\n(p.s.这个markdown的小表情好可爱。。输冒号的时候意外发现的。。。Surprise？？)","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"CSS 属性","url":"/2018/03/29/CSS-属性/","content":"\n[W3Cschool CSS](http://www.w3school.com.cn/css/css_jianjie.asp)\n\n<!--more-->\n\ntips:\n\n~~<span> <p> </p> </span>~~ \n\n<p><span></span></p>\n\n#####类选择器\n\n .center /*类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。*/\n\n```\n.fancy td {\n\tcolor: #f60;\n\tbackground: #666;\n\t}\n在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）\ntd.fancy {\n\tcolor: #f60;\n\tbackground: #666;\n\t}\n<td class=\"fancy\">\n```\n\n##### id选择器 \n\nsidebar\n\n##### 派生选择器\n\n##### 属性选择器\n\n##### front-style: \n\n字体\n\n##### text-align:\n\n  规定元素中的文本的水平对齐方式 center，right，left\n\n##### margin-top:\n\n 元素的上外边距 (单位多样)\n\n##### font-weight:\n\n 文本粗细 （支持数字）\n\n##### font-size:\n\n 设置不同的 HTML 元素的尺寸\n\n##### line-height: \n\n行距（行高）\n\n#####border: \n\n1px dotted #000 （边框 dotted solid）\n\n##### padding: \n\n10px （文字距离边框的内边距）\n\n##### display : \n\n| 值                  | 描述                                       |\n| ------------------ | ---------------------------------------- |\n| none               | 此元素不会被显示。                                |\n| block              | 此元素将显示为块级元素，此元素前后会带有换行符。                 |\n| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。               |\n| inline-block       | 行内块元素。（CSS2.1 新增的值）                      |\n| list-item          | 此元素会作为列表显示。                              |\n| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。                  |\n| compact            | CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |\n| marker             | CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |\n| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。     |\n| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。     |\n| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。          |\n| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。          |\n| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。          |\n| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                  |\n| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。       |\n| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                 |\n| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |\n| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）             |\n| inherit            | 规定应该从父元素继承 display 属性的值。                 |\n\n#### CSS背景 background \n\n```\nbody\n{ \nbackground: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center; \n} //所有背景属性在一个声明之中\n```\n\n##### background-color\n\n可以为所有元素设置背景色，这包括 body 一直到 em 和 a 等行内元素。\n\nbackground-color 不能继承，其默认值是 transparent。transparent 有“透明”之意。也就是说，如果一个元素没有指定背景色，那么背景就是透明的，这样其祖先元素的背景才能可见。\n\n##### background-image\n\nbackground-image 属性的默认值是 none，表示背景上没有放置任何图像。\n\n```\nbody {background-image: url(/i/eg_bg_04.gif);}\n```\n\n大多数背景都应用到 body 元素，不过并不仅限于此。\n\n下面例子为一个段落应用了一个背景，而不会对文档的其他部分应用背景：\n\n```\np.flower {background-image: url(/i/eg_bg_03.gif);}\n```\n\n您甚至可以为行内元素设置背景图像，下面的例子为一个链接设置了背景图像：\n\n```\na.radio {background-image: url(/i/eg_bg_07.gif);}\n```\n\n##### background-repeat\n\n属性值 repeat 导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样。repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。\n\n默认地，背景图像将从一个元素的左上角开始。\n\n ##### background-position\n\n背景图的位置。首先，可以使用一些关键字：top、bottom、left、right 和 center。通常，这些关键字会成对出现，不过也不总是这样。还可以使用长度值，如 100px 或 5cm，最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。\n\n**关键字**\n\n图像放置关键字最容易理解，其作用如其名称所表明的。例如，top right 使图像放置在元素内边距区的右上角。\n\n根据规范，位置关键字可以按任何顺序出现，只要保证不超过两个关键字 - 一个对应水平方向，另一个对应垂直方向。\n\n如果只出现一个关键字，则认为另一个关键字是 center。\n\n所以，如果希望每个段落的中部上方出现一个图像，只需声明如下：\n\n```\np\n  { \n    background-image:url('bgimg.gif');\n    background-repeat:no-repeat;\n    background-position:top;\n  }\n\n```\n\n下面是等价的位置关键字：\n\n| 单一关键字  | 等价的关键字                        |\n| ------ | ----------------------------- |\n| center | center center                 |\n| top    | top center 或 center top       |\n| bottom | bottom center 或 center bottom |\n| right  | right center 或 center right   |\n| left   | left center 或 center left     |\n\n**百分数值**\n\n百分数值的表现方式更为复杂。假设你希望用百分数值将图像在其元素中居中，这很容易：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:50% 50%;\n  }\n\n```\n\n这会导致图像适当放置，其中心与其元素的中心对齐。**换句话说，百分数值同时应用于元素和图像。**也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。\n\n如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。\n\n因此，如果你想把一个图像放在水平方向 2/3、垂直方向 1/3 处，可以这样声明：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:66% 33%;\n  }\n\n```\n\n如果只提供一个百分数值，所提供的这个值将用作水平值，垂直值将假设为 50%。这一点与关键字类似。\n\nbackground-position 的默认值是 0% 0%，在功能上相当于 top left。这就解释了背景图像为什么总是从元素内边距区的左上角开始平铺，除非您设置了不同的位置值。\n\n**长度值**\n\n长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。\n\n比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:50px 100px;\n  }\n\n```\n\n注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。\n\n#####background-attachment 背景关联\n\n如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。\n\n您可以通过 background-attachment 属性防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed），因此不会受到滚动的影响：\n\n```\nbody \n  {\n  background-image:url(/i/eg_bg_02.gif);\n  background-repeat:no-repeat;\n  background-attachment:fixed\n  }\n\n```\n\nbackground-attachment 属性的默认值是 scroll，也就是说，在默认的情况下，背景会随文档滚动。\n\n#### CSS 文本\n\n","tags":["CSS"],"categories":["前端"]},{"title":"Subline text 3 插件","url":"/2018/03/29/ST3插件/","content":"\n## 插件\n\n**View In Browser**\n\nhtml文件+快捷键在浏览器打开 （个人：ctrl+alt+f）\n\n**SideBarEnhancements**\n\n设置默认打开浏览器\n\n<!--more-->\n\n在设置里输入：\n\n`{`\n  `\"default_browser\": \"chrome\" //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari`\n`}`\n\n然后在快捷键中设置：\n\n```\n{    \n    \"keys\": [\"ctrl+alt+f\"],\n    \"command\": \"side_bar_open_in_browser\",\n    \"args\": {\n                \"paths\": [],\n                \"type\": \"testing\",\n                \"browser\": \"\"\n            }\n}\n```\n\n\n## 快捷键\n\n###### <b> Q：如何设置快捷键？ </b>\n\n**A：** *Preferences->Key Bindings-User* ，打开*Default (Windows).sublime-keymap*文件，\n\n输入`[ { \"keys\": [\"ctrl+alt+f\"], \"command\": \"open_in_browser\" },]` （eg）\n\n快捷键即ctrl+alt+f。\n\n\n\n","tags":["Subline"],"categories":["前端"]},{"title":"觅香","url":"/2018/03/28/不如你/","content":"\n<img src=\"\\mdpicture\\MX3.jpg\"  alt=\"遛狗时发现春天正盛\" />\n\n## 词\n\n**春风十里，五十里，一百里，体测八百米，海底两万里。**\n\n**德芙巧克力，香草味八喜，可可布朗尼。**\n\n**榴莲，菠萝蜜，芝士玉米粒，鸡汁土豆泥。**\n\n**黑椒牛里脊，黄焖辣子鸡，红烧排骨醋酱鱼。**\n\n**冰糖雪梨，梅菜扣肉饼，柠檬味雪碧，椒盐九吐鱼。**\n\n**白酒，青啤，安慕希，**\n\n**不如你，全都不如你。**\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **—— 《觅香》**\n\n<!--more-->\n\n<br/>\n\n## 叨叨\n\n歌词实在可爱，听得我都饿了呀！\n\n昨天，二十五度，完全没想到自己在这种温度之下还穿着加绒裤和加绒鞋垫！\n\n正好小可爱回来了，我果断牵着他买了冰淇淋QwQ，然后顺便在隔壁杨国福吃了麻辣烫嘿嘿嘿~（顺带吐槽一下某人的打扮，我远远的望去，见他身着白衬衫，很是好看，走进了一看，我他妈，你脖子上怎么还露出一截紫色呢？？啥玩意儿白衬衫里面穿了一件这么高的还是紫色的棉毛衫？？然后他一抬手……幻灭，绝对是幻灭，袖口上还露出五公分的深灰色毛衣？？我……我们不如分开走？？）\n\n晚上的选修课乌七麻黑看电影，带着小可爱潜入了教室，吃了两把鸡，想到这里，他要是还在上学，和我念一个学校一个专业多好呀~那我就可以每天每天每天打爆他的狗头！喵了个咪的，前天做梦梦到他居然牵着一个小姑娘的手还冲我挑眉得瑟？？气得我把新买的手机扔了出去屏幕都裂了他还不愿意赔？？哼，男人。\n\n从寝室下来的楼梯口闻到一个女生手上拎着的鸡排的香味，忽然感觉又饿了！可是我不是刚吃的麻辣烫吗？？（世界未解之谜：xxQ的胃）看着小可爱的脸，我非常认真的说了了一句：\n\n“ 我饿了，想吃关东煮w “\n\n真是作孽的一天，**虽然**我一早有想到家里的惨状，但是我也。。。没想到有这么惨。。。\n\n<img src=\"\\mdpicture\\18032801.jpg\" width=\"270\" height=\"360\" alt=\"ice-cream\" />&nbsp;<img src=\"\\mdpicture\\18032802.jpg\" width=\"270\" height=\"360\" alt=\"mess\" />\n\n但是！狗奴们应该都能体会我这种心情把！看到狗子热情四射的笑脸，看到她蹦蹦跳跳围着你开心的转，扑腾扑腾的，实在是太可爱了根本就不生气啊！！反而觉得她可爱极了！！好吧，你最萌，你最萌，让我来收拾这一切把！你出去玩吧！Orz\n\n哼！听话是听话的！臭臭和小便都没有乱拉乱撒，乖乖的在屎盆子上上厕所，我家狗子就是聪明嘻嘻嘻~\n\n带她出去溜的时候，她爱跑，我就看四下没有人，松开绳子让她肆意的奔跑，她知道我跑得慢，还跑两步，然后转回头来等我，看到我走的差不多了，再继续跑，啊啊啊啊我怎么能不爱你啊啊啊啊啊！太贴心了~ 一首《觅香》送给你！！德芙巧克力香草味八喜可可布朗尼！全都不如你！！\n\n<img src=\"\\mdpicture\\18032803.jpg\" width=\"360\" height=\"270\" alt=\"狗子上屋\" />\n\n<br/>\n\n<img src=\"\\mdpicture\\MX2.jpg\"  alt=\"吃外卖时开心的看着你的狗子\" />\n\n诶，意外的点题了，我真棒！（hhhh\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n哦对啦，附赠收获的什么叫的一把表情包，应该也没有人能看见吧，哈哈哈哈哈哈哈哈哈哈哈，上课的时候笑到不能自已！\n\n<img src=\"\\mdpicture\\18032805.jpg\" width=\"576\" height=\"360\" alt=\"smj表情包原图\" /><img src=\"\\mdpicture\\18032804.jpg\" width=\"355\" height=\"360\" alt=\"smj表情包\" />\n\n<br/>\n\n被发现就完了。（逃\n\n\n","tags":["歌词"],"categories":["Life & Story"]},{"title":"HDU 1024 Max Sum Plus Plus(DP+最大M子段和)","url":"/2018/03/28/HDU-1024-Max-Sum-Plus-Plus(DP+最大M子段和)/","content":"\n## [Max Sum Plus Plus](http://acm.hdu.edu.cn/showproblem.php?pid=1024)\n\n### 题意\n\nn个数字，选m组，使得SUM最大。\n\n<!--more-->\n\n### 思路\n\ndp[i][j]=max(dp[i][j-1]+a[j],max(dp[i-1][k])+a[j]) (0<k<j)。\n\ndp[i][j-1]+a[j]表示的是前j-1分成i组，第j个必须放在前一组里面。\n\nmax( dp[i-1][k] ) + a[j] )表示的前（0<k<j）分成i-1组，第j个单独分成一组。\n\n但是题目的数据量比较大，时间复杂度为n^3，n<=1000000，显然会超时，继续优化。\n\nmax( dp[i-1][k] ) 就是上一组 0....j-1 的最大值。我们可以在每次计算dp[i][j]的时候记录下前j个\n的最大值 用数组保存下来 ，这样时间复杂度为 n^2。\n\n**(1)节省时间**\n\n由基本思路，我们可以知道，dp[i][j]=max(dp[i][j-1]+num[j],dp(i-1,t)+num[j])，其中i-1<=t<=j-1.我们只要找到dp[i][j-1] 和dp[i-1][t]的最大值加上num[j]即为dp[i][j].所以，定义一个数组pre_max[n]，用pre_max[j-1]来表示求解dp[i][j]时dp[i-1][t]的最大值,则dp[i][j]=max(pre_max[j-1],dp[i][j-1])+num[j]。特别注意，pre_max[n]这个位置的存储空间是始终用不到的，因此可以用来存储其他数值，在接下来会用到。在求解dp[i][j]的同时，我们可以计算出dp[i][t];i<=t<=j的最大值，这个最大值在计算dp[i+1][j+1]的时候需要作为pre_max[j]的形式被使用，我们先把它存在pre_max[n]中。\n你可能会问：为什么不把它直接放在pre_max[j]中呢？因为你接下来需要计算dp[i][j+1]的值，需要用到pre_max[j]中原来的值，如果你把它存在这里，就会覆盖掉计算dp[i][j+1]所需要的那个值。所以，先把它放在pre_max[n]中。当我们计算完dp[i][j+1]之后，就会发现pre_max[j]中的值已经没有用处了，我们可以把它更新为计算dp[i+1][j+1]所需要的那个值，  即之前放在pre_max[n]中的那个值，即执行pre_max[j]=pre_max[n]。这样我们就节省了计算最大值时付出的时间代价。\n\n **(2)节省空间**\n\n通过时间的节省，我们突然间发现程序执行结束后pre_max[n]的值即为最后的结果，pre_max[n]数组才是我们希望求解的，dp[m][n]这个庞大的数组已经不是那么重要了，因此，我们现在用整型数tmp来代替dp[m][n]，用来临时存储dp[i][j]的值，作为求解pre_max[n]的中介。这样就节省了dp[i][j]占用的极大的空间。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\nint dp[1000010],MAX[1000010],a[1000010];\nint main()\n{\n    int n,m;\n    int maxx;\n    while (~scanf(\"%d%d\",&m,&n))\n    {\n        memset(dp,0,sizeof(dp));\n        memset(MAX,0,sizeof(MAX));\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=1;i<=m;i++)\n        {\n            maxx=-INF;\n            for(int j=i;j<=n;j++)\n            {\n                dp[j]=max(dp[j-1]+a[j],MAX[j-1]+a[j]);\n                MAX[j-1]=maxx;\n                maxx=max(maxx,dp[j]);\n            }\n        }\n        printf(\"%d\\n\",maxx);\n    }\n    return 0;\n}\n```\n\n[][][][]\n\n","tags":["HDU"],"categories":["算法"]},{"title":"HDU 1069 Monkey and Banana (简单dp)","url":"/2018/03/28/HDU-1069-Monkey-and-Banana-(简单dp)/","content":"\n## [Monkey and Banana](http://acm.hdu.edu.cn/showproblem.php?pid=1069)\n\n### 题意\n\n有一些方块，三维属性x，y，z，每一块方块都有无限个，求这些方块堆起来能达到的最高海拔？\n\n（下面的方块的x，y必须严格大于上面的x，y（对应））\n\n<!--more-->\n\n<br\\>\n\n### 思路\n\n简单dp，由于方块有无限个，就让一个方块一次存6种可能的摆放方式，dp表示这个方块加上它下面的方块能达到的最大高度。\n\n我按照x，y，z的降序排序，两重for循环中，因排序的不同而写的略微有差别，我的意思是a[i]在下，a[j]在上面的话，即满足a[i].x>a[j].x&&a[i].y>a[j].y , a[j].dp = max(a[j].dp, a[i].dp+a[j].z) ，就是说dp的是小方块。没错。嗯。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct node{\n    int x,y,z;\n    int high;\n};\nbool cmp(node a,node b)\n{\n    if(a.x==b.x)\n    {\n        if(a.y==b.y)\n            return a.z>b.z;\n        return a.y>b.y;\n    }\n    return a.x>b.x;\n}\nint main()\n{\n    int n,cas=1;\n    int x,y,z;\n    while(~scanf(\"%d\",&n)&&n)\n    {\n        node a[10010];\n        int index=0;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&z);\n            a[index].x=x;a[index].y=y;a[index].z=a[index].high=z;index++;\n            a[index].x=x;a[index].y=z;a[index].z=a[index].high=y;index++;\n            a[index].x=y;a[index].y=x;a[index].z=a[index].high=z;index++;\n            a[index].x=y;a[index].y=z;a[index].z=a[index].high=x;index++;\n            a[index].x=z;a[index].y=y;a[index].z=a[index].high=x;index++;\n            a[index].x=z;a[index].y=x;a[index].z=a[index].high=y;index++;\n        }\n        sort(a,a+index,cmp);\n        for(int i=0;i<index;i++)\n            for(int j=i+1;j<index;j++)\n                if(a[i].x>a[j].x&&a[i].y>a[j].y)\n                    a[j].high=max(a[j].high,a[i].high+a[j].z);\n        int ans=-1;\n        for(int i=0;i<index;i++)\n            ans=max(ans,a[i].high);\n        printf(\"Case %d: maximum height = %d\\n\",cas++,ans);\n    }\n    return 0;\n}\n\n```\n\n","tags":["HDU"],"categories":["算法"]},{"title":"冥冥","url":"/2018/03/26/冥冥/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=86 src=\"//music.163.com/outchain/player?type=2&id=547281157&auto=0&height=66\"></iframe>\n\n## 词\n\n<br/>\n\n**“**\n\n**在冥冥中掌控命运的力量，到底是什么？**\n\n**高山变成深谷，沧海化为桑田。**\n\n**夏冬的枯荣，国家的兴衰。**\n\n**人的生死。**\n\n**真的是神秘莫测？**\n\n**十年可见春去秋来，百年可证生老病死，千年可叹王朝更替，万年可见斗转星移。**\n\n**凡人如果用一天的视野，去窥探百万年的天地，是否就如同井底之蛙？**\n\n**”**\n\n<!--more-->\n\n<br/>\n\n## 思\n\n<br/>\n\n**这番台词，真是让我想起了从前的故事。**\n\n**我也曾是个爱天马行空的家伙。**\n\n<br/>\n\n**我忘掉了很多的事情，却始终记得这个片段。**\n\n**这么多年过去了，那个认认真真回答我对宇宙的困惑的男孩，现在又过的怎么样呢？**\n\n<br/>\n\n<img src=\"\\mdpicture\\1803267.jpg\" width=\"240\" height=\"360\" alt=\"极光\" /><img src=\"\\mdpicture\\1803268.jpg\" width=\"270\" height=\"360\" alt=\"新月\" /><img src=\"\\mdpicture\\1803266.jpg\" width=\"288\" height=\"360\" alt=\"超级蓝血月\" />\n\n<br/>\n\n<br/>\n\n*【PHOTO FROM INTERNET】*","tags":["嬴政"],"categories":["天行九歌"]},{"title":"934C A Twisty Movement(前缀和+思维)","url":"/2018/03/25/934C-A-Twisty-Movement(前缀和+思维)/","content":"\n## [A Twisty Movement](http://codeforces.com/problemset/problem/934/C)\n\n### 题意\n\n给出n个数字，由1、2组成，你可以选择一个区间[L,R]，将其逆转，使得集合中的***非递减子序列***最长。\n\n（不是子串。。。）\n\n<!--more-->\n\n### 思路\n\n“ 由于序列只由1和2组成，显然我们需要找到最长非递减子序列中第一个2出现的位置pos，那么逆序后[l,pos]会使后面2个数目增加，[pos,r]会使前面1个数目增加。\n\n于是我们先处理出“1”的前缀个数和与“2”的后缀个数和，然后我们每次枚举前面提到的位置pos，然后再依次枚举区间的l和r。\n\n然后分别滑动L，R的值，计算其对最长不降子序列贡献的最大值。\n\n对于l,计算[1,L-1]中1的个数和[l,pos]中2的个数和的最大值。\n\n对于2,计算[R,n]中2的个数和[pos,r-1]中1的个数和的最大值。” （网络）\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n,ans=0;\n    scanf(\"%d\",&n);\n    vector<int>a(n+2);\n    vector<int>pre1(n+2);\n    vector<int>pre2(n+2);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        pre1[i]=pre1[i-1]+(a[i]==1);\n    }\n    for(int i=n;i>=1;i--)\n        pre2[i]=pre2[i+1]+(a[i]==2);\n    for(int k=1;k<=n+1;k++)\n    {\n        int t1=0,t2=0;\n        for(int i=1;i<=k;i++)\n            t1=max(t1,pre1[i-1]+pre2[i]-pre2[k]);\n        for(int i=k;i<=n+1;i++)\n            t2=max(t2,pre2[i]+pre1[i-1]-pre1[k-1]);\n        ans=max(ans,t1+t2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n```\n\n","tags":["前缀和"],"categories":["算法"]},{"title":"839C Journey (简单dfs)","url":"/2018/03/25/839C-Journey-(简单dfs)/","content":"\n## [Journey](http://codeforces.com/problemset/problem/839/C)\n\n### 题意\n\nSeven Kingdoms 上有n个城市，他们之间由n-1条路连接，每个城市之间都无向连通，从第一个城市出发，每条路长度为1，若一个城市有x条岔路通向其他城市，那么这些城市的概率相同，均为1/x，走过的城市不会再走，那么一直走到走不了为止，求期望的路径长度？\n\n<!--more-->\n\n### 思路\n\n一看就是简单搜索，搜遍每条路，（zz的人永远不好好看题目，不是简单的路径/路的数量啊！），这里用结构体+vector来存图，结构体中加一个变量fencha来表示路径的分叉点，跑一下就好了。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct node{\n    vector<int>next;\n    double fencha;\n};\nint n;\ndouble all=0,way=0;\nint viss[100010];\nnode city[100010];\nvoid solve(int cur,int step,int vis[])\n{\n    int len=city[cur].next.size();\n    int flag=0;\n    for(int i=0;i<len;i++)\n        if(!vis[city[cur].next[i]])\n            flag++;\n    for(int i=0;i<len;i++)\n    {\n        if(!vis[city[cur].next[i]])\n        {\n            vis[city[cur].next[i]]=true;\n            city[city[cur].next[i]].fencha=city[cur].fencha*flag;\n            solve(city[cur].next[i],step+1,vis);\n            vis[city[cur].next[i]]=false;\n        }\n    }\n    if(flag==0||len==0)\n        all+=(1.0/city[cur].fencha)*step;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    int a,b;\n    if(n==1)\n    {\n        printf(\"0.000000000000000\\n\");\n        return 0;\n    }\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        city[a].next.push_back(b);\n        city[b].next.push_back(a);\n        viss[a]=viss[b]=false;\n        city[a].fencha=city[b].fencha=1;\n    }\n    viss[1]=true;\n    solve(1,0,viss);\n    printf(\"%.15f\\n\",all);\n    return 0;\n}\n```\n\n","tags":["dfs"],"categories":["算法"]},{"title":"954C Marix Walk(思维)","url":"/2018/03/23/954C-Marix-Walk(思维)/","content":"\n## [Marix Walk](http://codeforces.com/problemset/problem/954/C)\n\n### 题意\n\n走一个n*m的方格，一次走一格，上下左右都能走，输出使得这个走动合理的n，m大小。\n\n<!--more-->\n\n### 思路\n\n我真的是信了邪，直接输出***n=100000000***不就好了，mdzz。\n\n至于m的部分么，我们先不急，先来讲讲那个NO的情况:\n\n1. 原地不动\n2. 上下走的时候，非法 ，如：1 2 3 5\n3. 左右走的时候，非法，如： 1 2 3 6 7\n\n那么m怎么搞呢，如果是一个合法的走动，那么上下走的话，怎么走他们的差值都是不变的，也就是要求的m。\n\n微笑 微笑 ：）\n\n### 看！代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\nconst int N = 3e5 + 10;\nint a[N];\n\nint main()\n{\n    int n;\n    int y=1;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        if(i==0) continue;\n        if(a[i]==a[i-1])\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        if(abs(a[i]-a[i-1])!=1)\n            y=abs(a[i]-a[i-1]);\n    }\n    for (int i=1;i<n;i++)\n    {\n        if((abs(a[i]-a[i-1])!=1&&abs(a[i]-a[i-1])!=y))\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        if(a[i]%y==0&&a[i-1]-a[i]==1&&y!=1)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        else if(a[i]%y==1&&a[i]-a[i-1]==1)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n1000000000 %d\\n\",y);\n    return 0;\n}\n```\n\n","tags":["思维"],"categories":["算法"]},{"title":"今天份的快乐","url":"/2018/03/20/今天份的快乐/","content":"\n<!-- more -->\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**觉得SOUL是一个不错的APP。**\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**随性，也很清爽。**\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**昨天晚上日常丧病，随手发了一条瞬间：**\n<br/>\n![image](/mdpicture/1803121.jpg)\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**只是没有想到会有人这样回复，感觉很温暖**\n<br/>\n![image](/mdpicture/1803122.jpg)\n<br/>\n![image](/mdpicture/1803123.jpg)\n<br/>\n![image](/mdpicture/1803124.jpg)\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**感谢来自陌生人的，算是小小的关心吧。♥**\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"推荐blog","url":"/2018/03/16/参考博客/","content":"## 文字直接链接\n\n[美化](http://blog.csdn.net/com_ma/article/details/76039859)\n\n[插件什么的](https://www.jianshu.com/p/a52b68794a6b)\n\n[相册和音乐页](http://blog.csdn.net/u013775952/article/details/52524015?locationNum=4)\n\n[一个侧边隐藏音乐界面的hexo主题github](https://github.com/th720309/hexo-theme-believe)  [demo](http://www.tianhao.site/)\n\n[欢迎页面制作介绍](http://blog.lightina.cn/2016/10/27/HexoOverview/) [demo](https://jacklightchen.github.io/)\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"绑定域名","url":"/2018/03/16/绑定域名/","content":"\n1. 买一个域名并认证，如：xheartbeat.top\n\n   <!--more-->\n\n2. 解析域名：添加解析记录：\n\n   ​      A：@  192.30.252.154\n\n   ​      A :  @  192.30.252.153\n\n   ​     CNAME :  www   xxq1999.github.io\n\n3. hexo根目录source新建无后缀名的CNAME文件，并输入：\n\n   ​      xheartbeat.top（自己的域名）\n\n4. 然后hexo g，hexo d\n\n5. 打开github，在setting上的GitHub Pages：Custom domain：填入域名\n\n6. 结束。\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"ZOJ 4011 Happy Sequence (DP)","url":"/2018/03/11/ZOJ 4011 Happy Sequence (DP)/","content":"## [Happy Sequence](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4011)\n\n### 题意\n找一组数列；要求长度为m，且数列的每一项都是前一项的倍数，且数字不大于n。\n\n\n<!-- more -->\n### 思路\n\n这道题用动态规划去做，首先找状态，我们设数组f[i][j]表示以i结尾且长度为j的happy sequence个数。\n\n那么状态方程则为：\n\nf[i][j]=sum（f[k][j-1]），k为i的所有因子\n\n解释一下状态方程：\n\n既然f[i][j]表示以i结尾且长度为j的happy sequence个数，那么在此类数列后面再加个i的倍数（i*k%i==0）也是一个happy sequence，所以以i结尾的长度为j的happy sequence个数为所有的以i的因子结尾的长度为j-1的happy sequence个数之和。\n\n### 参考代码\n\n\n```\n#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint f[2005][2005];\nvector<int>V[2005];\nvoid init()\n{\n    memset(f,0,sizeof(f));\n\n    for(int i=1; i<=2005; i++)V[i].clear();\n    for(int i=1; i<=2005; i++)\n    {\n        for(int j=1; j<=2005; j++)\n        {\n            if(j%i==0)\n            {\n                V[j].push_back(i);\n            }\n        }\n    }\n    for(int i=1; i<=2005; i++)f[i][1]=1;\n    for(int i=2; i<=2000; i++)\n    {\n        for(int j=1; j<=2000; j++)\n        {\n            for(int k=0; k<V[j].size(); k++)\n            {\n                f[j][i]=(f[j][i]%mod+f[V[j][k]][i-1]%mod)%mod;\n            }\n            f[j][i]%=mod;\n        }\n    }\n}\nint main()\n{\n    int t;\n    init();//直接一次性都算出\n    while(~scanf(\"%d\",&t))\n    {\n        while(t--)\n        {\n            int n,m;\n            scanf(\"%d%d\",&n,&m);\n            int sum=0;\n            for(int i=1; i<=n; i++)\n            {\n                sum=(sum+f[i][m])%mod;//将所有以不大于n的数结尾且长度为m的happy sequence个数加起来就是答案了\n            }\n            printf(\"%d\\n\",sum);\n        }\n    }\n\n}\n```\n\n参考自[网络](http://blog.csdn.net/zyy_1998/article/details/79511442/)\n\n","tags":["ZOJ"],"categories":["算法"]},{"title":"如何插入音乐","url":"/2018/03/09/插入音乐/","content":"\n<ol>\n    <b/><li>使用GIT BASH在根目录安装下列插件：<li>\n\t<p>npm install hexo-tag-dplayer </p>\n    <p>npm install hexo-tag-aplayer</p>\n\n<!--more-->\n\n​\t<li>打开[网易云音乐](http://music.163.com/)</li>\n    <li>搜索你喜欢的音乐，点开歌名，然后点击“生成外链播放器”\n    <li>选择iframe插件，复制代码\n    <li>在负责需要放置该播放器的代码文件的最后粘贴该代码：\n    如：我在左边的菜单底部放置，那么我选择了\n    \\themes\\sw\\layout\\_partial 中的left-col.ejs 文件，粘贴了以下代码：\n\n```\n<div style=\"position:absolute; bottom:0px; left:0px; width:76%\">\n\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=80 src=\"//music.163.com/outchain/player?type=2&id=504797899&auto=1&height=66\"></iframe>\n\n</div>\n```\n**注意，div中的style，bottom为距离底部的高度，left为距离左边的宽度，中间的代码块是复制的网易给的代码，而里面的width和height可以自己调节。**","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"后青春期的诗","url":"/2018/03/09/后青春期的诗/","content":"\n18/03/09\n>  **“ 盛夏正要一天一天一天的灿烂“ ** \n\n\n<!-- more -->\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;不知不觉，已经是大二，即将大三了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;愧疚的是，定下的目标、曾经的方向，都没有实现。\n\n&nbsp;&nbsp;&nbsp;&nbsp;周围的人一点一点学习，一点一点进步。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上课的时候，听老师讲那些往届的学长学姐的故事，成就非凡，事业前途也一片光明；下课了之后，看网路上大神们讲述着自己成功的经历，感叹着某某某真是厉害呀，某某某太叼啦，又会为自己的未来担忧。\n\n&nbsp;&nbsp;&nbsp;&nbsp;不爱刷题，对算法提不起兴趣，在ACM的道路上慢慢被赶超，然后只能划划水。\n\n&nbsp;&nbsp;&nbsp;&nbsp;我希望总要有一样东西，是我现在能够做的，做到底的，于是借由这个个人网站，督促自己。\n<br/>\n<br/>\nP.S.感谢大佬的模板 ❤\n","tags":["随想"],"categories":["Life & Story"]},{"title":"进度条颜色修改","url":"/2018/03/09/进度条颜色修改/","content":"\n**在路径：*/theme/sw/source/css/path/path-theme-flash.css* 中，找到代码：**\n\n```\n.pace .pace-progress {\n  background: #FFB6C1;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n```\n\n**修改background颜色即可。**\n**本站颜色为<span  style=\"color:#FFB6C1\">浅粉</span>。**\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"小心心送给你","url":"/2018/03/09/如何鼠标点击出爱心/","content":"\n\n\n**1、在/theme/sw/source/js/src 中创建一个js文件**（eg. ***love.js***，没有src文件夹就创建一个）\n**2、复制下列代码到*love.js*中：**\n\n<!--more-->\n<br/>\n\n```\n    !function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);\n```\n\n代码块似乎显示不全，[这里](http://7u2ss1.com1.z0.glb.clouddn.com/love.js)是源代码\n\n**3、在/theme/sw/layout/layout.ejs 的<u>最后面</u>添加下列代码：**\n```\n<!-- 页面点击小红心 -->\n<script type=\"text/javascript\" src=\"/js/src/love.js\"></script>\n```\n**4、结束~**\n\n<br/><br/>\n参考自网路","tags":["网站优化"],"categories":["Web Dairy"]}]
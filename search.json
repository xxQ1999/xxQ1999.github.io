[{"title":"个人取向变化记录","url":"/2020/09/17/lyrics/","content":"\n每当我偶尔翻到以前写的、或者是摘录的文字的时候，总是感觉，咦……原来我那时候是这种调调啊……啧啧啧……\n\n好奇自己究竟有什么“审美”上的变化过程，顺便也摘一些喜欢的句子，开了这部分记录，给自己以后回过头来翻看的时候用。\n\n<!--more-->\n\n## 音乐\n\n*21岁，自己最喜欢的还是音乐*\n\n------\n> 在幻妙的时间里 有 望喜 和奇遇\n>\n> 在嘈杂的城市间 有永恒 的相遇\n>\n> 在有生之年里 常相伴 有知己\n>\n> 在漫妙的年龄享有 诚挚的 爱情\n>\n\n**[ 勐巴拉娜西 ]** 刺猬的歌总是能给我带来许多惊喜。这一段是最后子健写给小春天的祝福，真的很美好。\n\n\n\n## 文学\n\n> 愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火，我便是唯一的光。\n>\n> 倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。\n\n**[ 热风 · 随感录四十一 ]** \n\n\n\n> 我凭依栏杆，细看那萤火虫。我和萤火虫双方都长久地一动未动。只有夜风从我们身边掠过。榉树在黑暗中磨擦着无数叶片，籁籁作响。 \n>\n> 我久久、久久地等待着。\n>\n> 过了很长很长时间，萤火虫才起身飞去。它顿有所悟似的，蓦地张开双翅，旋即穿过栏杆，淡淡的萤光在黑暗中滑行开来。它绕着水塔飞快地曳着光环，似乎要挽回失去的时光。为了等待风力的缓和，它又稍停了一会儿，然后向东飞去。 \n>\n> 萤火虫消失之后，那光的轨迹仍久久地印在我脑海中。那微弱浅淡的光点，仿佛迷失方向的魂灵，在漆黑厚重的夜幕中往来彷徨。\n>\n> 我几次朝夜幕中伸出手去，指尖毫无所触，那小小的光点总是同指尖保持着不可触及的距离。\n\n**[ 萤 ]** 读了一遍《萤》，过程中一直被那种从何而来的悲伤笼罩着，心里又很安静很安静。\n\n","tags":["模板"],"categories":["Life & Story"]},{"title":"幻象波普星","url":"/2020/09/16/资源/","content":"\n## 音乐区\n\n- 《还愿》游戏原声带压缩包  [百度网盘 提取码: 9m7x]( https://pan.baidu.com/s/1QNMD75Z28f3BJm-4MrTedQ \"《还愿》\")\n\n\n\n## 书籍区\n\n- 《迷茫的旅行商：一个无处不在的计算机算法问题》[百度网盘 提取码：tix6 ](https://pan.baidu.com/s/1BQpElAkrS1XfGQAwDmhoIQ \"l旅行商问题\")\n\n- 《三体》（epub格式）[百度网盘 提取码：zch6](https://pan.baidu.com/s/1WJo_8nG2cqLilXdOgSQxQQ ) ","tags":["下载"],"categories":["资源"]},{"title":"把苦难也熬成绿豆汤","url":"/2020/05/18/考研/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=516358164&auto=0&height=66\"></iframe>\n\n什么时候能说明白自己心里的感受呢？\n\n## 得过且过汤\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚踏入二零二零年的时候，谁都没有想到接下来的几个月会这样过去。我对此感到不可思议，因为我常常思考的一个问题总是，“为什么是我呢”。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;奶奶说，我们晓青今年22岁，就是人生中会遇到坎的时候。大四，并不顺利的毕业设计，不上不下的初试成绩，divorce，急性肠胃炎，虚弱乏力，整日熬夜，昼夜颠倒……发胖，death。virus又好像让全世界的人都一起陪我倒霉。对啊，为什么呢？为什么这样一切都偏巧赶在一块儿了呢？\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我不知道，此刻的我既唯物，又唯心，还是个主观唯心。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样一段时间，我陷入焦虑和压抑，常常喜欢逃避。抓住一切可以出门的机会，去找他，去外边，离我的电脑越远越好，我不要想起这些东西，不要提起。我甚至开始恐惧，我怕如果考上了研究生，生活会更糟糕，于是我放弃了复试准备，我开始报名事业编制，一边询问身边所有人企图得到认同。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放弃，听起来很可惜吧？\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是消极成了全部。我真的很想要一碗汤，喝了这汤，一睡三天，只求结果，不问过程。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**幸好，没有这汤，夏天也会来的。**\n\n## 一个既幸运又幸福的家伙\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得自己很倒霉。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种倒霉就是每次做选择的时候，总能挑到最糟糕的那个。有的人就相反，运气总是很好。老实说我很嫉妒，并且无能为力。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;……可我好像也蛮幸运的。在关键时刻上，常常以为自己不行了，结果却出人意料。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于幸福，真的，平时感觉不到。唯有遇到苦难，才能在退出来之后，发现，哦，**我原来是幸福的**。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就比如现在。\n\n## MYSTERY OF LOVE\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我记得有一天我就躺在床上，然后阳台的门半开着，但是外面是阴天。我打开网易云，mystery of love，轻快明亮的曼陀铃，舒肤佳的声音唱着，我看着天花板，单曲循环一整个下午，然后阳光居然透过了云层中最薄的地方，照在了窗帘上……\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也没有什么特别的，只是当时特别安静，想起前一天晚上刚闹过脾气，听过家人朋友的安慰，告诉我没关系，很担心自己。哎，再难也就这样吧，我想，也没什么大不了的，对吧？\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;房间里变得有点热热的，我换上了裙子，哦，穿不下了，不过没问题，他们不会嫌弃我的。**裙子，裤子，其实都一样的，两个选择而已。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那天我发了这样的一条心情：\n\n> Mystery of Love\n> 无论第几次听都会被惊艳到\n> 无论现在是什么季节天上有几朵乌云\n> 我好像就能从这间小小的，阴阴的屋子里看到了\n> 那片森林，瀑布，草地，溪流，山脉，土壤……\n> 生机勃勃的绿色从心底长出来了\n> 空气变得热腾腾\n> 喷泉无力的在暴晒下工作着\n> 冰凉的 泳池的水\n> 皮肤就要黏糊糊的了\n> 眯缝着眼睛\n> 和你分享一半的雪糕\n>\n> ……\n>\n> 阳光透过了黄色带花的窗帘\n> 不用想象，夏天已经来了 \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，其实跟这首歌没关系，我知道夏天已经来了。\n\n<br/>\n\n<img src=\"https://xheartbeat.top/mdpicture/2020051802.jpg\"  alt=\"光\" />","tags":["随想"],"categories":["Life & Story"]},{"title":"承诺","url":"/2020/01/18/承诺/","content":"\n![word2](https://xheartbeat.top/mdpicture/word2.jpg)![word1](https://xheartbeat.top/mdpicture/word1.jpg)\n\n"},{"title":"How many integers can you find（容斥裸）","url":"/2018/09/08/How-many-integers-can-you-find（容斥裸）/","content":"\n# [How many integers can you find](http://acm.hdu.edu.cn/showproblem.php?pid=1796)\n\n## 题意\n\n一个n，一个长度为m的集合，集合里面有m个元素，问小于n的所有能被集合中任意元素整除的数字有多少。\n\nn<2^31,m<=10\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 25;\nint p[MAXN];\nint n;\nint m;\nint Result;\n\nint GCD(int a, int b) { //欧几里得算法，求最大公约数。\n    if (b == 0) return a;\n    else return GCD(b, a % b); //辗转相除。\n}\n\nint LCM(int a, int b) { //求最小公倍数。\n    return a / GCD(a, b) * b;\n}\n\nint Solve(int n) { //深度优先搜索实现容斥原理。\n    int i, j;\n    int Cnt_Manifold; //遍历到的数的数量（数集的数量）。\n    int Least_Common_Multiple; //遍历到的Cnt_Manifold个数的最小公倍数。\n    Result = 0; //记录每次深度搜索的结果。\n    for (i = 1; i < (1 << m); i++) { //i的二进制位代表此次遍历查找的是那几个数\n        Cnt_Manifold = 0;\n        Least_Common_Multiple = 1; //1与任何数的最小公倍数还是那个数本身，所以初值赋为1.\n        for (j = 0; j < m; j++)\n            if (i & (1 << j)) { //筛选出要找的数并求出他们的最小公倍数。\n                Cnt_Manifold++;\n                Least_Common_Multiple = LCM(Least_Common_Multiple, p[j]);\n            }\n        if (Cnt_Manifold & 1) { //奇数个为正偶数个为负，其作用相当于(-1)^(n - 1).\n            Result += n / Least_Common_Multiple;\n        }\n        else {\n            Result -= n / Least_Common_Multiple;\n        }\n    }\n    return Result;\n}\n\nint main() {\n    int cnt;\n    int temp;\n    while (cin >> n >> m) {\n        cnt = 0;\n        for (int i = 0; i < m; i++) {\n            cin >> temp; //去除了0的情况\n            if (temp) {\n                p[cnt++] = temp;\n            }\n        }\n        m = cnt;\n        cout << Solve(n - 1) << endl;\n    }\n    return 0;\n}\n```\n\n","tags":["容斥"],"categories":["算法"]},{"title":"容斥与鸽巢定理","url":"/2018/08/31/容斥与鸽巢定理/","content":"\n# 容斥\n\n## 公式\n\n$$\n|A_1∪A_2∪…∪A_n|=\\sum_{i=1}^n|A_i|-\\sum_{i=1}^n\\sum_{j>i}|A_i∩A_j|+\\sum_{i=1}^n\\sum_{j>i}\\sum_{k>j}|A_i∩A_j∩A_k|+…\n$$\n\n$$\n+(-1)^{n-1}|A_1∩A_2∩…∩A_n|\n$$\n\n\n\n## 应用\n\n### 错排问题\n\n[【已写】](http://xheartbeat.top/2018/08/14/%E9%94%99%E6%8E%92%EF%BC%88%E5%85%AC%E5%BC%8F+%E4%B8%89%E7%A7%8D%E7%94%9F%E6%88%90%EF%BC%89/)\n\n### 棋盘多项式与有禁区的排列\n\n#### 布棋问题\n\n一个n*m棋盘上放k个棋子，其中任意两个棋子不能位于同一行或者同一列上。问种数。\n\n**布棋方案数** $R_k(C)$ **:** k个棋子依照上述规则放在棋盘C中的方案数\n\n**棋盘多项式：** 棋盘C中放不限定数量的棋子,$R(C)=\\sum_{k=0}^∞R_k(C)x^k$（有点母函数的味道），由于k<=C(格子数)，因此这个多项式也是有限的。\n\n**放置：**  $R_k(C)=R_{k-1}(C_x)+R_k(C_e)$\n\nC表示这个棋盘，$C_x$表示放在棋盘C除去这个格子所在的行和列之后的棋盘，$C_e$表示棋盘C删去这个格子后的棋盘。\n那么这个公式的意思就是，在棋盘C上放k个棋子的种数，等于（第k个棋子放在一个格子上，前k-1个数量的格子放在除了这个格子所在的行和列的地方），加上，（k个棋子放在除了这个格子的其他地方）。\n\n**棋盘多项式性质：**\n\n1. $R(C)=xR(C_x)+R(C_e)$\n2. 若C由两个互不干扰的棋盘组成，有$R(C)=R(C_1)·R(C_2)$\n\n\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E7%A6%81%E5%8C%BA%E6%A3%8B%E7%9B%98%E6%8E%92%E5%88%97%E5%AE%9E%E4%BE%8B.jpg\" height=\"635\" width=\"413\" alt=\"棋盘排列构造多项式，利棋盘多项式的性质，如图\">\n\n\n\n#### 有禁区的排列\n\n**排列数定理：**\n$$\nn！-r_1(n-1)!+r_2(n-2)!-…±r_n\n$$\n$r_i$表示有$r_i$个棋子布置到禁区的方案数。（***仅适用n·n的棋盘***）\n\n**< 例题 >** 有1,2,3,4号工人，A,B,C,D四个人物，1号不做B，2号不做B、C，3号不做C、D，4号不做D，问有多少种分配方式？\n\n【解】先构造一个4*4的棋盘，然后画出这个棋盘的禁区，对于这个禁区计算它的棋盘多项式，得$R(C)=1+6x+10x^2+4x^3$，因此用容斥的思想，得到：\n$$\n4!- 6·(4-1)!+10·(4-2)!-4·(4-3)! +0(4-4)!= 4\n$$\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E7%A6%81%E5%8C%BA%E6%A3%8B%E7%9B%98%E4%BE%8B%E9%A2%98.jpg\" height=\"123\" width=\"296\"  alt=\"例题棋盘禁区如图所示，构造的多项式原理同上图\">\n\n# 鸽巢定理\n\n## 基本定理\n\n**n+1只鸽子飞回n个鸽巢，至少有一个鸽笼含有不少于2只的格子。**\n\n**数学描述：**\n\n**m($1\\le m$)个元素分成n个组，那么总有一个组至少含有元素个数$\\lceil\\frac{m}{n}\\rceil$**\n\n## 小应用\n\n1. **对于正整数序列，$a_1，a_2，…，a_m$，至少存在整数k和l, $1\\le k<l\\le m$，使得$a_k+a_{k+1}+…+a_l$是m的倍数。**\n\n   【证明】对每个元素$a_i$构造一个前缀和sum[i]，则有两种可能性：\n\n   (1) 若有一个sum[i]是m的倍数，则证毕；\n\n   (2) 若没有一个sum[i]为m的倍数，则令$r_h\\equiv S_h mod\\ m $ 。\t\n\n   其中，h=1,2,…,m，我们已知上面所有的项都非m的倍数，故余数r[i]的范围在[1,m-1]，共m个数，根据鸽巢定理，m个余数在[1,m-1]共m-1的范围内至少存在一对$r_h$,$r_k$，满足$r_k=r_h$,则sum[k]和sum[h]满足：\n   $$\n   S_k\\equiv S_h mod \\ m\n   $$\n   设h>k的话，得到\n   $$\n   S_h-S_k=(a_1+a_2+…+a_h)-(a_1+a_2+…+a_k)\n   =a_{k+1}+…+a_h\\equiv 0\\ mod \\ m\n   $$\n   证毕。\n\n2. **中国剩余定理**\n","tags":["学习"],"categories":["算法"]},{"title":"GCD?LCM!(莫比乌斯反演)","url":"/2018/08/20/GCDLCM!(莫比乌斯反演)/","content":"\n# [ GCD?LCM!](http://acm.hdu.edu.cn/showproblem.php?pid=5382)\n\n## 题意\n\n哈哈哈哈哈懵逼钨丝做的我一本满足，爽歪歪，推公式好塔马有趣儿\n\n咳咳，题目是：\n$$\nF(n)=\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\\ge n]\n$$\n\n$$\nS(n)=\\sum_{i=1}^nF(n)\n$$\n\nt组，每组给你一个n，求S(n)。\n\nt<=1e5,n<=1e6\n\n\n\n## 思路\n\n$$\nF(n)=\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\\ge n]\n$$\n\n$$\n=\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\\ge n-1]-\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n-1]\n$$\n\n`由于对于后半部分来说，i，j=n时显然不符合，因此可直接降为n-1`\n$$\n=\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)\\ge n-1]-\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]\n$$\n`将前半部分转化成F(n-1)，故修改i，j的上限，而i，j=n时一定满足要求，因此要补上2n-1`\n$$\n=\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)\\ge n-1]+(2n-1)-\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]\n$$\n\n$$\n=F(n-1)+(2n-1)-\\sum_{i=1}^{n-1}\\sum_{j=1}^{n-1}[lcm(i,j)+gcd(i,j)==n-1]\n$$\n\n`令后半部分为T(n-1),则：`\n$$\nF(n)=F(n-1)+(2n-1)-T(n-1)\n$$\n接下来分析T(n)\n$$\nT(n)=\\sum_{i=1}^n\\sum_{j=1}^n[lcm(i,j)+gcd(i,j)==n]\n$$\n令d=gcd(i,j)，又由于lcm(i,j)=ij*(gcd(i,j))，令i=id，j=jd\n$$\n=\\sum_{d|n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\n[ijd+d==n][gcd(i,j)==1]\n$$\n\n$$\n=\\sum_{d|n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\n[j=\\frac{\\frac{n}{d}-1}{i}][gcd(i,j)==1]\n$$\n\n$$\n=\\sum_{d|n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\n[gcd(i,\\frac{\\frac{n}{d}-1}{i})==1]\n$$\n\n由于$\\ i = \\frac{n}{d}$ 时，条件显然不成立，因此修改i的上限\n$$\n=\\sum_{d|n}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor-1}\n[gcd(i,\\frac{\\frac{n}{d}-1}{i})==1]\n$$\n令后半部分为$ G(\\frac{n}{d}-1) $\n$$\nT(n)=\\sum_{d|n}G(\\frac{n}{d}-1)\n$$\n接下来分析G(n)\n$$\nG(n)=\\sum_{i=1}^n[gcd(i,\\frac{n}{i})==1]\n$$\n要满足后半部分，我们打表（或者根据思考（？？？））发现\n$$\nG(n)=2^k,k为n的质因子个数\n$$\n那么到这里，基本上要推的就都推完了，\n\n差一个总和。\n\n由于：\n$$\nF(n)=F(n-1)+(2n-1)-T(n-1)\n$$\n\n$$\n=F(n-2)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)\n$$\n\n$$\n=F(n-3)+(2(n-2)-1)-T(n-3)+(2(n-1)-1)-T(n-2)+(2n-1)-T(n-1)\n$$\n\n$$\n……\n$$\n\n$$\n=F(1)+\\sum_{i=1}^n(2i-1)-\\sum_{i=0}^{n-1}T(i)\n$$\n\n故：\n$$\nS(n)=\\sum_{i=1}^n(F(1)+\\sum_{j=1}^i(2j-1)-\\sum_{j=0}^{i-1}T(j))\n$$\n\n$$\nS(n)=nF(1)+\\sum_{i=1}^ni^2-\\sum_{i=1}^n\\sum_{j=0}^{i-1}T(i)\n$$\n\n$$\n=n+\\frac{n(n+1)(2n+1)}{6}-\\sum_{i=1}^n\\sum_{j=0}^{i-1}T(i)\n$$\n\n我们一步一步来：\n\n1. 预处理，先筛出所有质数，然后是1~1e6的质因子个数，然后求得G(n)，再求得T(n)，然后对T(n)求一次前缀和得到每个sum[i]，再对每个sum[i]求前缀和ans[i]=sum[i-1]+ans[i-1]。\n2. 没有2了，对于每个输入的n直接用刚刚最后那个公式带进去算就好了：\n\n$$\nS(n)=n+\\frac{n(n+1)(2n+1)}{6}-ans[n]\n$$\n\n哦，别忘了取模。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000010;\nconst int MOD=258280327;\n/** 对于μ函数的线筛 */\nint prim[N];\nbool vis[N]={0};\nint cnt=0;\nll p[N]={0};\nll sum[N]={0},ans[N]={0};\nll liu;\n\nll PowerMod(ll x,ll n)\n{\n    ll res=1;\n\twhile(n>0)\n\t{\n\t   if(n%2==1)\n\t   {\n\t   \t res=res*x;\n\t   \t res=res%MOD;\n\t   }\n\t   x=x*x;\n\t   x=x%MOD;\n\t   n>>=1;\n\t}\n\treturn res;\n}\n\n\nvoid Solve(ll N)\n{\n    for(int i=2;i<N;i++) //素数筛\n    {\n        if(vis[i]==false)prim[++cnt]=i;\n        for(int j=0;j<cnt&&i*prim[j]<N;j++)\n            vis[i*prim[j]]=true;\n    }\n\n    for(int n=1;n<=N;n++) //求质因子个数\n    {\n        int tmp=n;\n        for(ll i=1;prim[i]*prim[i]<=tmp; i++)\n        {\n            if(tmp%prim[i]==0)\n            {\n                p[n]++;\n                while(tmp%prim[i]==0) tmp/=prim[i];\n            }\n        }\n        if(tmp>1)\n            p[n]++; \n    }\n\n    for(int i=1;i<=N;i++)  //求2^k\n        p[i]=PowerMod(2,p[i]);\n    for(int d=1;d<=N;d++)  //  求T(n)\n    {\n        for(int k=1;k*d<=N;k++)\n        {\n            sum[k*d]=(sum[k*d]+p[k-1])%MOD;\n        }\n    }\n    sum[0]=1;\n    for(int i=1;i<=N;i++) //求sum[n]\n    {\n        sum[i]=(sum[i]+sum[i-1])%MOD;\n    }\n    for(int i=1;i<=N;i++) //求ans[n]\n    {\n        ans[i]=(sum[i-1]+ans[i-1])%MOD;\n    }\n}\n \nll cal(ll n) \n{\n    return n*(n+1)%MOD*(2*n+1)%MOD*liu%MOD;\n}\n\nint main()\n{\n    liu=PowerMod(6,MOD-2);\n    Solve(1000000);\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        printf(\"%lld\\n\",(cal(n)+n-ans[n]+MOD)%MOD);\n    }\n    return 0;\n}\n\n```\n\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"带劲and和（连通块+&结论）","url":"/2018/08/20/带劲and和（连通块+&结论）/","content":"\n# [带劲的and和](http://acm.hdu.edu.cn/showproblem.php?pid=6411) \n\n## 题意\n\n度度熊有一张n个点m条边的**无向图**，第i个点的点权为vi。\n如果图上存在一条**路径**使得点i可以走到点j，则称i,j是**带劲**的，记f(i,j)=1；否则f(i,j)=0。显然有f(i,j)=f(j,i)。\n度度熊想知道求出：\n$\\sum_{i=1}^{n−1}\\sum_{j=i+1}^nf(i,j)×max(v_i,v_j)×(v_i\\&v_j)$\n其中&是C++中的and位运算符，如1&3=1, 2&3=2。\n请将答案对109+7取模后输出。\n\n\n\n ## 思路\n\n先处理连通块。\n\n这里我用的是并查集，也可以用tarjan，然后对于每个连通块里的元素，我们按照从小到大排序。\n\n由于比如 9 8 7 这部分时，默认我们已经知道9是最大的元素，那么一定是9*(9&8+9&7),由于与运算是只有两位上的数字均为1时才能有贡献，那么也就是说，我们不需要对于每两个数字都计算&运算，而可以对每一个数字的二进制位进行处理，当第i位上为1时，count[i]++，只有count[i]上的数>=2时，才算对于这个有了贡献，并且我们是用同一的9去进行与运算，在count位>=2时，也只有满足当9上的第i位也为1时才算数。\n\n因此从小到达排序之后，从第一个元素开始，在它前面的元素一定比它小，因此我们只要对于这个元素上为1的位进行查询，看它的count是否大于等于2，然后确定是否产生贡献，ans+了后再把当前元素的这一位的count[i]++即可。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nconst int MOD=1e9+7;\nint id[N];\nint sz[N];\n\nlong long val[N];\nint Find(int x)  ///找跟根结点\n{\n    while(x!=id[x])\n    {\n        id[x]=id[id[x]];\n        x=id[x];\n    }\n    return x;\n}\n\nint un(int p,int q)\n{\n    int pr=Find(p);\n    int qr=Find(q);\n    if(pr==qr) return -1;\n    if(sz[pr]<=sz[qr])\n    {\n        sz[qr]+=sz[pr];id[pr]=qr;\n    }\n    else\n    {\n        sz[pr]+=sz[qr];id[qr]=pr;\n    }\n}\n\nvoid clear()\n{\n    for(int i=1;i<=N;i++)\n    {\n        id[i]=i;sz[i]=1;\n    }\n}\n\nbool cmp(long long a,long long b)\n{\n    return a>b;\n}\nint main()\n{\n    int t,n,m,u,v;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        clear();\n        vector<long long>fa[100010];\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)\n            scanf(\"%lld\",&val[i]);\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            un(u,v);\n        }\n        for(int i=1;i<=n;i++)\n        {\n            fa[Find(i)].push_back(val[i]);\n        }\n        long long ans=0;\n        int len=0;\n        for(int i=1;i<=n;i++)\n        {\n            len=fa[i].size();\n            if(len>1)\n            {\n                sort(fa[i].begin(),fa[i].end());\n                int wei[32]={0};\n                for(int j=0;j<len;j++)\n                {\n                    long long tmp=fa[i][j];\n                    for(int k=0;k<=30&&tmp>0;k++)\n                    {\n                        if(tmp&1)\n                        {\n                            ans=(ans+1ll*wei[k]*fa[i][j]%MOD*(1<<k)%MOD)%MOD;\n                            wei[k]++;\n                        }\n                        tmp>>=1;\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\t\n```\n\n","categories":["算法"]},{"title":"Mophues(莫比乌斯反演)","url":"/2018/08/20/Mophues(莫比乌斯反演)/","content":"\n# [  Mophues](http://acm.hdu.edu.cn/showproblem.php?pid=4746) \n\n## 题意\n\n若a的质因子个数<=P，则称a为p的一个lucky number。\n\n给你n，m，P，求在n，m范围内的i，j，gcd(i,j)是P的lucky number，这样的i，j有几对？\n\nn，m，P<=5e5。多组不超过5000组。\n\n## 思路\n\n题意就是让我们求：\n$$\n\\sum_{i=1}^n\\sum_{j=1}^mf(gcd(i,j)),其中f(x)表示x的质因子个数比p小\n$$\n反演过程就不具体写了，我们可以轻松得到结果：\n$$\n\\sum_{t=1}^{min(n,m)}\\lfloor\\frac{n}{t}\\rfloor\\lfloor\\frac{m}{t}\\rfloor\\sum_{d|t}f(d)μ(\\frac{t}{d})\n$$\n经过计算我们发现，5e5内的数字最大的质因数个数为18，那么对于大于18的p我们就可以降为18。\n\n首先对5e5内的数预处理出它们的质因子个数。\n\n然后枚举d，用sum[i]\\[j]表示当t=i时，质因子个数为j的数的μ之和。\n\n再对sum[i]\\[j]求t=i时质因子个数小于等于j的μ之和。\n\n然后对每一个t的sum求一个前缀和。\n\n就可以分块做了。\n\n注意ans和sum还是要开longlong。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=500010;\nconst int MOD=1e9+7;\n/** 对于μ函数的线筛 */\nint mu[N],prim[N];\nbool vis[N]={0};\nint cnt=0;\nll p[N]={0};\nll sum[N][21]={0};\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n\n}\nvoid Solve(ll N)\n{\n    //int MAX=0;\n    for(int n=1;n<=N;n++)\n    {\n        int tmp=n;\n        for(ll i=1;prim[i]*prim[i]<=tmp; i++)\n        {\n            while(tmp%prim[i]==0) p[n]++,tmp/=prim[i];\n        }\n        if(tmp>1)\n            p[n]++;  //这个不可以缺少\n        //MAX=max(MAX,p[n]);\n    }\n    for(int d=1;d<=N;d++)\n    {\n        for(int k=1;k*d<=N;k++)\n            sum[k*d][p[d]]+=mu[k];\n    }\n    for(int t=1;t<=N;t++)\n    {\n        for(int i=1;i<=18;i++)\n            sum[t][i]+=sum[t][i-1];\n    }\n    for(int i=0;i<19;i++)\n    {\n        for(int t=1;t<=N;t++)\n            sum[t][i]+=sum[t-1][i];\n    }\n}\n\n\nint main()\n{\n    int t,n,m,u,v;\n    get_mu(500000ll);\n    Solve(500000ll);\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,m,P;\n        scanf(\"%d%d%d\",&n,&m,&P);\n        if(P>18) P=18;\n        int MIN=min(n,m);\n        long long ans=0;\n        for(int l=1,r;l<=MIN;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l));\n            ans+=1ll*(n/l)*(m/l)*(sum[r][P]-sum[l-1][P]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"CA Loves GCD(DP)","url":"/2018/08/19/CA-Loves-GCD(DP)/","content":"\n# [CA Loves GCD](http://acm.hdu.edu.cn/showproblem.php?pid=5656) \n\n## 题意\n\n给你n个数，从里面任取几个（至少1个），计算它们的gcd，问你所有可能的取法的gcd之和。\n\n对结果模1e8+7（注意是8）\n\nn<=1000\n\n## 思路\n\ndp[i]\\[j]表示取前i个数时gcd为j的种数。\n\n取第i个时：dp[i]\\[gcd(a[i],j)] += dp[i-1]\\[j] ；\n\n不取第i个时：dp[i]\\[j] += dp[i-1]\\[j]；\n\n对1000内的任意两个数的gcd作预处理，i从0开始。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e8+7;\nconst int N=10000010;\nint dp[1010][1010]={0};\nint gcd[1005][1005];\nint a[1010];\n/*int ggcd(int a, int b) {\n    return b == 0 ? a : ggcd(b, a%b);\n}*/\n\nvoid init(int n)\n{\n    dp[0][0]=1;\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            gcd[i][j]=__gcd(i,j);\n            gcd[j][i]=gcd[i][j];\n        }\n    }\n}\n\nint main()\n{\n    init(1000);\n    int t,n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        memset(dp,0,sizeof(dp));\n        scanf(\"%d\",&n);\n        int MAX=-1;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&a[i]);\n            MAX=max(MAX,a[i]);\n        }\n        dp[0][0]=1;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=0;j<=MAX;j++)\n            {\n                dp[i][j]=(dp[i][j]+dp[i-1][j])%MOD;\n                dp[i][gcd[a[i]][j]]=(dp[i][gcd[a[i]][j]]+dp[i-1][j])%MOD;\n            }\n        }\n        int ans=0;\n        for(int i=1;i<=MAX;i++)\n            ans=(ans+1ll*dp[n][i]*i)%MOD;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n```\n\n","tags":["dp"],"categories":["算法"]},{"title":"Hillan and the girl(莫比乌斯反演)","url":"/2018/08/19/Hillan-and-the-girl(莫比乌斯反演)/","content":"\n# [Hillan and the girl](http://acm.hdu.edu.cn/showproblem.php?pid=5663) \n\n## 题意\n\n对于1<=n,m<=1e7，T<=1e4，求：\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{m}f(gcd(i,j)),其中f(x)=1，当且仅当x为平方数\n$$\n\n## 思路 \n\n来，让我们来反演一波：\n$$\n\\sum_{d=1}^{mim(n,m)}f(d)\\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)==d]\n$$\n\n$$\n\\sum_{d=1}^{min(n,m)}f(d)\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}[gcd(i,j)==1]\n$$\n\n$$\n\\sum_{d=1}^{min(n,m)}f(d)\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\sum_{t|gcd(i,j)}μ(t)\n$$\n\n$$\n\\sum_{d=1}^{min(n,m)}f(d)\\sum_{i=1}^{\\lfloor\\frac{n}{dt}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{dt}\\rfloor}\\sum_{t=1}^{min(\\lfloor\\frac{n}{d}\\rfloor,\\lfloor\\frac{m}{d}\\rfloor)}μ(t)\n$$\n\n$$\n\\sum_{d=1}^{min(n,m)}f(d)\\sum_{t=1}^{min(\\lfloor\\frac{n}{d}\\rfloor,\\lfloor\\frac{m}{d}\\rfloor)}μ(t){\\lfloor\\frac{n}{dt}\\rfloor}{\\lfloor\\frac{m}{dt}\\rfloor}\n$$\n\n令dt=T，则：\n$$\n\\sum_{T=1}^{min(n,m)}{\\lfloor\\frac{n}{T}\\rfloor}{\\lfloor\\frac{m}{T}\\rfloor\\sum_{d|T}f(d)}μ(\\frac{T}{d})\n$$\n由于$d=x^2$\n$$\n\\sum_{T=1}^{min(n,m)}{\\lfloor\\frac{n}{T}\\rfloor}{\\lfloor\\frac{m}{T}\\rfloor\\sum_{x=1}^{min(\\sqrt{n},\\sqrt{m})}\\sum_{x^2|T}}μ(\\frac{T}{x^2})\n$$\n对于T的前半部分，我们可以用分块，复杂度为$\\sqrt{n}$，对于后半部分，就可以预处理出来。\n\n枚举x，以及每一个$x^2$的倍数$k·x^2$，处理出每一个T的对应的值，然后再求前缀和。\n\n预处理部分的复杂度为O(n)，求的时候的复杂度为$O(T\\sqrt{n})$。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=10000010;\nint mu[N],prim[N];\nbool vis[N]={0};\nint cnt=0;\nlong long sum[N]={0};\nvoid get_mu(int n)\n{\n    mu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n            for(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n            vis[prim[j]*i]=1;\n            if(i%prim[j]==0)break;\n            else mu[i*prim[j]]=-mu[i];\n        }\n    }\n\n    for(int d=1;d*d<=n;d++)\n        for(int k=1;k*d*d<=n;k++)\n            sum[k*d*d]+=mu[k];\n\n    for(int i=1;i<=n;i++)\n        sum[i]+=sum[i-1];\n}\n\n\nint main()\n{\n    get_mu(10000000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        int MIN=min(n,m);\n        long long ans=0;\n        for(int l=1,r;l<=MIN;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l));\n            ans+=1ll*(sum[r]-sum[l-1])*(n/l)*(m/l);\n        }\n        printf(\"%lld\\n\",1ll*n*m-ans);\n    }\n    return 0;\n}\n```\n\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"はなび","url":"/2018/08/19/小偷家族/","content":"\n<img src=\"https://xheartbeat.top/mdpicture/海边.jpg\" alt=\"海边\">\n\n我发现日本的电影或者是电视剧，总是生活的样子，不会把片子的色调调的明亮而饱和，不会把每个人脸上的斑点、皱纹、坑坑洼洼悄悄隐藏，而让坐在荧幕前面的我们只看到光滑的皮肤和胶原蛋白。\n\n是走在大街上能看到的，二十多岁小姑娘，三四十岁的工厂的妇女，建筑工地上的工人，和蔼的老婆婆，还有那怯生生的孩子。\n\n是贫穷的屋子里面拥挤的住着五口人，角角落落塞得满满当当。\n\n是即使辛苦艰难，其中偷偷夹带着的小幸福。\n\n尽管我从一开始就知道，他们并不是”一家人“。\n\n尽管我想，要是一直在一起就好啦。\n\n柴田在废弃的车子中找到不高兴的祥太，告诉他由理是他”妹妹“，你要叫我”爸爸“（祥太一直叫不出口），瘸着腿在路上和祥太玩闹；\n\n信代和由理泡着澡，由理看见信代手臂上的伤疤，和妈妈用熨斗烫伤自己的伤疤一样，心疼的不停轻轻抚摸着信代受伤的地方，信代说谢谢你，已经一点都不疼啦；\n\n洗完澡把由理来时的旧衣服烧了，信代紧紧的抱着由理，悲伤的好像要把由理揉进自己的怀抱里。对由理说才不是由理的错，如果有人说爱你才打你，那才不是真的，如果爱你的话，就会像我这样，这样抱着你；\n\n大家一起看烟花，可是只听得见烟花的声音，却看不到烟花；\n\n小卖铺的爷爷早就知道祥太总是把东西偷偷顺走，只是当看到由理也学着祥太的样子偷窃，他学着他们偷东西前的手势，告诉祥太，以后不要叫你妹妹这样了，然后送了他们两个果冻，祥太问要继续偷吗，柴田说超市里放着的东西不属于任何人，除非倒闭了；\n\n大家一起去海边的时候，奶奶对信代说”你真漂亮，脸蛋“，后来信代也跑去和大家玩，然后奶奶一个人坐在沙滩上面，把沙子洒在自己长满老年斑的小腿上，看着这一瞬间的”家人们“，无声的说”谢谢你们“；\n\n信代为了保住由理，丢了工作，和柴田在家里吃着面，她走去厨房，雷雨前的最后一丝阳光透过窗户落进来，信代穿着透明凉快的衣服，汗水浸湿了头发，浸湿了脸庞，浸湿了胳膊，柴田看呆了，信代亲了柴田，然后终于打雷了，大雨来了，屋子里都是热乎乎，热乎乎的味道。\n\n但是总会被打破的。\n\n奶奶在从海边回来后的某天安静的离开了，柴田想打救护车，信代却说，你敢叫救护车吗。殡仪馆火化这么贵。我们哪有钱。由理也想和奶奶一直在一起吧。那我们就一直陪着奶奶吧。于是在自家挖坑把奶奶埋葬了。\n\n亚纪一直伤心。柴田对祥太说，我们一直是五个人，从来没有奶奶。\n\n信代取了奶奶的银行卡，找到了奶奶藏起来的钱，和柴田开心的大笑。\n\n柴田带着祥太砸车偷包，祥太开始不愿意这样做了。\n\n便利店的爷爷也去世了。祥太带着由理去超市，叫由理在外面等着。由理却跑进来想和哥哥一起偷。祥太看见还这么小的妹妹，笨拙的学着自己，把一包零食塞进自己的衣服里，塑料包装发出响声。他看了一会，在店员面前抢了一带柚子，转身就跑。然后被店员追上，从桥上跳下去。他终于认识到，这样的生活，已经不能再继续下去了。他是故意的呀。\n\n大家被发现了。想要抛下在医院的祥太逃跑，还是没有成功。\n\n”你们并不是一家人啊。“\n\n”奶奶的尸体呢？抛尸可是犯罪啊。“\n\n”为什么要诱拐孩子呢？“\n\n”柴田你啊，祥太是你的本名把？“\n\n”叫孩子偷窃，内心不会愧疚吗？“\n\n”听说那两个人是杀了前夫呢。“\n\n”奶奶一直有从你父母那里拿钱哦。“\n\n”是因为自己生不出孩子，才嫉妒别人，才会诱拐孩子的吧。”\n\n”树理（由理）的画颜色真好看呀，终于能回家了呢。“\n\n“祥太你呀，以后就能去学校上学啦。”\n\n”他们是怎么称呼你的呢？妈妈？母亲？“\n\n……\n\n解散了，这样的羁绊。\n\n道德的制高点，大概看不见渺小的尘埃。\n\n总会有些疑惑，比如为什么信代失业，柴田却理所当然的说你可以重拾老本行；奶奶死的时候，信代和柴田没有一点难过的样子，没过多久就拿了奶奶的养老金窃喜；为什么明明从前给了祥太这般的慈爱和体贴，却还是决定抛弃他，偷偷溜走。\n\n柴田追赶着公交车，大声呼喊祥太的名字，车上的祥太却只是向前看，无动于衷。但是末了却转过头，轻声的说了一声”爸爸“。祥太对柴田的爱的认可，是真的，希望自己能够追寻另一种人生，也是真的。\n\n只是柴田永远听不见这句”爸爸“，就像奶奶在海边说的”谢谢“，就像亚纪一直在从父母那里拿钱的时候，以为奶奶并不是喜欢她，才收留她的，是因为钱，她永远不知道奶奶一分钱没花。我想起她问柴田，维系两个人之间的东西到底是什么？是钱啊。\n\n是利益吗？让这个家庭组合在一起？\n\n我想是的，私利是让他们走在一起的原因，是让他们一起生活的原因，是让他们选择彼此的原因。这并不影响我对你的关心。只是这样的选择，比起自己原本的人生，好了太多了。\n\n私欲是真的，背叛是真的，爱也是真的。\n\n无法讨论人性，因为无情之中又饱含着万千真情。\n\n世界并不是完美的乌托邦，也并非地狱的修罗场。\n\n每个人都有每个人的活法。\n\n也许我根本没有看懂这部电影，很多人都说看不懂。只是很喜欢这样的电影。我想起自己看《人间失格》电影的时候，开头，一条弹幕：\n\n”你不需要看懂这部电影，你只要知道，有人这样活着就好了。“\n\n\n\n\n\n> 他呈现的不是道德的是非，而是道德的困境。\n>\n> 他帮你撕掉人们身上的标签，让你看见那一个一个人。那些和你一样，有血有肉，有夜里开着灯等他们回家的亲人。\n>\n> 他尽力展现生活的复杂，让你看到算计，也看到算计背后的温情，让你了解，体谅，让你珍惜”有点肮脏的世界，忽然变得美好了起来的瞬间。“","tags":["随想"],"categories":["Life & Story"]},{"title":"整数划分(裸五边形定理)","url":"/2018/08/17/整数划分(裸五边形定理)/","content":"\n### [不可重复的数字划分](https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1201)（基础dp）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 50005;\nconst LL MOD = 1e9+7;\nint dp[MAXN][350];\nint main()\n{\n  //  int n,m,cas=1;\n    int ans;\n    int n;\n   // five();\n    while(~scanf(\"%d\",&n))\n    {\n        ans=0;\n        memset(dp,0,sizeof(dp));\n        dp[0][0]=1;\n        for(int i=1;i<=n;i++)\n            for(int j=1;j*(j+1)<=i*2;j++)\n            dp[i][j]=(dp[i-j][j-1]+dp[i-j][j])%MOD;\n            //1.i-j的数，j-1个划分，每个划分数+1，再加上1的划分；2.i-j的数。j个划分，每个划分数+1\n        for(int i=1;i<=350&&dp[n][i]!=0;i++)\n            ans=(ans+dp[n][i])%MOD;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n### [1259 整数划分 V2](https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1259)\n\n```c++\n//可重复的划分，五边形定理\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 1e9+5;\nconst int MAXN = 50005;\nconst LL MOD = 1e9+7;\nusing namespace std;\nint n;\nlong long q[405],f[MAXN];\nlong long dp[MAXN];\nvoid five()\n{\n    for(int i=1;i<=400;i+=2)\n    {\n        LL temp=(i+1)/2;\n        q[i]=(3*temp*temp-temp)/2;\n        q[i+1]=(3*temp*temp+temp)/2;\n       // printf(\"%lld,\",q[i]);\n    }\n    f[0]=1;\n    for(int i=1;i<=MAXN;i++)\n    {\n        for(int j=1,c=1;j<=400;j+=2,c*=-1)\n        {\n            if(i-q[j]<0) break;\n            f[i]=(f[i]+f[i-q[j]]*c+MOD)%MOD;\n            if(i-q[j+1]<0) break;\n            f[i]=(f[i]+f[i-q[j+1]]*c+MOD)%MOD;\n        }\n    }\n}\nint main()\n{\n    int n,m,cas=1;\n    LL a;\n    five();\n    while(~scanf(\"%d\",&n))\n    {\n        printf(\"%lld\\n\",f[n]);\n    }\n    return 0;\n}\n```\n\n","tags":["数学"],"categories":["算法"]},{"title":"Little Bishops（棋盘禁区排列）","url":"/2018/08/17/Little-Bishops（棋盘禁区排列）/","content":"\n<h1>[Little Bishops](https://vjudge.net/problem/UVA-861)</h1>\n\n ## 题意\n\n在国际棋盘中，象的走法是斜对角线，也就是说两个象不能容于一条斜对角线。国际象棋有黑白两色格子相交组成。给你n*n的棋盘和k个象，问你在满足任意两个象互不相斥的情况下，摆放的最大种数？\n\n## 思路\n\n利用棋盘禁区排列这一思想。\n\n首先我们可以看到，在棋盘中，黑色的格子和白色的格子上的象绝对不会相斥，所以我们可以根据$R_k(C)=R_i(C_1)*R_{k-i}(C-C_1)$得，Ans就是在黑色棋盘上放i个象的种类乘以在白色棋盘上放k-i个象的种数。\n\n为了将黑白棋盘分开，比如要建立一个方便的白色棋盘，斜着看显然不舒服，那么我们就：\n\n先把黑色格子删去，然后我们斜+45度看这个棋盘，把一斜看做一行，一斜中的格子数就是一行的格子数，同样的，斜-45度就是列中的格子数。又因为每行互换位置并不影响最终结果，因此我们可以把原本对称的棋盘行，进行格数从小到大排序，得到最终的棋盘。\n\n注意，由于黑白棋盘不一样，对于一个n*n的棋盘来说，斜+45度看一共有2n-1个斜行，因此我们这里让白色棋盘占n行，黑色占n-1行，然后用另外的一个数组来存每行中有多少格子（列），基本的构造棋盘就完成了。\n\n对于构造出来的棋盘（如白色），分析一下：\n\n设mp[i]\\[j]表示前i行放j个棋子的种数。那么有\n$$\nmp[i][j]=mp[i-1][j]+mp[i-1][j-1]·(c[i]-(j-1))\n$$\n相当于=前i-1行放了j个棋子，这一行不放的种数，加上前i-1行放了j-1个棋子乘以这一行只能在（格子数-已经被j-1个象占了的格子数量）个格子。\n\n对两个棋盘都进行这样的操作即可。\n\n最后的答案就是$\\sum_{i=0}^{k}R_i(C_{white})·R_{k-i}(C_{black})$\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint mp1[10][70],mp2[10][70];\nint c1[10],c2[10];\nint main()\n{\n    int n,k;\n    while(~scanf(\"%d%d\",&n,&k))\n    {\n        if(n==0&&k==0) break;\n        if(n==1)\n        {\n            if(k==1||k==0) printf(\"1\\n\");\n            else printf(\"0\\n\");\n            continue;\n        }\n        memset(mp1,0,sizeof(mp1));\n        memset(mp2,0,sizeof(mp2));\n\n        for(int i=1;i<=n;i++) //白色棋盘\n        {\n            if(i&1) c1[i]=i;\n            else c1[i]=c1[i-1]; //printf(\"i:%d\\n\",c1[i]);\n        }\n        for(int i=1;i<=n-1;i++) //黑色棋盘\n        {\n            if(i&1) c2[i]=i+1;\n            else c2[i]=i;\n\n        }\n        for(int i=0;i<=n;i++)\n            mp1[i][0]=mp2[i][0]=1;\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=k;j++)\n            mp1[i][j]=mp1[i-1][j]+mp1[i-1][j-1]*(c1[i]-j+1);\n        \n        for(int i=1;i<=n-1;i++)\n            for(int j=1;j<=k;j++)\n            mp2[i][j]=mp2[i-1][j]+mp2[i-1][j-1]*(c2[i]-j+1);\n        long long ans=0;\n        for(int i=0;i<=k;i++)\n            ans+=1ll*mp1[n][i]*mp2[n-1][k-i];\n\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["排列组合"],"categories":["算法"]},{"title":"Werewolf（缩点）","url":"/2018/08/16/Werewolf/","content":"\n# [Werewolf](http://acm.hdu.edu.cn/showproblem.php?pid=6370) \n\n## 题意\n\n狼人杀游戏，规定村民不能说假话，狼人可能说假话。\n\n每一个人可以指认别人（除了自己）是村民或者是狼人。\n\n根据这些指证，我们可以得出：\n\n1、x号必为村民；\n\n2、x号必为狼人；\n\n3、x号可能是村民也可能是狼人。\n\n问必为村民的人数和必为狼人的人数。\n\n\n\n## 思路\n\n题解的代码比较妙啊……\n\n首先我们肯定能分析出不可能有必为村民的情况，因为所有人都可能是狼人这样的情况是成立的。\n\n然后，我们又能发现，只有在环中，只存在一个狼人指证，和至少1个村民指证，那么才能确认其中的某一个人是狼人；\n\n我们再通过这些确认的狼人，推出其他指证这些狼人为平民的人必为狼人。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nconst int N = 100010;\nstruct node\n{\n    int to;\n    int v;\n}g[N];\n\nint vis[N];\nint ans[N];\nvoid solve(int id)\n{\n    vis[id]=1;\n    if(g[id].v==1) //我指证别人是村民\n    {\n        if(!vis[g[id].to]) //指证的人没有被访问过，就要先让他过一下\n        {\n            solve(g[id].to);\n            if(ans[g[id].to]==-1) ans[id]=-1; //我指证的是铁狼，那么我说了谎，我也是狼\n            else if(ans[g[id].to]==id) ans[id]=-1; //我指证的人指证回了我，说明有个环，环中有一个狼人指证，那么我就是那个铁狼。\n            else ans[id]=ans[g[id].to]; //我也指向我指证的人的指证\n        }\n        else if(ans[g[id].to]==0) ans[id]=N; //如果有全为村民的环，这里体现为，我最终指证回了一开始的那个人，结果呢，他居然还是没有得到指证的指证的指证……的对象，说明不能确认他，也就是说是全村民环。\n        else //访问过啦，但是也不是全是村民\n        {\n            ans[id]=ans[g[id].to]; //我继续指证\n            if(ans[id]==id) ans[id]=-1; //如果……\n        }\n    }\n    else //我指证别人是狼！但是啥都不一定，所以我指证指证。(- -|||)天呐我在说什么。。。\n        ans[id]=g[id].to; \n}\n\n\nint main()\n{\n    int t,n,x;\n    char s[20];\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        memset(vis,0,sizeof(vis));\n        memset(ans,0,sizeof(ans));\n\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&g[i].to);\n            scanf(\"%s\",s);\n            if(s[0]=='w') g[i].v=0;//狼人\n            else g[i].v=1;\n        }\n\n        for(int i=1;i<=n;i++)\n            if(ans[i]==0)\n                solve(i);\n\n        int cnt=0;\n        for(int i=1;i<=n;i++)\n            if(ans[i]==-1)cnt++;\n\n        printf(\"0 %d\\n\",cnt);\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Prefix Free Code（字符串）","url":"/2018/08/16/Prefix-Free-Code/","content":"\n## [Prefix Free Code](https://nanti.jisuanke.com/t/29556) \n\n## 题意\n\n给你n个字符串，这些字符串都不是互相的前缀，再给你一个模式串。模式串由k个其中的字符串任意排列组成。求这个模式串是从中选k个按照字典序排列组成的第几个串？\n\n\n\n## 思路\n\n用全排列的方法，1~n表示前n个字符串，用字符串哈希的方法把他们压缩成数字放在map里映射字符串的序号。\n\n然后遍历模式串。对于每找到一个字符串，按照（比此序号小的字符串-前面已经用掉的字符串的个数）*剩下的位子的全排列数量乘以原先算出来的种数，然后把这个新找到的字符串add到树状数组中，用来标记已经用掉的字符串的个数。\n\n\n\n## 看！代码\n\n```c++\n\n#include <bits/stdc++.h>\n#define MOD 1000000007\n#define MAXN 1000010\nusing namespace std;\ntypedef long long ll;\nll fac[1000010];\nll inv[1000010];\nstring s[1000010];\nstring ss;\nconst ll base=131;\nconst ll mod=1234567891011ll;\nunordered_map<ll,int>mp;\nll solve(int id)\n{\n    int len=s[id].size();\n    ll ans=0;\n    for(int i=0;i<len;i++)\n        ans=(ans*base+(s[id][i]))%mod;\n    return ans;//\n}\nint n;\nint d[1000010];\nint lowbit(int x)\n{\n    return x&(-x);\n}\nint query(int x)\n{\n    int res=0;\n    while(x)\n    {\n        res+=d[x];\n        x-=lowbit(x);\n    }\n    return res;\n}\nvoid add(int x,int v)\n{\n    while(x<=n)\n    {\n        d[x]+=v;\n        x+=lowbit(x);\n    }\n}\nll PowerMod(ll a,ll b,ll c)\n{\n    ll ans=1;\n    ll k;\n    k=a;\n    k=k%c;\n    while(b>0)\n    {\n        if(b&1)\n            ans=(ans*k)%c;\n        b>>=1;\n        k=(k*k)%c;\n    }\n    return ans;\n}\nvoid init()\n{\n    fac[0]=fac[1]=1;\n    for(int i=2;i<=MAXN;i++)\n        fac[i]=fac[i-1]*i%MOD;\n    inv[MAXN]=PowerMod(fac[MAXN],MOD-2,MOD);\n    for(int i=MAXN-1;i>=0;i--)\n        inv[i]=inv[i+1]*(i+1)%MOD;\n}\nint main()\n{\n    init();\n    int k;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n        cin>>s[i];\n    sort(s+1,s+n+1);\n    for(int i=1;i<=n;i++)\n    {\n        ll tot=solve(i);\n        mp[tot]=i;\n    }\n    cin>>ss;\n    int len=ss.size();\n    ll temp=0;\n    ll ans=0;\n    int cnt=0;\n    for(int i=0;i<len;i++)\n    {\n        temp=(temp*base+(ss[i]))%mod;\n        if(mp[temp]!=0)\n        {\n            cnt++;\n            int id=mp[temp];\n            ll sum=1;\n            sum=id-1-query(id);\n            sum=((fac[n-cnt]*inv[n-k])%MOD*sum)%MOD;\n            ans=(ans+sum)%MOD;\n            temp=0;\n            add(id,1);\n        }\n    }\n    printf(\"%lld\\n\",(ans+1)%MOD);\n    return 0;\n}\n\n```\n\n","tags":["字符串哈希"],"categories":["算法"]},{"title":"输入输出","url":"/2018/08/16/输入输出/","content":"\n```c++\nvoid read(int &x){\n\tchar ch = getchar();x = 0;\n\tfor (; ch < '0' || ch > '9'; ch = getchar());\n\tfor (; ch >='0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n}\n```\n\n```c++\ncopy(a,a+n-1,ostream_iterator<int>(cout,\" \"));\ncout<<a[n-1]<<endl;\n```\n\n```c++\nnamespace IO {\n    const int MX = 4e7; //1e7 占用内存 11000kb\n    char buf[MX]; int c, sz;\n    void begin() {\n        c = 0;\n        sz = fread(buf, 1, MX, stdin);//一次性全部读入\n    }\n    inline bool read(int &t) {\n        while (c < sz && buf[c] != '-' && (buf[c] < '0' || buf[c] > '9')) c++;\n        if (c >= sz) return false;//若读完整个缓冲块则退出\n        bool flag = 0; if(buf[c] == '-') flag = 1, c++;\n        for(t = 0; c < sz && '0' <= buf[c] && buf[c] <= '9'; c++) t = t * 10 + buf[c] - '0';\n        if(flag) t = -t;\n        return true;\n    }\n}\n\n\nint main()\n{\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    IO::begin();\n    IO::read(t); //读入t\n}\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"拉格朗日插值法","url":"/2018/08/16/拉格朗日插值/","content":"\n可以求给定式子的前n项和。\n\n感觉可以求给定式子的前n项和。\n\n如：求3x^5+4x^3-5x+8;\n\n式子中最高项次数为5，则需要先计算出6个数字。\n\n板子的使用：\n\n先调用polysum::init(m); 这里的m要和D一起改，m<D;\n\n然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。\n\n模板（[求n^k的前n项和](https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1258)）：\n\n```c++\n/**\n先调用polysum::init(m); 这里的m要和D一起改，m<D;\n\n然后处理最高次数+1个数字存入b[],然后调用polysum::polysum(k,b,n+1)求得前n项和，k为最高次数。\n\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int MOD=1e9+7;\ntypedef long long ll;\nnamespace polysum {\n\t#define rep(i,a,n) for (int i=a;i<n;i++)\n\t#define per(i,a,n) for (int i=n-1;i>=a;i--)\n\tconst int D=51000;\n\tll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D];\n\tll powmod(ll a,ll b){ll res=1;a%=mod;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\tll calcn(int d,ll *a,ll n) { // a[0].. a[d]  a[n]\n\t\tif (n<=d) return a[n];\n\t\tp1[0]=p2[0]=1;\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-i+mod)%mod;\n\t\t\tp1[i+1]=p1[i]*t%mod;\n\t\t}\n\t\trep(i,0,d+1) {\n\t\t\tll t=(n-d+i+mod)%mod;\n\t\t\tp2[i+1]=p2[i]*t%mod;\n         }\n\t\tll ans=0;\n\t\trep(i,0,d+1) {\n\t\t\tll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;\n\t\t\tif ((d-i)&1) ans=(ans-t+mod)%mod;\n\t\t\telse ans=(ans+t)%mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init(int M) {\n\t\tf[0]=f[1]=g[0]=g[1]=1;\n\t\trep(i,2,M+5) f[i]=f[i-1]*i%mod;\n\t\tg[M+4]=powmod(f[M+4],mod-2);\n\t\tper(i,1,M+4) g[i]=g[i+1]*(i+1)%mod;\n\t}\n\tll polysum(ll m,ll *a,ll n) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]\n\t\tll b[D];\n\t\tfor(int i=0;i<=m;i++) b[i]=a[i];\n\t\tb[m+1]=calcn(m,b,m+1);\n\t\trep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod;\n\t\treturn calcn(m+1,b,n-1);\n\t}\n\tll qpolysum(ll R,ll n,ll *a,ll m) { // a[0].. a[m] \\sum_{i=0}^{n-1} a[i]*R^i\n\t\tif (R==1) return polysum(n,a,m);\n\t\ta[m+1]=calcn(m,a,m+1);\n\t\tll r=powmod(R,mod-2),p3=0,p4=0,c,ans;\n\t\th[0][0]=0;h[0][1]=1;\n\t\trep(i,1,m+2) {\n\t\t\th[i][0]=(h[i-1][0]+a[i-1])*r%mod;\n\t\t\th[i][1]=h[i-1][1]*r%mod;\n\t\t}\n\t\trep(i,0,m+2) {\n\t\t\tll t=g[i]*g[m+1-i]%mod;\n\t\t\tif (i&1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod;\n\t\t\telse p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod;\n\t\t}\n\t\tc=powmod(p4,mod-2)*(mod-p3)%mod;\n\t\trep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod;\n\t\trep(i,0,m+2) C[i]=h[i][0];\n\t\tans=(calcn(m,C,n)*powmod(R,n)-c)%mod;\n\t\tif (ans<0) ans+=mod;\n\t\treturn ans;\n\t}\n} // polysum::init();\nll pow2(ll a,ll b)\n{\n\tll res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    ll b[51000];\n    b[0]=0;\n    polysum::init(50000);\n    while(t--)\n    {\n        ll n,k;\n        scanf(\"%lld%lld\",&n,&k);\n        for(ll i=1;i<=k+1;i++)\n        {\n            b[i]=pow2(i,k);\n        }\n        printf(\"%lld\\n\",polysum::polysum(k,b,n+1));\n    }\n    return 0;\n}\n\n```\n\n---","tags":["学习"],"categories":["算法"]},{"title":"欧拉","url":"/2018/08/16/欧拉函数计算φ(n)/","content":"\n<h2>φ(n)</h2>\n\n\n\n欧拉函数，指的就是小于n与n互质的数的个数。\n$$\nφ(x)=x(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})…(1-\\frac{1}{p_n})，其中p_i为x的质因子\n$$\n\n\n```c++\nint phi(int n) {\n    int ans = n;\n    for (int i = 2; i <= sqrt(n); ++i) if (n % i == 0) {\n        ans = ans / i * (i-1);\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) ans = ans / n * (n-1);\n    return ans;\n}\n```\n\n以下的代码以 O(NlogN)复杂度求出 [2,N] 中每个数的欧拉函数。\n\n```c++\nvoid euler(int n) {\n    for (int i = 2; i <= n; ++i) phi[i] = i;\n    for (int i = 2; i <= n; ++i) if (phi[i] == i)\n        for (int j = i; j <= n; j += i)\n            phi[j] = phi[j] / i * (i-1);\n}\n```\n\n下面利用线性筛法的思想在 O(N)的时间内快速递推出 [2,N] 中每个数的欧拉函数。\n\n```c++\ntypedef long long ll;\nconst int maxn = 10000000 + 5;\nint phi[maxn], pri[1000005], n, tot;\nbool mark[maxn];\nll ans, sum[maxn];\nvoid getphi() {\n    phi[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        if (!mark[i]) { phi[i] = i - 1; pri[++tot] = i; }\n        for (int j = 1; j <= tot; j++) {\n            int x = pri[j];\n            if (i*x>n)break;\n            mark[i*x] = 1;\n            if (i%x == 0) { phi[i*x] = phi[i] * x; break; }\n            else phi[i*x] = phi[i] * phi[x];\n        }\n    }\n}\n```\n<h2>降幂</h2>\n\n<h3>公式</h3>\n$$\na^x\\equiv a^{x \\ mod \\ \\phi(p) + \\phi(p)} (mod \\ p)\\  (x \\geq p)\n$$\n\n### 快速幂\n\n```c++\nll qmod(ll a,ll n,ll mod)\n{\n    ll b=a%mod,ans=1;\n    while(n)\n    {\n        if(n&1)\n        {\n            ans=(ans*b)%mod;\n        }\n        b=b*b%mod;\n        n>>=1;\n    }\n    return ans;\n}\n```\n\n\n\n### 模板\n\n```c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\ntypedef __int64 ll;\nchar b[1000006];\n\nll ouler(ll n)\n{\n    ll ans=n,a=n;\n    for(ll i=2;i*i<=a;i++){\n        if(a%i==0){\n            ans-=ans/i;\n            while(a%i==0){\n                a/=i;\n            }\n        }\n    }\n    if(a>1){\n        ans-=ans/a;\n    }\n    return ans;\n}\n\nll qmod(ll a,ll n,ll mod)\n{\n    ll tmp=a%mod,ans=1;\n    while(n){\n        if(n&1){\n            ans=(ans*tmp)%mod;\n        }\n        tmp=tmp*tmp%mod;\n        n>>=1;\n    }\n    return ans;\n}\n//利用公式\nll solve(ll a,char *b,ll c)\n{\n    int PHI=ouler(c);\n    ll res=0;\n    for(int i=0;b[i];i++)\n    {\n        res=(res*10+b[i]-'0');\n        if(res>c)break;\n    }\n    if(res<=PHI)\n    {\n        return qmod(a,res,c);\n    }\n    else\n    {\n        res=0;\n        for(int i=0;b[i];i++)\n        {\n            res=(res*10+b[i]-'0')%PHI;\n        }\n        return qmod(a,res+PHI,c);\n    }\n}\n\nint main()\n{\n    ll a,c,i;\n    ll n=0,tmp;\n    while(scanf(\"%I64d%s%I64d\",&a,b,&c)!=EOF)\n    {\n        printf(\"%I64d\\n\",solve(a,b,c));\n    }\n    return 0;\n}\n```\n\n","tags":["欧拉函数"],"categories":["算法"]},{"title":"莫比乌斯反演","url":"/2018/08/16/莫比乌斯反演/","content":"\n## 整数分块\n\n比如：\n$$\n\\sum_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor\n$$\n$O(n)$的做法之外，还有一种$O(\\sqrt{n})$的做法。\n\n对于每个$\\lfloor\\frac{n}{i}\\rfloor$我们可以通过打表发现有许多的值是不断重复的，再继续寻找规律（不会找啊Orz）发现每一块的数字都是n/(n/i)，那么就可以利用分块的道理：\n\n```c++\nfor(int l=1,r;l<=n;l=r+1)\n{\n    r=n/(n/l); //右边的数应当取min，这里只有一个n就没关系\n    ans+=(r-l+1)*(n/l);\n    //这里根据情况改啊！r-（l-1）是因为这里的积性函数可以看作是μ(i)=1，n/l是后面的那个n/i\n}\n```\n\n有时候可能推出来的式子没有这么裸，它可能乘了一个积性函数$\\mu,\\varphi $，这时候就要对这些函数统计一个前缀和，因为当我们跳过一个分块的时候，就相当于跳过了这个块的函数值。\n\nP.S. 当$O(n)$也T，杜教筛？？？？？？？？？？？？\n\n## 莫比乌斯函数μ(d)\n\n**定义：**\n\n1. d = 1时，μ(d) = 1；\n2. d = $\\Pi_{i=1}^{k}p_i $ ，pi为互不相同的素数时，$μ(d) =(-1)^k$（也就是说，当用于乘积的某一个质因子的次数不大于1时，μ值由用于乘积的质因子个数决定）；\n3. 其他情况，都为0 。\n\n**性质：**\n\n1. $\\sum_{d|n}μ(d) = (n=1)$\n2. $\\sum_{d|n}\\frac{μ(d)}{d} = \\frac{φ(n)}{n}$,其中φ为小于n与n互质的数字的个数\n\n```c++\n/** 对于μ函数的线筛 */\nint mu[N],prim[N];\nbool vis[N]={0};\nint cnt=0;\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n}\n```\n\n**有时候要同时求φ(x)和μ(x)，整合版：**\n\n```c++\n/*mu为μ，phi为φ */\nconst int maxn = 1000000 + 5;\nint phi[maxn],mu[maxn],prim[maxn];\nbool vis[maxn]={0};\nint cnt=0;\n\nvoid get_mu(int n)\n{\n    mu[1]=phi[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;phi[i]=i-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0) {phi[i*prim[j]]=phi[i]*prim[j];break;}\n        \telse {mu[i*prim[j]]=-mu[i];phi[i*prim[j]] = phi[i] * phi[prim[j]];}\n    \t}\n\t}\n}\n\n\n\n/** 做题时看到一版少开一个数组的*/\nconst int maxn = 1e6+100;\ntypedef long long ll;\nint fac[maxn],miu[maxn],phi[maxn];\nvoid init()\n{\n    for(int i=1;i<maxn;++i) fac[i]=i;\n    phi[1]=miu[1]=1;\n    for(int i=2;i<maxn;++i)\n    {\n        if(fac[i]==i)\n            for(int j=i<<1;j<maxn;j+=i)\n                fac[j]=i;\n        if(i/fac[i]%fac[i]) phi[i]=(fac[i]-1)*phi[i/fac[i]],miu[i]=-miu[i/fac[i]];\n        else phi[i]=fac[i]*phi[i/fac[i]],miu[i]=0;\n    }\n}\n```\n\n\n\n## 莫比乌斯反演\n\n定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：\n$$\nF(n)=\\sum_{d|n}f(d)\n$$\n 那么参考容斥的话，就能推出：\n$$\nf(n)=\\sum_{d|n}μ(d)F(\\frac{n}{d})\n$$\n一个更好用的形式，当满足：\n$$\nF(n)=\\sum_{n|d}f(d)\n$$\n有：\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(d)\n$$\n","tags":["学习"],"categories":["算法"]},{"title":"错排（公式+三种生成）","url":"/2018/08/16/错排（公式+三种生成）/","content":"\n## 公式\n\n1. 普通阶乘\n\n$$\nD_n=|I|-\\sum_{i=1}^n|S_i|+\\sum_{i=1}^n\\sum_{j>i}|S_i∩S_j|-\\sum_{i=1}^n\\sum_{j>i}\\sum_{k>i}|S_i∩S_j∩S_k|+…+(-1)^{n-1}|S_1∩S_2∩…∩S_n|\n$$\n\n$$\n=n!(1-\\frac{1}{1!}+\\frac{1}{2!}-\\frac{1}{3!}+…+(-1)^{n}\\frac{1}{n!})\n$$\n\n2. 递推关系\n\n$$\nD_n=(n-1)(D_{n-1}+D_{n-2}),D_1=0,D_2=1\n$$\n\n$$\nD_n=nD_{n-1}+(-1)^n\n$$\n\n## 三种生成方式\n\n### 递归\n\n时间复杂度为$O(D_n)$，但是由于递归函数的调用开销是很大的，系统要为每次函数调用分配存储空间，并将调用点压栈予以记录。而在函数调用结束后，还要释放空间，弹栈恢复断点。所以，考虑函数处理过程，整体看来，递归法的效率并不高。 \n\n```c++\nvoid Digui(int n,int cur,int vis[]) //递归\n{\n    if(cur>n)\n    {\n        copy(a+1,a+n,ostream_iterator<int>(cout,\" \"));\n        cout<<a[n]<<endl;\n        num1++;return;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i]&&cur!=i)\n        {\n            vis[i]=1;a[cur]=i;\n            Digui(n,cur+1,vis);\n            vis[i]=0;\n        }\n    }\n}\n```\n\n### 字典序生成法\n\n用全排列的字典序生成法，同时对每次生成的全排列检验是否合法。\n\n时间复杂度$O(2n*n!)$\n\n```c++\nvoid Dictionary(int n) //字典生成\n{\n    for(int i=1;i<=n;i++)\n        b[i]=i;\n    do{\n        int flag=0;\n        for(int i=1;i<=n;i++)\n            if(b[i]==i)\n            {\n                flag=1;break;\n            }\n        if(flag) continue;\n        num2++;\n        copy(b+1,b+n,ostream_iterator<int>(cout,\" \"));\n        cout<<b[n]<<endl;\n    }while(next_permutation(b+1,b+1+n));\n}\n```\n\n\n\n### 改进的字典序生成法\n\n在对于某一个生成的全排列时判断，同时对接下来不正确的全排列都跳过。由于这种额外的判断方式，我们不能再使用next_permutation函数。\n\n时间复杂度$O(D_n)$\n\n```c++\nint AdLxOrder(int n)\n{\n    int num_a = 0;\n    int *dearr = new int[n + 1];\n    int *occup = new int[n + 1];\n    int Flag = n + 1; //记录不满足错排的元素位置，均满足则为n+1\n    for (int i = 0; i <= n; i++){ dearr[i] = 0;occup[i] = 0;}\n    for (int i = 1, len = 0; i <= n + 1; i++)\n    {\n        if (i < n)                            //安排第i个位置\n        {\n            for (int j = 1; j <= n; j++)    //安排第i个位置\n            {\n                if (occup[j] == 0 && j != i)\n                {\n                    occup[j] = 1;            //occup[j]记录j是否已经被安排\n                    dearr[i] = j;            //安排dearr[i]\n                    break;\n                }\n            }\n        }\n        else if (i == n)                    //安排最后一位\n        {\n            for (int j = 1; j <= n; j++)    //安排第i个位置，无论是否满足\n            {\n                if (occup[j] == 0)\n                {\n                    occup[j] = 1;            //occup[j]记录j是否已经被安排\n                    dearr[i] = j;\n                    if (j == i)\n                        Flag = n;\n                    break;\n                }\n            }\n        }\n        else                                //i == n+1\n        {\n            if (Flag == n + 1)                //满足，输出，并找字典序下一个\n            {\n                num_a++;\n                for(int k = 1;k <= n; k++)\n                    printf(\"%d  \",dearr[k]);\n                printf(\"\\n\");\n                int pos = 0;\n                for (int k = n; k > 1; k--)    //从右往左找下降\n                {\n                    if (dearr[k - 1] < dearr[k])\n                    {\n                        pos = k - 1;\n                        for (int m = n; m > pos; m--)\n                        {\n                            if (dearr[m] > dearr[pos])    //找到后缀中较大的最小元素\n                            {\n                                if (dearr[m] == pos)\n                                    Flag = pos;     //记录不满足的位置\n                                int tmp = dearr[m];   //交换\n                                dearr[m] = dearr[pos];\n                                dearr[pos] = tmp;\n                                //记录不满足的位置（只记录最左侧）\n                                for (int k1 = pos+1, k2 = n; k1 < k2; k1++, k2--)\n                                {\n                                    if (dearr[k1] == k2 && Flag > k2)\n                                        Flag = k2;  //记录不满足的位置\n                                    if (dearr[k2] == k1 && Flag > k1)\n                                        Flag = k1;  //记录不满足的位置\n\n                                    int tmp = dearr[k2]; //陆续交换\n                                    dearr[k2] = dearr[k1];\n                                    dearr[k1] = tmp;\n                                }\n                                i = n; //循环末尾有i++，此处特取n\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            else                            //找关键位置的下一个值\n            {                                //关键位置：下降位置和不满足位置的最左者\n                int pos = 0;\n                for (int k = n; k > 1; k--)    //从右往左找下降\n                {\n                    if (dearr[k - 1] < dearr[k])\n                    {\n                        pos = k - 1;\n                        if (pos > Flag)        //pos取下降位置和不满足位置的最左者\n                            pos = Flag;\n\n                        for (int m = pos; m <= n; m++) occup[dearr[m]] = 0; //全部重置\n                        for (int m = dearr[pos] + 1; m <= n; m++) //从dearr[pos]+1开始找\n                        {\n                            if (occup[m] == 0 && m != pos) //给pos找到下一个值\n                            {\n                                dearr[pos] = m;\n                                occup[m] = 1;\n                                i = pos;\n                                Flag = n + 1;\n                                break;\n                            }\n                        }\n                        if (Flag == n + 1)\n                            break;\n                        else\n                            k = pos + 1;    //重新向前找下降，循环末尾有k--，此处特+1\n                    }\n                }\n            }\n        }\n    }\n    delete []dearr;\n    delete []occup;\n    return num_a;\n}\n```\n\n\n\n","tags":["学习"],"categories":["算法"]},{"title":"组合数学（一）QAQ","url":"/2018/08/16/组合数学/","content":"\n[TOC]\n\n\n\n## 组合\n\n$C_n^r=C_{n-1}^r+C_{n-1}^{r-1}$ 对于第n个元素，不取时，相当于前n-1个元素中取r个，取时，是前n-1个元素中取r-1个。\n\n像个杨辉三角：\n\nC(0,0)\n\nC(1,0)   C(1,1)\n\nC(2,0)   C(2,1)   C(2,2)\n\nC(3,0)   C(3,1)   C(3,2)   C(3,3)\n\n.....        .....        .....\n\n如果要求解C(n,r)，可以先求解出C(n-1,r) 和 C(n-1,r-1)；再运用公式相加即可。很明显，这是一个与[Fib数列](http://www.cnblogs.com/hapjin/p/5571352.html)类似的递归计算。只不过求Fib(n)时，只有一个参数，而这里有二个参数而已。（还是直接求把。。还有用dp的方法）\n\n\n\n## Cayley公式\n\n> 一个完全图K_n有$n^{n-2}$棵生成树，即n个有标号1~n的顶点的树的个数为：$n^{n-2}$\n\n证明：你画个图\n\n> 给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n>2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。\n\n简化为：n个数字可重复的排列到n-2个位置上去。\n\n## 不全相异的排列\n\nn个元素组成的多重集，$a_i$重复$n_i$次，$n=∑_{i=1}^kn_i$,从n个元素中选取r个排列，求不同的排列数。\n\n若r=n ,为：$\\frac{n!}{n_1!n_2!…n_k!}$\n\n## 重复排列和重复组合\n\n排列：在n个不同物体中可重复选取r个排列：$n^r$\n\n组合：…… 组合：$C_{n+r-1}^r$\n\n证明组合：对于1~n的x集合中选取r个元素，然后对应的构造r个y集合中的元素，对应关系为：$y_i=x_i+i-1$，\n\n故……\n\n## 圆周排列\n\n> a、b、c、d，普通排列：24，圆周排列：6 = 24/4 也就说；普通数量/个数 = （n-1）！\n\n\n\n<h2>生成全排列</h2>\n\n### 序数法\n\n任何  $m=a_{n-1}(n-1)!+a_{n-2}(n-2)!+a_{n-3}(n-3)!+……+a_2·2!+a_1·1!$ ①\n\n其中a1 = m%2， a2=(m/2)%3 , a3=(m/2/3)%4 ……直到m/……=0；\n\n那么！a集合（$a_{n-1}~a_1$）共有n！种排列对不对！那么怎样把1,2，……n的一个排列和①联系起来呢？\n\n> 某一个n阶排列的序号是m，那么将m转换为阶乘进制数后，阶乘进制数的第i位就是在i右面比i小的元素个数。例如4阶排列中（从0开始计数的）第19个排列的序号是19，将19转换成阶乘进制数是3010，那么，第一位是0，表明1的右面没有比1小的元素，而第二位是1，则2的右面有一个元素小于2，第三位是0，即3的右面没有比它小的元素，第四位是3，4的右面有3个元素小于它。显然，这个排列是4 2 1 3。\n\n### 字典序法\n\n> 很简单就是1234 、 1243、 1324、 1342、……这样的全排列生成顺序\n\n方法是：eg：上一个排列数为：3421 (p.s.以下的i j k都是下标) 1~n\n\n1. 求$ i = max ( j|a_j-1<a_j ) = 2$\n2. 求$ j = max(k|a_i-1<a_k)= 2$\n3. 交换$a_i-1$ 和 $a_j$ ，得：4321\n4. 将$a_ia_{i+1}a_{i+2}……a_n$逆序：得4123。\n\n[Poj 1833](http://poj.org/problem?id=1833) 可以使用stl中的next_permutation(op1,op2)自动生成字典序的下一个全排列。\n\nop1是放排列的数组首地址a，op2是排列的长度a+n。\n\n到最后一个排列时返回为false。\n\n但是这一题卡输出，用stl的<iterator>中的\n\n```c++\ncopy(a,a+n-1,ostream_iterator<int>(cout,\" \"));\ncout<<a[n-1]<<endl;\n```\n\n参考用法：\n\n```c++\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <iterator>\nusing namespace std;\nint n;\nint main()\n{\n    int a[1300];\n    int m,k;\n    scanf(\"%d\",&m);\n    while(m--)\n    {\n        scanf(\"%d%d\",&n,&k);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<k;i++)\n            next_permutation(a,a+n);\n        for(int i=0;i<n;i++)\n            printf(\"%d \",a[i]);\n        copy(a,a+n-1,ostream_iterator<int>(cout,\" \"));\n        cout<<a[n-1]<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n### 邻位互换法\n\n计蒜客构造题 [[bellring]](https://nanti.jisuanke.com/t/28877)\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1;\t\t1\n\nn=2;\t\t12 , 21\n\nn=3;\t\t123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n```c++\n/**\n\t本算法的思想也是希望以（12…n）作为n个元素1，2，…，n的第一个排列，\n\t然后按照某种方法，由一个排列（p）＝（p1p2…pn）直接生成下一个排列，\n\t直到全部排列生成完毕为止。\n\n\t以n＝4为例，开始在排列1234的各数上方加一个左箭头“←”，\n\t当一个数上方箭头所指的一侧，相邻的数比该数小时，便称该数处于活动状态。\n\t从排列（p）＝（p1p2…pn）生成下一个排列的算法如下：\n\t（1）若排列（p）＝（p1p2…pn）中无一数处于活动状态，则停止，否则转（2）；\n\t（2）求所有处于活动状态的数中的最大者，设为k，\n\t\tk和它的箭头所指的一侧的相邻数互换位置，转（3）；\n\t（3）令比k大的所有数的箭头改变方向，转（1）。\n*/\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nenum DIR{LEFT=-1,RIGHT=1};\n\n\n/*\t函数功能：判断下标i所指p中元素是否处于活动状态\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir\tin,标记p中每个元素的箭头方向\n *\t\t\ti\tin,待判定元素的下标\n *\t\t\tN\tin,待排列字符的个数\n *\t返回值：\ttrue 表示待判定元素为活动状态，\n *\t\t\tfalse 表示待判定元素处于非活动状态\n */\nbool IsActive(const char *p,const DIR *dir,const int i,const int N)\n{\n\tif(i+dir[i] < 0 || i+dir[i] >= N)\n\t\treturn false;\n\tif(p[i+dir[i]] < p[i])\t//箭头所指一侧相邻的数比该数小\n\t\treturn true;\n\telse return false;\n}\n\n\n/*\t函数功能：找到p中处于活动状态的数中的最大者\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir in,标记p中每个元素的箭头方向\n *\t\t\tN\tin,待排列字符的个数\n *\t返回值：上述最大者的下标，-1表示调用参数有误,N表示没有活动者\n */\nint MaxActive(const char *p,const DIR *dir,const int N)\n{\n\tint k=N;\n\tfor(int i=0;i<N;i++)\n\t\tif(IsActive(p,dir,i,N) && (p[i] > p[k]))\n\t\t\tk = i;\n\treturn k;\n}\n\n\n/*\t函数功能：交换下标i所指元素与其箭头方向所指元素,原位交换\n *\t输入参数：p\tinout,指向n个字符的一个当前排列\n *\t\t\tdir inout,标记p中每个元素的箭头方向\n *\t\t\ti\tin,待交换元素的下标\n *\t返回值：\ttrue 表示交换成功\n *\t\t\tfalse 表示交换失败，失败原因为调用参数有误。\n */\nbool Swap(char *p, DIR *dir, int *i)\n{\n\tif(p == NULL || dir == NULL)\n\t\treturn false;\n\n\n\t//交换相邻的元素；\n\tchar temp = p[*i];\n\tp[*i] = p[*i+dir[*i]];\n\tp[*i+dir[*i]] = temp;\n\n\n\t//元素相关的箭头也得交换\n\tDIR T = dir[*i];\n\tdir[*i] = dir[*i+T];\n\tdir[*i+T] = T;\n\n\n\t*i = *i + T;\t//使*i依旧是未交换前*i所指元素的下标\n\treturn true;\n}\n\n\n/*\t函数功能：上述算法思路第三步，修改所以比k大的元素的箭头方向，原位修改\n *\t输入参数：p\tin,指向n个字符的一个当前排列\n *\t\t\tdir\tinout,标记p中每个元素的箭头方向\n *\t\t\tk\tin,p中处于活动状态的最大者的下标，由MaxActive函数求出\n *\t\t\tN\tin,缓冲区p的长度,也是待排列字符的个数\n *\t返回值：\ttrue 表示函数执行成功\n *\t\t\tfalse 表示函数执行失败，失败原因为调用参数有误\n */\nbool ModifyDir(const char *p,DIR *dir,const int k,const int N)\n{\n\tif(p == NULL || dir == NULL)\n\t\treturn false;\n\tfor(int i=0;i<N;i++)\n\t\tif(p[i]>p[k])\n\t\t\tdir[i] = (dir[i] == LEFT ? RIGHT : LEFT);\n\treturn true;\n}\nint main()\n{\n\tint N =0;\n\tcin>>N;\n\tchar *p = new char [N+1];\n\tDIR *dir = new DIR [N];\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tp[i] = '1'+i;\n\t\tdir[i] = LEFT;\n\t}\n\tp[N]='\\0';\n\tint k=0;\n\tfor(int i=0;i<strlen(p)-1;i++)\n            printf(\"%d \",p[i]-'0');\n        printf(\"%d\\n\",p[strlen(p)-1]-'0');\n\tint c = 1;\n\tdo\n\t{\n\t\tk = MaxActive(p,dir,N);\n\t\tif(k == N)\n\t\t\tbreak;\n\t\tSwap(p,dir,&k);\n\t\tModifyDir(p,dir,k,N);\n\t\tfor(int i=0;i<strlen(p)-1;i++)\n            printf(\"%d \",p[i]-'0');\n        printf(\"%d\\n\",p[strlen(p)-1]-'0');\n\n\t} while (1);\n\tdelete []p;\n\tdelete []dir;\n\treturn 0;\n}\n\n```\n\n## 卡特兰数\n\n$$\na_{n}=\\frac{4n-2}{n+1}a_{n-1}\n$$\n\n1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... …\n\n该递推关系的解是：\n$$\na_{n}=\\frac{C_{2n}^{n}}{n+1}   (n=1,2,3,…)\n$$\neg. 出栈的种数与卡特兰数：\n\n**① 对于出栈序列中的每一个数字，在它后面的、比它小的所有数字，一定是按递减顺序排列的。**\n\n**② 给定一个入栈顺序：1  2  3 .... n，一共有多少种合法的出栈顺序？**\n\n答案是 卡特兰数。即一共有：$h(n)=\\frac{C_{2n}^{n}}{n+1}   $ 种合法的出栈顺序。\n\n如果仅仅只需要求出一共有多少种合法的出栈顺序，其实就是求出组合 C(2n,n)就可以了。\n\n## 组合数模板\n\n### n,m大，MOD小\n\n```c++\n#define ll long long  \nconst int N=1000100;  \nconst int MOD=99991;  \nll f[N];  \nll Fp(ll a,ll n)  \n{  \n    ll ans=1;  \n    while(n)  \n    {  \n        if(n&1) ans=(ans*a)%MOD;  \n        a=a*a%MOD;  \n        n>>=1;  \n    }  \n    return ans;  \n}  \nll Lucas(ll a,ll k)  \n{  \n    ll ans=1;  \n    while(a&&k)  \n    {  \n        ll a1=a%MOD;  \n        ll b1=k%MOD;  \n        if(a1<b1) return 0;  \n        ans=ans*f[a1]*Fp(f[b1]*f[a1-b1]%MOD,MOD-2)%MOD;  \n        a/=MOD;  \n        k/=MOD;  \n    }  \n    return ans;  \n}  \nvoid Init()  \n{  \n    f[0]=1;  \n    for(int i=1;i<=MOD;i++)  \n    {  \n        f[i]=f[i-1]*i%MOD;  \n    }  \n}  \nint main()  \n{  \n    Init();  \n    printf(\"%I64d\\n\",Lucas(5,2));  \n}  \n```\n\n### n，m小，mod大\n\n```c++\n#define ll long long  \nconst int MOD=1e9+7;  \nconst int N=1000100;  \nll f[N];  \nll Fp(ll a,ll n)  \n{  \n    ll ans=1;  \n    while(n)  \n    {  \n        if(n&1) ans=ans*a%MOD;  \n        a=a*a%MOD;  \n        n>>=1;  \n    }  \n    return ans;  \n}  \nll C(int n,int m)  \n{  \n    if(n<m) return 0;  \n    return f[n]*Fp(f[m],MOD-2)%MOD*Fp(f[n-m],MOD-2)%MOD;  \n}  \nvoid Init()  \n{  \n    f[0]=1;  \n    for(int i=1;i<N;i++) f[i]=f[i-1]*i%MOD;  \n}  \nint main()  \n{  \n    Init();  \n    printf(\"%I64d\\n\",C(5,2));  \n}  \n```\n\n### n，m很小\n\n```c++\n#define ll long long \nconst int MOD=1000000007;  \nconst int N=20;  \nll C[N][N];  \nint main()  \n{  \n    C[0][0]=C[1][0]=C[1][1]=1;  \n    for(int i=2;i<N;i++)  \n    {  \n        C[i][0]=1;  \n        for(int j=1;j<N;j++)  \n        {  \n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;  \n        }  \n    }  \n}  \n```\n\n\n\n\n\n## 母函数\n\n> 定义：对于序列$a_0,a_1,a_2 … $构造一个函数：\n\n\n$$\nG(x)=a_0+a_1x+a_2x^2+…\n$$\n\n> 则，函数G(x)就是序列$a_0,a_1,a_2…$的母函数。\n\n比如说一个普通型母函数的应用：\n\n有质量为1,2,3的砝码各一枚：\n\n（1）可以称出多少种不同的质量？\n\n解：1个1g砝码可以用1+x表示，1表示不用，x表示用1g砝码\n\n​\t1个2g砝码可用$1+x^2$表示……\n\n​\t1个3g砝码$1+x^3$……\n\n​\t则其母函数$G(x)=(1+x)(1+x^2)(1+x^3)=1+x+x^2+2x^3+x^4+x^5+x^6$\n\n​\tx上的指数表示质量，x前的系数表示搭配种类。\n\n​\t故可以称出6种。\n\n（2）若砝码有无穷个？\n\n解：以2g砝码为例，那么2g砝码可以组成：$(1+x^2+x^4+x^6……)$\n\n因此：$G(x)=(1+x+x^2+x^3+……)(1+x^2+x^4+x^6+……)(1+x^3+x^6+x^9+……)$\n\n\n\n模板：\n\n```c++\n//这个比较快速\n/**\nK对应具体问题中物品的种类数。\nv[i]表示该乘积表达式第i个因子的权重，对应于具体问题的每个物品的价值或者权重。\nn1[i]表示该乘积表达式第i个因子的起始系数，对应于具体问题中的每个物品的最少个数，即最少要取多少个。\nn2[i]表示该乘积表达式第i个因子的终止系数，对应于具体问题中的每个物品的最多个数，即最多要取多少个。\n对于表达式(1+x+x^2)(x^8+x^10)(x^5+x^10+x^15+x^20)，v[3]={1,2,5}，n1[3]={0,4,1}，n2[3]={2,5,4}。\n解题的关键是要确定v、n1、n2数组的值。\n通常n1都为0，但有时候不是这样。\nn2有时候是无限大。\nP是可能的最大指数。\n如果n2为无穷大，那么第二层循环条件j<=n2[i]可以去掉。\na[i],i为指数，内容为系数。\n*/\n//初始化a，因为有last，所以这里无需初始化其他位\n\na[0]=1;\nint last=0;\nfor (int i=0;i<K;i++)\n{\n\tint last2=min(last+n2[i]*v[i],P);//计算下一次的last\n\tmemset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n\tfor (int j=n1[i];j<=n2[i]&&j*v[i]<=last2;j++)//这里是last2\n\t\tfor (int k=0;k<=last&&k+j*v[i]<=last2;k++)//这里一个是last，一个是last2\n\t\t\tb[k+j*v[i]]+=a[k];\n\tmemcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n\tlast=last2;//更新last\n}\n```\n\n例题：[HDU2082](http://acm.hdu.edu.cn/showproblem.php?pid=2082)\n\n示例代码:\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint v[100],n[100],a[100],b[100],last,last2,sum;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        for(int i=0; i<26; i++)\n        {\n            scanf(\"%d\",&n[i]);\n            v[i]=i+1;\n        }\n        a[0]=1;last=0;\n        //初始化a，因为有last，所以这里无需初始化其他位\n        for (int i=0; i<26; i++)\n        {\n            int last2=min(last+n[i]*v[i],50);//计算下一次的last\n            memset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n            for (int j=0; j<=n[i]&&j*v[i]<=last2; j++) //这里是last2\n                for (int k=0; k<=last&&k+j*v[i]<=last2; k++) //这里一个是last，一个是last2\n                    b[k+j*v[i]]+=a[k];\n            memcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n            last=last2;//更新last\n        }\n        int ans=0;\n        for(int i=1; i<=50; i++)\n            if(a[i])   ans+=a[i];\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n## 整数拆分\n\n//大整数分解模板\n\n```c++\ntypedef long long ll;\nmap<ll, int>m;\nconst int mod = 10000019;\nconst int times = 50;//测试50次\nll mul(ll a, ll b, ll m)\n//求a*b%m\n{\n    ll ans = 0;\n    a %= m;\n    while(b)\n    {\n        if(b & 1)ans = (ans + a) % m;\n        b /= 2;\n        a = (a + a) % m;\n    }\n    return ans;\n}\nll pow(ll a, ll b, ll m)\n//a^b % m\n{\n    ll ans = 1;\n    a %= m;\n    while(b)\n    {\n        if(b & 1)ans = mul(a, ans, m);\n        b /= 2;\n        a = mul(a, a, m);\n    }\n    ans %= m;\n    return ans;\n}\nbool Miller_Rabin(ll n, int repeat)//n是测试的大数，repeat是测试重复次数\n{\n    if(n == 2 || n == 3)return true;//特判\n    if(n % 2 == 0 || n == 1)return false;//偶数和1\n\n    //将n-1分解成2^s*d\n    ll d = n - 1;\n    int s = 0;\n    while(!(d & 1)) ++s, d >>= 1;\n    //srand((unsigned)time(NULL));在最开始调用即可\n    for(int i = 0; i < repeat; i++)//重复repeat次\n    {\n        ll a = rand() % (n - 3) + 2;//取一个随机数,[2,n-1)\n        ll x = pow(a, d, n);\n        ll y = 0;\n        for(int j = 0; j < s; j++)\n        {\n            y = mul(x, x, n);\n            if(y == 1 && x != 1 && x != (n - 1))return false;\n            x = y;\n        }\n        if(y != 1)return false;//费马小定理\n    }\n    return true;\n}\nll gcd(ll a, ll b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\nll pollard_rho(ll n, ll c)//找到n的一个因子\n{\n    ll x = rand() % (n - 2) + 1;\n    ll y = x, i = 1, k = 2;\n    while(1)\n    {\n        i++;\n        x = (mul(x, x, n) + c) + n;//不断调整x2\n        ll d = gcd(y - x, n);\n        if(1 < d && d < n)\n            return d;//找到因子\n        if(y == x)\n            return n;//找到循环，返回n，重新来\n        if(i == k)//一个优化\n        {\n            y = x;\n            k <<= 1;\n        }\n    }\n}\nvoid Find(ll n, ll c)\n{\n    if(n == 1)return;//递归出口\n\n    if(Miller_Rabin(n, times))//如果是素数，就加入\n    {\n        //factor[index++]=n;\n        m[n]++;\n        return;\n    }\n\n    ll p = n;\n    while(p >= n)\n        p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到\n\n    Find(p, c);\n    Find(n / p, c);\n}\nint main()\n{\n    ll n;srand((unsigned)time(NULL));\n    while(cin >> n)\n    {\n        m.clear();\n        Find(n, rand() % (n - 1) + 1);//这是自己设置的一个数\n        cout<<n<<\" = \";\n        for(map<ll ,int>::iterator it = m.begin(); it != m.end();)\n        {it->first<<\" ^ \"<<it->second;\n            if((++it) != m.end())\n               cout<<\" * \";\n            cout<<\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n\n\n## Ferrrs图像\n\n> 一个自上而下的n层各自组成的图像，$m_i$为第i层的格子数。当$m_i≥m{i+1}$，即上层的格子数不少于下层的格子数时，称之为Ferrers图像。\n\n绕$y=-x$旋转得到的图像仍然是Ferrers图像，这样两个称为一对共轭Ferrers图像。\n\n整数的拆分也可以用这个图像来表示。\n\n可根据图像证明定理：整数n拆分成k个数的和的拆分数，与数n拆分成最大数为k的拆分数相等。\n\neg：24=5+5+5+4+3+2 的图像 共轭图像的话，24=6+6+5+4+3，\n\n可以看出，24拆分成6个数的最大数=24拆分成最大数为6的拆分数\n\n\n\n……\n\n## 指数型母函数\n\n在不全相异的排列那一p里面，r=n可以容易求出，但是当r一般情况的时候就复杂了。\n\n对于给定的数列$a_0,a_1,a_2,…,a_n,…，$通常称为形式幂级数，即：\n$$\nΣ_{n=0}^∞\\frac{a_n}{n!}x^n=a_0+a_1x+\\frac{a_2}{2!}x^2+\\frac{a_3}{3!}x^3+…+\\frac{a_n}{n!}x^n+…\n$$\n为数列$a_0,a_1,a_2,…,a_n,…$的指数型母函数，这里规定0！=1。\n\n这样，对于一个多重集，其中$a_i$重复了$n_i$次，$n=∑_{i=1}^nn_i$，从n个元素中取r个元素排列，不同的排列数对应的指数型母函数：\n$$\nG(x)=(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_1}}{n_1!})(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_2}}{n_2!})+…+(1+\\frac{x}{1!}+\\frac{x^2}{2!}+…+\\frac{x^{n_k}}{n_k!})\n$$\n例题：有1,2,3,4,个数字组成的五位数中，要求数1出现次数不超过2次，但不能不出现；2不超过1次；3最多3次，可以不出现；4出现次数为偶数。求满足上述条件的数的个数。\n\n解：$C_r$对应的指数型母函数为\n$$\nG(x)=(\\frac{x}{1!}+\\frac{x^2}{2!})(1+\\frac{x}{1!})(1+\\frac{x}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!})(1+\\frac{x^2}{2!}+\\frac{x^4}{4!})\n$$\n解得x上指数为5的系数为215。\n\np.s.4的偶数次之所以到$x^4$是因为再多也不满足条件啊。\n\nHDU[排列组合](http://acm.hdu.edu.cn/showproblem.php?pid=1521) 题\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\ntypedef long long LL;\nusing namespace std;\nconst int N = 11;\ndouble c1[N],c2[N];     //注意类型\nLL fac[N];\n \nvoid cal()\n{\n    fac[0]=1;           //0!会被用到\n    for(int i=1;i<N;i++)\n        fac[i]=i*fac[i-1];\n}\n \nint main()\n{\n    cal();\n    int n,r;\n    while(~scanf(\"%d%d\",&n,&r))\n    {\n        memset(c1,0,sizeof(c1));\n        memset(c2,0,sizeof(c2));\n \n        c1[0]=1;\n        int num;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&num);\n            if(num==0) continue;\n            for(int j=0;j<=r;j++)\n            {\n                for(int k=0;k<=num&&k+j<=r;k++)\n                {\n                    c2[k+j]+=c1[j]/fac[k];\n                }\n            }\n            for(int j=0;j<=r;j++)\n            {\n                c1[j]=c2[j];\n                c2[j]=0;\n            }\n        }\n\n        printf(\"%.0lf\\n\",c1[r]*fac[r]);\n    }\n \n\treturn 0;\n}\n```\n\n\n\n## 递推关系\n\n\n\n## 斐波那契\n\n\n\n## 斯特林数 Stiring\n\n###第一类斯特林数\n\n> 有正负，其绝对值是包含n个元素的集合分作k个环排列的方法数目\n\n递推公式：\n\n​\t\t\t\t\t\t\tS（n，0）= 0\n\n​\t\t\t\t\t\t\tS（1，1） = 1\n\n​\t\t\t\t\t\t\tS（n+1，k）= S（n，k-1) + nS（n，k）\n\n第三个式子是这样的，n+1个元素分成k个环，可以理解为前n个元素分成k-1个环，第n+1个自成一个环的种类数量，加上前n个元素分成k个环，第n+1个元素插入到第i个元素左边。\n\n### 模板\n\n```c++\n//第一类Stirling数s(p,k)计数的是把p个对象排成k个非空循环排列的方法数\n#define ll long long\nconst int N=1000;\nconst int MOD=1e9+7;\nll s[N][N];//存放要求的Stirling数\nvoid Init()\n{\n    s[1][1]=1;\n    for(int i=2;i<N;i++)\n    {\n        for(int j=1;j<=i;j++)\n        {\n            s[i][j]=(s[i-1][j-1]+(i-1)*s[i-1][j])%MOD;\n        }\n    }\n}\n```\n\n\n\n### 第二类斯特林数\n\n> 将包含n个元素的集合划分为正好k个非空子集方法的数目\n\n递推公式：\n\n​\t\t\t\t\t\t\tS（n，k）= 0（n<k ||k==0）\n\n​\t\t\t\t\t\t\tS（n，n） = S（n，1） = 1 \n\n​\t\t\t\t\t\t\tS（n，k）= S（n-1，k-1) + kS（n-1，k）\n\n第三个式子是这样的，n个元素分成k集合，可以理解为前n-1个元素分成k-1个集合，第n个自成一个集合的种类数量，加上前n-1个元素分成k个环，第n个元素在k个集合中选择放到里面去。\n\n### 模板\n\n```c++\n/*\n第二类Stirling数S(p,k)计数的是把p元素集合划分到k个不可区分的盒子里且没有空盒子的划分个数。\n*/\n#define ll long long\nconst int N=1000;\nconst int MOD=1e9+7;\nll s[N][N];//存放要求的Stirling数\nvoid Init()\n{\n    s[1][1]=1;\n    for(int i=2;i<N;i++)\n    {\n        for(int j=1;j<=i;j++)\n        {\n            s[i][j]=(s[i-1][j-1]+j*s[i-1][j])%MOD;\n        }\n    }\n}\n```\n\n","tags":["数学"],"categories":["算法"]},{"title":"Halloween treats（鸽巢定理）","url":"/2018/08/16/Halloween-treats（鸽巢定理）/","content":"\n## [Halloween treats](http://acm.hdu.edu.cn/showproblem.php?pid=1808) \n\n## 题意\n\n有c个小朋友，n户家庭，n户家庭中每户分别有$a_i$个糖果，小朋友们可以向任意户家庭讨糖果，最终的糖果被小朋友平均分，问你向哪几户人家讨糖果可以使得平均分成立？（任意输出即可）\n\n如果没有输出“no sweets”。\n\n1<=c<=n<=100000\n\n## 思路\n\n鸽巢定理的应用。\n\n对于正整数序列，$a_1，a_2，…，a_m$，至少存在整数k和l,1<=k<l<=m，使得$a_k+a_{k+1}+…+a_l$是m的倍数。（证明见容斥和鸽巢定理介绍）\n\n因此对每个数i求前缀，第一，如果前缀本身就能被c整除，那么输出1~i，否则，sum[i]%=c；第二，如果有任意两个sum[i],sum[j]对c取模后相等，则证明$a_{i+1}到a_j$的数之和是c的倍数。输出这几个数即可。\n\n注意，这个定理的条件是c不大于n。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nint sum[100010];\nint main()\n{\n    int n,c;\n    while(~scanf(\"%d%d\",&c,&n))\n    {\n        if(c==0&&n==0) break;\n        a[0]=0;\n        int flag=-1;\n        vector<int>same[c+1];\n        memset(sum,0,sizeof(sum));\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=1;i<=n;i++)\n        {\n            sum[i]=sum[i-1]+a[i];\n            if(sum[i]%c==0)\n            {\n                flag=0;\n                same[0].push_back(0);\n                same[0].push_back(i);\n                break;\n            }\n            sum[i]%=c;\n            same[sum[i]].push_back(i);\n            if(same[sum[i]].size()==2)\n            {\n                flag=sum[i];\n                break;\n            }\n        }\n        if(flag==-1)\n        {\n            puts(\"no sweets\");\n            continue;\n        }\n        int a=same[flag][0],b=same[flag][1];\n        for(int i=a+1;i<b;i++)\n            printf(\"%d \",i);\n        printf(\"%d\\n\",b);\n    }\n    return 0;\n}\n```\n\n","tags":["排列组合"],"categories":["算法"]},{"title":"The Best Path(欧拉+并查集)","url":"/2018/08/15/The-Best-Path(欧拉+并查集)/","content":"\n# [The Best Path](https://nanti.jisuanke.com/t/29370) \n\n## 题意\n\n给你n个点，m条边，问你是否能够一次性不重复的走完其他所有的边，对于每一点有一个权值，ans=经过的每一次点的异或和（一个点可以重复多次），求怎么走使得这个ans最大。\n\n## 思路\n\n一次性走完很显然是要欧拉路或者回路的，那么条件就是0个或者2个奇数度数的点，这个开头计数一下就好，另外还要判断是否连通，否则永远走不到某些路，所以用并查集查询father即可。\n\n然后对于欧拉路来说，两个奇数度数的点一定有贡献，而对于偶数度数u的点来说，只要看u/2的奇偶性即可，是奇数就有贡献，偶数就没贡献，因此在开头把所有的点先异或一遍得一个ans，然后对于每一个点分析，如果没贡献就再异或一次。\n\n如果是欧拉回路，那么就对每一个点作为起始点，我们可以发现起始点是没有贡献的，因此ans对于每一个起始点异或，取最大值即可。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=0x3f3f3f3f;\nconst int N = 100010;\nint id[N];\nint sz[N];\n\nint poor[N];\nint deg[N];\nint Find(int x)  ///找跟根结点\n{\n    while(x!=id[x])\n    {\n        id[x]=id[id[x]];\n        x=id[x];\n    }\n    return x;\n}\n\nint un(int p,int q)\n{\n    int pr=Find(p);\n    int qr=Find(q);\n    if(pr==qr) return -1;\n    if(sz[pr]<=sz[qr])\n    {\n        sz[qr]+=sz[pr];id[pr]=qr;\n    }\n    else\n    {\n        sz[pr]+=sz[qr];id[qr]=pr;\n    }\n}\n\nvoid clear()\n{\n    for(int i=1;i<=N;i++)\n    {\n        id[i]=i;sz[i]=1;\n    }\n}\n\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        clear();\n        memset(deg,0,sizeof(deg));\n        int n,m;\n        int ans=0;\n        scanf(\"%d%d\",&n,&m);\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&poor[i]);\n            ans=ans^poor[i];\n        }\n        int u,v;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            deg[u]++;\n            deg[v]++;\n            un(u,v);\n        }\n        int ji=0,cnt=0;\n        for(int i=1;i<=n;i++)\n        {\n             if(deg[i]&1) ji++;\n             if(Find(i)!=Find(1))\n             {\n                 cnt++;break;\n             }\n        }\n        if(cnt!=0||(ji!=0&&ji!=2)) {printf(\"Impossible\\n\");continue;}\n        if(ji) //欧拉路\n        {\n           // cout<<ans<<endl;\n            for(int i=1;i<=n;i++)\n                if(deg[i]%2==0&&(deg[i]/2)%2==0)\n                    ans=ans^poor[i];\n        }\n        else //回路\n        {\n            int temp;\n            for(int i=1;i<=n;i++)\n            {\n                temp=ans^poor[i];\n                ans=max(ans,temp);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["欧拉路"],"categories":["算法"]},{"title":"Balanced Sequence (贪心)","url":"/2018/08/15/Balanced-Sequence-(贪心)/","content":"\n# [Balanced Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=6299) \n\n## 题意\n\n给你几个含有左右括号的串，你可以任意组合，求组合能得到的最大的括号匹配数量。\n\n贪心。\n\n具体贪心法可以见代码。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#pragma comment(linker, “/STACK:1024000000,1024000000”)\nusing namespace std;\nstruct node{\n    int left_no,right_no,yes;\n    node()\n    {\n        left_no=right_no=yes=0;\n    }\n};\nbool cmp(node a,node b)\n{\n    if(a.left_no>=a.right_no&&b.left_no<=b.right_no)//左少右多 + 左多右少 a前面\n        return true;\n    if(a.left_no<=a.right_no&&b.left_no>=b.right_no) //左少右多 + 左多右少 b前面\n        return false;\n    if(a.left_no<=a.right_no&&b.left_no<=b.right_no) //左少右多+左少右多 谁的左面数量多谁放前面\n        return a.left_no>b.left_no;\n    return a.right_no<b.right_no; // 左多右少 左多右少 谁的右边多谁放后面\n\n}\nchar s[5000010];\nint main()\n{\n    int n,t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        vector<node>a(n);\n        int len;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",s);\n            len=strlen(s);\n            long long left=0,right=0,ans=0;\n            for(int j=0;j<len;j++)\n            {\n                if(s[j]=='(')\n                    left++;\n                else\n                {\n                    if(left>0)  left--,ans++;\n                    else    right++;\n                }\n            }\n            a[i].left_no=left;\n            a[i].right_no=right;\n            a[i].yes=ans;\n        }\n        sort(a.begin(),a.end(),cmp);\n        long long left=0,right=0,ans=0;\n        for(int i=0;i<n;i++)\n        {\n            ans+=a[i].yes;\n            if(left>=a[i].right_no)\n                left-=a[i].right_no,ans+=a[i].right_no;\n            else\n                ans+=left,left=0;\n            left+=a[i].left_no;\n        }\n        printf(\"%lld\\n\",ans*2);\n    }\n    return 0;\n}\n```\n\n","tags":["贪心"],"categories":["算法"]},{"title":"Swordsman(多个优先队列)","url":"/2018/08/15/Swordsman(多个优先队列)/","content":"\n# [ Swordsman](http://acm.hdu.edu.cn/showproblem.php?pid=6396) \n\n## 题意\n\n给你一个n,代表有n个队伍，一个k，代表每个队伍中有k个战士，对应k个经验值，我方队伍中也有k个战士。\n\n输入我方战士的k个战斗力，\n\n接下来每一行输入敌方每个队伍k个战士的战斗力，打败k个战士后可以得到的经验值。\n\n只有我方k个战士的战斗力均对应大于敌方某个队伍中k个战士的战斗值，才能得到相应的k个经验，提升战斗力，然后接着跟其他的队伍打。\n\n问你我方战士每个人最后最多能为多少战斗力？\n\nk<=5,n<=1e5，保证得到的战斗力在int范围内。\n\n## 思路\n\n首先由于读入数据大，先来个读入挂。\n\n然后我们可以对每一种敌方战士（列），建立k个优先队列，以战斗值小为上。\n\n然后不断循环，每次从第1个战士开始和第1个队列中的敌方战士打，如果强于他，就弹出这个战士，并记录这个战士对应的队伍中的战败情况，一旦他们的队伍全军覆没，我方每个战士就可以得到相应的经验值，然后和第i个队列中的战士打，一直到i=k为止，结束一轮循环。\n\n然后一直循环直到某一次循环中不再有打赢他们的情况出现。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >a[6];\nnamespace IO {\n    const int MX = 4e7; //1e7 占用内存 11000kb\n    char buf[MX]; int c, sz;\n    void begin() {\n        c = 0;\n        sz = fread(buf, 1, MX, stdin);//一次性全部读入\n    }\n    inline bool read(int &t) {\n        while (c < sz && buf[c] != '-' && (buf[c] < '0' || buf[c] > '9')) c++;\n        if (c >= sz) return false;//若读完整个缓冲块则退出\n        bool flag = 0; if(buf[c] == '-') flag = 1, c++;\n        for(t = 0; c < sz && '0' <= buf[c] && buf[c] <= '9'; c++) t = t * 10 + buf[c] - '0';\n        if(flag) t = -t;\n        return true;\n    }\n}\nint n,k,x,d[6],b[100008][6],c[100008]; //d用来存当前战斗力，b是打败的奖励，c是记录某一行的打败情况\npair<int,int>zz;\nint main()\n{\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    IO::begin();\n    IO::read(t);\n    while(t--)\n    {\n        IO::read(n);\n        IO::read(k);\n        memset(c,0,sizeof(c));\n        for(int i=1;i<=k;i++) IO::read(d[i]);\n        for(int i=1;i<=k;i++)\n        {\n            while(a[i].size()) a[i].pop();\n        }\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=k;j++) IO::read(x),zz.first=x,zz.second=i,a[j].push(zz); //先把所有的情况放到优先队列中\n            for(int j=1;j<=k;j++) IO::read(b[i][j]);\n        }\n        int ans=0;\n        bool f;\n        while(true)\n        {\n            f=0;\n            for(int i=1;i<=k;i++)    //对于每一列\n            {\n                while(!a[i].empty()) //对于某一列的最小的元素\n                {\n                    zz=a[i].top();\n                    if(zz.first<=d[i])  //可以打败\n                    {\n                        a[i].pop();\n                        c[zz.second]++;  //记录下这一行的打败情况\n                        if(c[zz.second]==k) //如果这一行都打败了 ，就吃掉啦\n                        {\n                            for(int j=1;j<=k;j++) d[j]+=b[zz.second][j];\n                            ans++,f=1;\n                        }\n                    }\n                    else break;\n                }\n            }\n            if(!f) break; //如果某次循环中没有能吃的，就break了\n        }\n        cout<<ans<<endl;\n        for(int i=1;i<=k;i++)\n        {\n            if(i==1) cout<<d[i];\n            else cout<<\" \"<<d[i];\n        }\n        puts(\"\");\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Age of Moyu(bfs)","url":"/2018/08/15/Age-of-Moyu(bfs)/","content":"\n# [Age of Moyu](http://acm.hdu.edu.cn/showproblem.php?pid=6386) \n\n## 题意\n\n给你n个点，m条边，要求从1号走到n号，每条边上都有一种颜色，如果你在相同颜色的边上走，不会有额外的花费，但是如果你从一种颜色的边走到另一种颜色的边上，那么就要加1的花费，求的是最小花费。\n\n1<=n<=1e5, 0<=m<=2e5\n\n多组。\n\n## 思路\n\n如果直接bfs优先队列处理大顶堆的话，把跑过的点或者边标记了的话，是考虑不周到的。\n\n如：\n\n6 8 \n\n1 2 2 \n\n2 3 2 \n\n3 4 2 \n\n1 4 1 \n\n1 5 1\n\n4 5 2 \n\n5 6 2 \n\n2 6 1  答案应该是1，但是很多都容易输出2。\n\n正确的做法是，用set[i]储存每次到达点i的前驱结点，如果到达这个点的花费比历史中到达这个点的最小花费要大，就continue,如果相等，前驱结点在set中，continue，如果不在set中，就放入set中，如果小于的话，就把set[i]清空，然后把历史最小花费mincost[i]更新了，并且把前驱结点放到set中（我发现放这条边的颜色也是可以的），然后对当前这个点连出去的每一条边继续判断，如果不是反向边，而且mincost[nxt]>=（(当前颜色!=下个颜色)+mincost[i]），就把mincost[nxt]更新了，并且如果nxt点不是终点，就把nxt点push到优先队列中，优先队列存的是每一个点的到达状态，按照到达的花费从小到大放。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn =1e5+5;\nstruct edge{\n    int to,color,nxt; //下一个点，这条边的颜色，对于这个点相连的下一条边\n}e[maxn<<2];\nset<int>preid[maxn]; //到达某点时花费相同的前一个结点\nint idcost[maxn]; //到达某点的最小花费\nint head[maxn]; //暂时记录上一条边的\n\nstruct node{\n    int val,id;//当前总花费，当前到达点\n    int color,father;//前一条边上的颜色，前一个结点\n    bool operator <(const node &p) const{return val>p.val;}\n};\n\nint solve(int n)\n{\n    priority_queue<node>q;\n    idcost[1]=0;\n    q.push((node){idcost[1],1,-1,-1});\n    int len,id,color,father,tot,i,cl,nxt;\n    node tmp;\n    while(!q.empty())\n    {\n        tmp=q.top();\n        q.pop();\n        id=tmp.id,tot=tmp.val,father=tmp.father,color=tmp.color;\n        if(tot>idcost[id]) continue; //如果当前到达的总花费比到这一点的最小的花费要贵\n        else if(tot==idcost[id])\n        {\n            if(preid[id].find(color)!=preid[id].end()) //如果当前到达点已经记录了前一个点的颜色//我发现father前驱结点也是对的\n                continue;\n            preid[id].insert(color);\n        }\n        else //更新最小花费\n        {\n            preid[id].clear();\n            preid[id].insert(color);\n            idcost[id]=tot;\n        }\n        for(i=head[id];~i;i=e[i].nxt) //对于这个点连接的其他点\n        {\n            cl=e[i].color;\n            nxt=e[i].to;\n            if(nxt==father) continue; //反向边\n            if(((cl!=color)+idcost[id])<=idcost[nxt])\n            {\n                idcost[nxt]=(cl!=color)+idcost[id];\n                if(nxt!=n)\n                    q.push((node){idcost[nxt],nxt,cl,id});\n            }\n        }\n    }\n    if(idcost[n]==INF) return -1;\n    return idcost[n];\n}\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n#endif\n    int n,m;\n    int u,v,w;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(head,-1,sizeof(head));\n        memset(idcost,INF,sizeof(idcost));\n        int total=0;\n        for(int i=1;i<=n;i++)\n            preid[i].clear();\n        while(m--)\n        {\n            scanf(\"%d%d%d\",&u,&v,&w);\n            e[total]=(edge){v,w,head[u]}; //一种新型存边方式hhh\n            head[u]=total++;\n            e[total]=(edge){u,w,head[v]};\n            head[v]=total++;\n        }\n        printf(\"%d\\n\",solve(n));\n    }\n    return 0;\n}\n```\n\n","tags":["bfs"],"categories":["算法"]},{"title":"Sequence(整除分块+矩阵快速幂)","url":"/2018/08/14/Sequence(整除分块+矩阵快速幂)/","content":"\n## [ Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=6395) \n\n## 题意\n\n定义：\n$$\nF_1=A\n$$\n\n$$\nF_2=B\n$$\n\n$$\nF_n=D\\cdot{}F_{n-1}+C\\cdot{}F_{n-2}+\\lfloor\\frac{P}{n}\\rfloor\n$$\n\n求Fn，Mod1e9+7。\n\n## 思路\n\n一看到这个向下取整！\n\n多么亲切啊！\n\n整除分块啊！\n\n……\n\n一开始怎么都想不出来怎么把分块用进去，队友一波机智，先分块，然后矩阵快速幂，哇，秒啊，然后两个小时过去了……\n\n由于莫比乌斯中我们经常会用到一个分块的概念：\n$$\n\\sum_{i=1}^n\\lfloor\\frac{n}{i}\\rfloor\n$$\n\n```c++\nfor(int l=1,r;l<=n;l=r+1)\n{\n    r=n/(n/l);\n    ans+=(r-l+1)*(n/l);\n}\n```\n\n那么我们就想，因为矩阵快速幂要求的是尾项是个常数，而对于这个整除来说，在某些区间内它的值是一定的，因此我们就可以先把他们划分为好几块，然后对于每个区间进行矩阵快速幂即可，有些细节注意，比如说次数不足3次时，要手写一波判断，因为没有需要的Fn-1，Fn-2，比如n小于p的时候，需要在循环内直接结束，比如n大于p的时候，分块结束后再进行裸的矩阵快速幂。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9+7;\nstruct mat\n{\n    long long a[3][3];\n}m,r;\nmat mult(mat x,mat y)\n{\n    mat res={0};\n    int i,j,k;\n    for(i=0;i<3;i++)\n    for(j=0;j<3;j++)\n    for(k=0;k<3;k++)\n        res.a[i][j]=(res.a[i][j]+(x.a[i][k]*y.a[k][j])%MOD)%MOD;\n    return res;\n}\nmat PowerMod(mat x,long long n)\n{\n    mat ans={0};\n    int i,j;\n    for(i=0;i<3;i++)\n    ans.a[i][i]=1;\n    while(n>0)\n    {\n        if(n%2==1)\n        ans=mult(ans,x);\n        x=mult(x,x);\n        n=n/2;\n    }\n    return ans;\n}\nint main()\n{\n    int t;\n    ll a,b,c,d,p,n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld%lld%lld%lld%lld%lld\",&a,&b,&c,&d,&p,&n);\n        if(n==1) { printf(\"%lld\\n\",a);continue;}\n        else if(n==2) { printf(\"%lld\\n\",b);continue;}\n        m.a[0][2]=m.a[1][1]=m.a[2][1]=m.a[2][0]=0;\n        m.a[0][0]=d;m.a[0][1]=c;\n        m.a[1][0]=m.a[2][2]=1;\n        ll pre=b,ppre=a;\n        for(int L=3,R;L<=p;L=R+1)\n        {\n\n            R=p/(p/L); \n            int zs=min(1ll*R-L+1,n-L+1);\n            if(zs<=3)\n            {\n                for(int i=1;i<=zs;i++)\n                {\n                    ll tmp=pre;\n                    pre=((pre*d+ppre*c)%MOD+p/L)%MOD;\n                    ppre=tmp;\n                }\n                if(n>=L&&n<=R) break;\n                continue;\n            }\n            m.a[0][2]=p/L;\n            r=PowerMod(m,zs);\n            ll p1=(r.a[0][0]*pre+r.a[0][1]*ppre+r.a[0][2])%MOD;\n            ll p2=(r.a[1][0]*pre+r.a[1][1]*ppre+r.a[1][2])%MOD;\n            pre=p1;ppre=p2;\n            if(n>=L&&n<=R) break;\n        }\n        if(n>p)\n        {\n            m.a[0][2]=0;\n            r=PowerMod(m,n-max(2ll,p));\n            ll p1=(r.a[0][0]*pre+r.a[0][1]*ppre+r.a[0][2])%MOD;\n            pre=p1;\n        }\n        printf(\"%lld\\n\",pre);\n    }\n    return 0;\n}\n```\n\n","tags":["矩阵快速幂"],"categories":["算法"]},{"title":"Family View（AC自动机求匹配串位置）","url":"/2018/08/14/Family-View（AC自动机求匹配串位置）/","content":"\n# [Family View](https://nanti.jisuanke.com/t/29367) \n\n## 题意\n\n就是给你n个模式串，长度总和不超过1e6，给你一个匹配串，长度不超过1e6，然后要求是把匹配的字符换成\"*\"。\n\n## 思路\n\nAC自动机，在标记尾节点的地方（个数）顺带标记一下匹配串的最长长度，然后用vector pair存一下每次匹配时的位置和匹配的长度，最后对于每一pair进行处理。（对了 先把模式串用小写的保存下来，因为不区分大小写）\n\n## 看！代码\n\n```c++\n//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxm=1000006;    //maxm是总结点数：约为字母数+++\n\nchar S[maxm],word[maxm];\nchar s2[maxm];\nstruct node{\n    int tail;\n    int len;\n}tt[maxm];\nint nxt[maxm][26],f[maxm],size;    //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数\nvector<pair<int,int> >Index; //位置、长度\n\nint newnode(){    //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号\n    memset(nxt[size],0,sizeof(nxt[size]));\n    f[size]=tt[size].tail=0;\n    tt[size].len=0;\n    return size++;\n}\n\nvoid insert(char s[]){    //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作\n    int i,p=0;\n    for(i=0;s[i];i++){\n        int &x=nxt[p][s[i]-'a'];\n        p=x?x:x=newnode();\n    }\n    tt[p].tail++;    //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成\n    tt[p].len=max(tt[p].len,(int)strlen(s));\n}\n\nvoid makenxt(){    //利用bfs来构造失配指针\n    int i;\n    queue<int>q;\n    f[0]=0;    //先将0结点挂的字母加入队列，失配指针指向0结点\n    for(i=0;i<26;i++){\n        int v=nxt[0][i];\n        if(v){\n            f[v]=0;\n            q.push(v);\n        }\n    }\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(i=0;i<26;i++){\n            int v=nxt[u][i];\n            if(!v)nxt[u][i]=nxt[f[u]][i];    //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母\n            else{\n                q.push(v);    //u结点存在指向i的结点，则将所指向的结点下标加入队列\n                f[v]=nxt[f[u]][i];    //失配指针指向上个结点失配指针指向结点所挂当前字母的结点\n            }\n        }\n    }\n}\n\nint query(char s[]){    //查询s串中模式串出现了多少种/次\n    int ans=0,v=0;\n    for(int i=0;s[i];i++){\n        while(v&&!nxt[v][s[i]-'a'])v=f[v];    //先匹配直到没有失配\n        v=nxt[v][s[i]-'a'];\n        int tmp=v;\n        while(tmp){\n            if(tt[tmp].tail!=0) //这里！\n                Index.push_back(make_pair(i,tt[tmp].len));\n            tmp=f[tmp];\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int T;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        Index.clear();\n        int n;\n        scanf(\"%d\",&n);\n        size=0,newnode();\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",word);\n            insert(word);\n        }\n        makenxt();\n        getchar();\n        gets(S);\n        int len=strlen(S);\n        for(int i=0;i<len;i++)\n            if(S[i]>='A'&&S[i]<='Z')\n                s2[i]=S[i]-'A'+'a';\n            else\n                s2[i]=S[i];\n        query(s2);\n        len=Index.size();\n        for(int i=0;i<len;i++)\n  \t    {\n            for(int j=0;j<Index[i].second;j++)\n                S[Index[i].first-j]='*';\n        }\n        puts(S);\n    }\n    return 0;\n}\n```\n\n\n\n## AC自动机注释模板\n\n```c++\n//该程序不能判别相同模式串，因此若模式串重复，答案会将相同模式串当做不同的处理，因此若需要可以用map去重或修改insert\n#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\nconst int maxm=500006;    //maxm是总结点数：约为字母数+++\n\nchar s[1000005],word[55];\nint nxt[maxm][26],tail[maxm],f[maxm],size;    //nxt是结点指向不同字母的结点下标，tail是表示该结点为几个单词的词尾(可能需要计算重复的模式串情况),f是当不匹配时转跳到的结点下标,size是结点数\n\nint newnode(){    //初始化整个trie或建立新的结点时，首先初始化当前结点所指向的26个字母的结点为0，表示暂时还没有指向的字母，然后暂定该结点不是单词尾结点，暂无失配时转跳位置（即转跳到根节点），返回结点标号\n    memset(nxt[size],0,sizeof(nxt[size]));\n    f[size]=tail[size]=0;\n    return size++;\n}\n\nvoid insert(char s[]){    //构造trie,p为当前结点的上一个结点标号，初始为0；x即为当前结点（上个结点标号指向当前字母的结点）标号,若此结点还未出现过，那么就建立这个结点；然后更新p为当前结点标号以便后续操作\n    int i,p=0;\n    for(i=0;s[i];i++){\n        int &x=nxt[p][s[i]-'a'];\n        p=x?x:x=newnode();\n    }\n    tail[p]++;    //此时仅将s串记录，即将s串结尾的结点加1，若无相同模式串，则此操作只会使所有串尾结点的tail值由0变为1，但有相同模式串，则会重复记录，需要去重可以用map或用tail[p]=1;语句来完成\n}\n\nvoid makenxt(){    //利用bfs来构造失配指针\n    int i;\n    queue<int>q;\n    f[0]=0;    //先将0结点挂的字母加入队列，失配指针指向0结点\n    for(i=0;i<26;i++){\n        int v=nxt[0][i];\n        if(v){\n            f[v]=0;\n            q.push(v);\n        }\n    }\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(i=0;i<26;i++){\n            int v=nxt[u][i];\n            if(!v)nxt[u][i]=nxt[f[u]][i];    //当u结点没有i对应字母，则视为失配，将其指向失配后转跳到的结点所指向的i对应字母\n            else{\n                q.push(v);    //u结点存在指向i的结点，则将所指向的结点下标加入队列\n                f[v]=nxt[f[u]][i];    //失配指针指向上个结点失配指针指向结点所挂当前字母的结点\n            }\n        }\n    }\n}\n\nint query(char s[]){    //查询s串中模式串出现了多少种/次\n    int ans=0,v=0;\n    for(int i=0;s[i];i++){\n        while(v&&!nxt[v][s[i]-'a'])v=f[v];    //先匹配直到没有失配\n        v=nxt[v][s[i]-'a'];\n        int tmp=v;\n        while(tmp){\n            ans+=tail[tmp];\n            tail[tmp]=0;    //这里加这句是为了仅计算出现多少种模式链，而若不加这句则可以计算累计出现多少次\n            tmp=f[tmp];\n        }\n    }\n    return ans;\n}\n\nint main(){\n    int T;\n    scanf(\"%d\",&T);\n    while(T--){\n        int n;\n        scanf(\"%d\",&n);\n        size=0,newnode();\n        for(int i=0;i<n;i++){\n            scanf(\"%s\",word);\n            insert(word);\n        }\n        makenxt();\n        scanf(\"%s\",s);\n        printf(\"%d\\n\",query(s));\n    }\n    return 0;\n}\n```\n\n**结构体版**\n\n```c++\n#include<iostream> //查询匹配的数量 ，不知道有没有带重复的\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nstruct asd{\n    int fail; // 失配指针\n    int vis[26]; // 子节点的位置\n    int end; // 标记有几个单词以这个节点结尾 \n} AC[1000010];\nint rt,cnt,l,n;\nchar ch[1000010];\n\ninline void build(char *ch)\n{\n    int l=strlen(ch+1);\n    int now=rt,v;\n    for(int i=1;i<=l;i++)\n    {\n        v=ch[i]-'a';\n        if(!AC[now].vis[v]) AC[now].vis[v]=++cnt;\n        now=AC[now].vis[v];\n    }\n    AC[now].end+=1;\n}\n\ninline void get_fail()\n{\n    queue <int> Q;\n    for(int i=0;i<=25;i++) // 第一层肯定没有之前的点与他匹配 \n        if(AC[rt].vis[i]) \n            Q.push(AC[rt].vis[i]); // 因为默认是 0 所以没有写指向根节点 \n    while(!Q.empty())\n    {\n        int u=Q.front(); Q.pop();\n        for(int i=0;i<=25;i++) // 枚举所有子节点\n        {\n            if(AC[u].vis[i]) // 存在这个子节点\n            {\n                AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];\n                // 子节点的fail指针指向当前节点的\n                // fail指针所指向的节点的相同子节点 \n                Q.push(AC[u].vis[i]);\n            }\n            else //不存在这个子节点\n            AC[u].vis[i]=AC[AC[u].fail].vis[i];\n            // 当前节点的这个子节点指向当\n            // 前节点fail指针的这个子节点 \n        }\n    }\n}\n\ninline int query(char *ch)\n{\n    int l=strlen(ch+1);\n    int now=rt,ans=0,u;\n    for(int i=1;i<=l;i++)\n    {\n        u=ch[i]-'a';\n        now=AC[now].vis[u];\n        for(int j=now; j && AC[j].end!=-1; j=AC[j].fail)\n        {\n            ans+=AC[j].end;\n            AC[j].end=-1;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%s\",ch+1);\n        build(ch);\n    }\n    get_fail();\n    scanf(\"%s\",ch+1);\n    printf(\"%d\\n\",query(ch));\n    return 0;\n}\n\n```\n\n","tags":["AC自动机"],"categories":["算法"]},{"title":"GuGuFishtion(欧拉函数公式+莫比乌斯)","url":"/2018/08/14/GuGuFishtion(欧拉函数公式+莫比乌斯)/","content":"\n## [GuGuFishtion](http://acm.hdu.edu.cn/showproblem.php?pid=6390) \n\n## 题意\n\n求：\n$$\nAns=\\sum_{i=1}^{n}\\sum_{j=1}^m\\frac{φ(ij)}{φ(i)φ(j)}\\%p\n$$\n其中，n,m<=1e6, max(n,m)<=p<=1e9，且p为素数。\n\n##思路\n\n由欧拉函数公式：\n$$\nφ(x)=x(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})…(1-\\frac{1}{p_n})，其中p_i为x的质因子\n$$\n将公式带入$\\frac{φ(ij)}{φ(i)φ(j)}$中：\n$$\n原式=\\frac{ij(1-\\frac{1}{c_1})…(1-\\frac{1}{c_t})}{i(1-\\frac{1}{a_1})…(1-\\frac{1}{a_n})j(1-\\frac{1}{b_1})…(1-\\frac{1}{b_m})}\n$$\n\n$$\n=\\frac{1}{(1-\\frac{1}{a_1})(1-\\frac{1}{a_2})…(1-\\frac{1}{b_1})(1-\\frac{1}{b_2})…}\n$$\n\n上下同乘以gcd(i,j)，则可以得到：\n\n(这里虽然讲不清楚但是大致是一个容斥)\n$$\n原式=\\frac{gcd(i,j)}{gcd(i,j)-gcd(i,j)/质因数的任意组合+gcd(i,j)/所有质因子的组合}\n$$\n\n$$\n=\\frac{gcd(i,j)}{φ(gcd(i,j))}\n$$\n\n因此\n$$\nAns=\\sum_{i=1}^{n}\\sum_{j=1}^m\\frac{gcd(i,j)}{φ(gcd(i,j))}\\%p\n$$\n令k=gcd(i,j)，并枚举k，有：\n$$\nAns=\\sum_{i=1}^{n}\\sum_{j=1}^m\\sum_{k=1}^{min(n,m)}\\frac{k}{φ(k)}[gcd(i,j)==k]\\%p\n$$\n\n$$\n=\\sum_{k=1}^{min(n,m)}\\frac{k}{φ(k)}\\sum_{i=1}^{n}\\sum_{j=1}^m[gcd(i,j)==k]\\%p\n$$\n\n$$\n=\\sum_{k=1}^{min(n,m)}\\frac{k}{φ(k)}\\sum_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}[gcd(i,j)==1]\\%p\n$$\n\n$$\n=\\sum_{k=1}^{min(n,m)}\\frac{k}{φ(k)}\\sum_{i=1}^{\\lfloor\\frac{n}{dk}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{dk}\\rfloor}\n\\sum_{d=1}^{min(n,m)}μ(d)\\%p\n$$\n\n$$\n=\\sum_{k=1}^{min(n,m)}\\frac{k}{φ(k)}\\sum_{d=1}^{min(n,m)}μ(d){\\lfloor\\frac{n}{dk}\\rfloor}{\\lfloor\\frac{m}{dk}\\rfloor}\\%p\n$$\n\n就可以做啦！\n\n枚举k=1~min(n,m)，先分析出要预先求的东西：\n\n1. μ(d)\n2. φ(k)\n\n预处理：由于n/dk向下取整时，当dk>n，值为0，因此我们只要先枚举dk=1到min(n,m)即可。\n\n然后对于for(k)，dk为d的倍数增长，此时，d=dk/k,将μ(dk/k)、n/dk、m/dk相乘，取模得到F(k)+=。\n\n计算：然后就可以一个大循环，枚举k从1~min(n,m)，求得k\\*逆元(φ(k))，再*先前求得的F(k)，并取模即可。\n\n注意：由于时间限制， 取模一定要尽量少取。特别是在预处理阶段中，求F(k)时，由于F(k)是重复累加的，因此若是**每一次累加都取模，会造成不必要的时间浪费**，因此我们可以把F(k)开long long，然后在全部预处理完毕之后再一次性for取模。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll MOD;\nconst int maxn = 1000000 + 5;\nint phi[maxn],mu[maxn],prim[maxn];\nbool vis[maxn]={0};\n\nll quzheng[maxn],f[maxn];\nint cnt=0;\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll n)//乘法逆元，a与n必须互素\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n    mu[1]=phi[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;phi[i]=i-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0) {phi[i*prim[j]]=phi[i]*prim[j];break;}\n        \telse {mu[i*prim[j]]=-mu[i];phi[i*prim[j]] = phi[i] * phi[prim[j]];}\n    \t}\n\t}\n\n}\n\nint cal(int n,int m)\n{\n    memset(f,0,sizeof(f));\n    int MIN=min(n,m);\n    for(int i=1;i<=MIN;i++) quzheng[i]=1ll*(n/i)*(m/i);\n    for(int i=1;i<=MIN;i++)\n        for(int j=i;j<=MIN;j+=i)\n            f[i]+=1ll*mu[j/i]*quzheng[j];\n    for(int i=1;i<=MIN;i++) //就是这个TLE\n        f[i]%=MOD;\n}\n\nint main()\n{\n    int n,m,t;\n    get_mu(1000000);\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d%lld\",&m,&n,&MOD);\n        cal(n,m);\n        int MIN=min(n,m);\n        ll ans=0;\n        for(int i=1;i<=MIN;i++)\n        {\n            ans=(ans+(1ll*i*mod_inverse(phi[i],MOD))%MOD*f[i]+MOD)%MOD;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"Recovery(构造)","url":"/2018/08/12/recovery/","content":"\n## [Recovery](https://nanti.jisuanke.com/t/29559) \n\n## 题意\n\n给两行，由01组成，一行表示行中1的个数，一行表示列中1的个数，奇数为1，偶数为0。\n\n如果不能构造就是-1，能就输出原来的矩阵的样子。\n\n按照1尽可能的多，然后字典序小。\n\n\n\n## 思路\n\n不太好说，这个。。。。就。。。看代码吧。\n\n主要是发现行列之间1的关系，以及如何放比较好，。\n\n## 看！代码\n\n\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    string hang;\n    string lie;\n    cin>>hang>>lie;\n    int h[55],l[55];\n    int lenh,lenl;\n    int cnth=0,cntl=0;\n    lenh=hang.size(),lenl=lie.size();\n    for(int i=0;i<lenh;i++)\n    {\n        if(hang[i]=='0'&&lenl%2==0||hang[i]=='1'&&lenl%2==1)\n            h[i]=0;\n        else h[i]=1,cnth++;\n    }\n    for(int i=0;i<lenl;i++)\n    {\n        if(lie[i]=='0'&&lenh%2==0||lie[i]=='1'&&lenh%2==1)\n            l[i]=0;\n        else l[i]=1,cntl++;\n    }\n    if(cnth%2!=cntl%2)\n    {\n        printf(\"-1\\n\");return 0;\n    }\n    int i=0;\n    while(cnth<cntl)\n    {\n        if((h[i]+2)<=lenl) h[i]+=2,cnth+=2;\n        else i++;\n    }\n    i=0;\n    while(cnth>cntl)\n    {\n        if((l[i]+2)<=lenh) l[i]+=2,cntl+=2;\n        else i++;\n    }\n    for(i=0;i<lenh;i++)\n    {\n        for(int j=0;j<lenl;j++)\n        {\n            if(h[i]!=0&&l[j]!=0)\n            {\n                h[i]--,l[j]--;\n                printf(\"0\");\n            }\n            else printf(\"1\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n```\n\n","categories":["算法"]},{"title":"Bramasole","url":"/2018/08/12/Bramasole/","content":"\n\n\n<img src=\"https://xheartbeat.top/mdpicture/托斯卡纳艳阳下.jpg\" alt=\"白色恋人，浪漫的意大利男性，治愈的开始，另一场人生的结束\">\n\n> “我把集市上买的一颗热葡萄塞进嘴里，肆意的甜蜜在口腔蔓延，甚至闻起来也是紫色的。”\n\n这大概是在整部电影中让我印象最深刻的一句话了。\n\n\n\n在徐志摩先生笔下，佛罗伦萨（翡冷翠）是有风穿过橄榄林带来着石榴花香，蓝天白云下有色彩鲜艳的隔壁，深绿色的百叶窗和深红色的屋顶，隔着夜，隔着天，通着恋爱的灵犀一点。旅行、到一个五颜六色的地方，认识五颜六色的陌生人。在看完这部电影之后，我几乎就想即刻动身了。我知道有这么一个地方，它有充足的阳光，适合葡萄生长，也适合酿造爱情和生活，“当太阳照在山顶上的伊特鲁里亚石壁上，洋槐树就被镶上金边，色彩柔和的房子沿着小河岸弯弯曲曲的排列，如同水彩画一般”，“微风吹拂的白色窗帘，墙角灰白色的陶罐，麦田里新收的草卷儿”。我希望一动不动的盯着这片土地，天旋地转。旅行的魅力。\n\n\n\n而托斯卡纳的乡野，总会使人联想起高更、梵高那些大师们的画笔，大片大片浓厚的色彩，金色的、橘色的、紫罗兰色的，这般会流动的色彩。语言在其面前是多么苍白。如果可以，我甚至想把那些灿烂的色彩贴在这张白纸上。像墨绿的火焰一样朝向天空的树林，金光流溢的草原，盛开的虞美人，色彩的盛宴。\n\n这里有达芬奇，有文艺复兴，还有郁郁葱葱长满葡萄藤的山坡。\n\n然后弗兰西斯来到了这里。\n\n在明信片上写下了“紫色”的心情，开始改变，是托斯卡纳送给她的第一份礼物。\n\n\n\n原本只是一场失意的旅行，却用自己所有的积蓄买下了一座破败不堪的，连水龙头都出不了水的小房子——“Bramasole”，意大利语向往阳光的意思。命运的突然就像是在“Bramasole”中被白鸽的粪便砸中，而过去就像海中突然陆沉的岛屿，一下子消失不见了。然后一切就成真了。新生活是具体的，一砖一瓦，雕花的铁床，栏杆上的画像，刚刚成熟的橄榄，从此她拥有“三口水井、一条罗马古道、一处伊特拉斯坎人的古城墙遗址、一条地下信道、一百一十七棵橄榄树、二十棵李树、以及其他数也数不清处的果树和花丛，还可以在屋外铺着亚麻布的长桌上，吃着用院子里才来的鼠尾草做馅料的意大利方饺，敲开路边捡来的球果、用其中的松仁做出香味四溢的老祖母馅饼……”这座房子实在是太老了，就像你会随时倒下去长眠不醒的老祖母。\n\n \n\n而生活就是与人不停的邂逅，不停的与周边的环境发生关系。\n\n \n\n在她落寞绝望时充满耐心的安慰她的可靠的房产中介，靠美和灵性生活，永远纯真如孩童叫她振作起来的神秘女郎，帮法兰西斯修房子的修缮工们，还有每天早晨为路边的圣母像献上鲜花，悼念亡妻的老人，以及属于她的一场短暂的罗曼蒂克史。\n\n一点一点回移的日子就好像小野丽莎的歌，fly me to the moon，柔柔软软轻轻悄悄的，不经意而温柔的掠过。\n\n \n\n治愈是我所有能形容这部电影的词汇。\n\n \n\n其实那个时候刚好是我生活的极大转折点——一个不知道会往哪里转向的，不知是褒义还是贬义的转折点。说不知道，但当时的我，连呼吸都是不知所措。在不愿意接受的悲伤中也思考生活的方向，我知道我为什么不愿意接受这样的转折，尽管它的本质是好的。就像弗兰西斯，离婚也是她不愿意接受的事实，是很难走出来的人生巨大的转折点。在这样的时刻，往往所有的注意力会被吸引，会失去对其他事物的热情，天晴的时候在下雨，下雨的时候整个人都会湿透。弗兰西斯在忙碌琐碎的装修之中顾不及心碎的滋味，但我一静下来，手头空空荡荡的时候，各种情绪翻江倒海的来了，落魄不止。\n\n \n\n我听到弗兰西斯一个人的嘶喊：\n\n“我一个人住那么大的房子有什么用？”\n\n \n\n那你为什么还要在这里？\n\n \n\n“因为我厌倦了恐惧，因为我的心底仍然有希望。”\n\n“我想要在这里举办一场婚礼，我想要有一个家。”\n\n \n\n有时候遇到很糟糕的境遇，躲不开、避不掉的重重压力围城，生活被就像被胡乱泼了墨。在这个时候，希望是最美好的东西。\n\n \n\n好心的中介讲了这么一个故事，他说奥地利和意大利之间的阿尔卑斯山脉中有一段叫做塞默灵，那段山脉地势险峻，令人望而生畏，他们在那里建造了连通维也纳和威尼斯的铁路。尽管当时根本没有火车可以驶过，但他们依然把铁轨铺好了，因为他们知道总有一天会有火车驶过。 \n\n你不必期待、不必翘首以盼，该来的总会来，而你，只需要做好准备。\n\n杨绛先生说：“人的一切痛苦本质上都是对自己无能的愤怒。”有时候我们不快乐，是因为想要的太多，希望一切都在自己的手里。但是又何必呢，我们掌握不了的东西就任其流浪，有一句很俗很俗的话讲，该来的总会来。“当我还是个小女孩时，我总是数小时地看瓢虫，最后，我会放弃，然后在草地上睡着了。当我醒来的时候，它们爬得我满身都是。”\n\n影片的最后，弗兰西斯的愿望在托斯卡纳实现了。她想要一个家，托斯卡纳给了她一个靠自己撑起来的家；她想要一场婚礼，一对漂亮真挚的小爱人在她的家里举办了婚礼；她想要孩子，她的好友带着自己刚出世的宝宝和自己的同性恋人来她的房子度假。她想要的一切都有了，只是换了一种方式。\n\n最终，屋子里干涸的水龙头会有潺潺的流水，而好事总会来到，而当它来晚时，也不失为一种惊喜。\n\n“希望你也在这里。”","tags":["随想"],"categories":["Life & Story"]},{"title":"2018暑期训练题解","url":"/2018/08/11/2018暑期集训/","content":"\n<h2>7.7 [BAPC 2014 Preliminary](https://www.jisuanke.com/contest/1403)</h2>\n\n\n\nA. 思维题，重点在于当剩余的n<k时，只要k%n==0就可以成功，比如 64 6的时候，先约分：32：6，再约：16:6，一直约到 1:6 ，那n=1，当然ok。\n\nB. dijkstra最短路一下\n\nD. Dp，结束后想了一下，dp[i]表示第i层停下来的所有怨气，dp[i]=min(dp[i],dp[j] + val(j->i)) ,（j<i）i之前电梯停在j层，然后从j直接到i 的话，加上这一部分的怨气就好了val，而valij的怨气就是i的前缀和加上若每一层都停的怨气，再减去了j层停下来的人消失的这部分怨气。\n\n<img src=\"\\mdpicture\\20180712A.jpg\" alt=\"20180712A\"/>\n\nF. 飞行航道 水\n\nJ. 找单词，八方找，正反找。看了题解 好像是先判断了一下回文减少了一下长度？\n\n<h2>7.10 [ Benelux Algorithm Programming Contes](https://www.jisuanke.com/contest/1404)</h2>\n\n\n\nB.  最少按下的按钮次数\n\n用bfs，时间小于0，变成0，大于3600，变为3600。vis[i]记录时间为i的最少步骤数目。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nint n,sum;\nint a[20],vis[3610];\nstruct node{\n    int val;\n    int step;\n};\nvoid solve()\n{\n    queue<node>q;\n    node temp,tp;\n    temp.val=0;\n    temp.step=0;\n    q.push(temp);\n    vis[0]=0;\n    while(!q.empty())\n    {\n        temp=q.front();\n        q.pop();\n        for(int i=0;i<n;i++)\n        {\n            int cur=temp.val+a[i];\n            if(cur<0) cur=0;\n            else if(cur>3600) cur=3600;\n            if(vis[cur]==-1)\n            {\n                vis[cur]=temp.step+1;\n                tp.step=temp.step+1;\n                tp.val=cur;\n                q.push(tp);\n            }\n        }\n    }\n}\nint main()\n{\n    int t;\n\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&sum);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        memset(vis,-1,sizeof(vis));\n        solve();\n        for(int i=sum;i<=3600;i++)\n            if(vis[i]!=-1)\n        {\n            printf(\"%d %d\\n\",vis[i],i-sum);\n            break;\n        }\n    }\n    return 0;\n}\n\n```\n\nG. 水\n\nI. 计算组成n的最小的两个斐波那契数a b，其中按b小来排，且a<b\n\n\n\n<img src=\"\\mdpicture\\180710I.jpg\" alt=\"180710I.jpg\"/>\n\n由上可知，先计算出最大的两个相邻数相加小于n的地方，设为x，y（x<y），然后xa+yb=n,从b=1开始求满足条件的a，且a<b。\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[1000];\nconst int INF=0x3f3f3f3f;\nint main()\n{\n    a[0]=a[1]=1;\n    for(int i=2;i<44;i++)\n        a[i]=a[i-1]+a[i-2];\n    //小于1e9的斐波那契\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        int loc;\n        //计算出最大的两个相邻数相加小于n的地方\n        for(int i=43;i>=1;i--)\n        {\n            if((a[i]+a[i-1])<=n)\n            {\n                loc=i;break;\n            }\n        }\n        int ai_1;\n        while(loc>0)\n        {\n            for(int i=1;i*a[loc]<n;i++)\n            {\n                if((n-a[loc]*i)%a[loc-1]==0&&(n-a[loc]*i)/a[loc-1]<=i)\n                {\n                    ai_1=i;goto out;\n                }\n            }\n            loc--;\n        }\n    out:\n        printf(\"%d %d\\n\",(n-a[loc]*ai_1)/a[loc-1],ai_1);\n    }\n    return 0;\n}\n```\n\nJ. 把迷宫设置大，然后从中间模拟\n\n\n\n<h2>7.12</h2>\n\n\n\nB. 最小路径覆盖，网络流，最大流\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5010;\nconst int M=3000010;\nconst int inf=0x3f3f3f3f;\nstruct Edge\n{\n    int v,cap,nxt;\n}e[M];;//邻接表要开边数的两倍\nint src,des,dis[N],head[N],ecnt;  //memset dis,head-1 ecnt=0,src=0,des=2*n+1;\nint n,m;\nvoid Addedge(int u,int v,int w)\n{\n    e[ecnt].v=v;\n    e[ecnt].cap=w;\n    e[ecnt].nxt=head[u];\n    head[u]=ecnt++;\n    e[ecnt].v=u;\n    e[ecnt].cap=0;\n    e[ecnt].nxt=head[v];\n    head[v]=ecnt++;\n}\nbool Bfs()\n{\n    queue<int>q;\n    q.push(src);\n    memset(dis,-1,sizeof(dis));\n    dis[src]=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();\n        for(int i=head[u];~i;i=e[i].nxt)\n        {\n            int v=e[i].v;\n            if(e[i].cap>0&&dis[v]==-1)\n            {\n                dis[v]=dis[u]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[des]>=0;\n}\nint Dfs(int u,int a)\n{\n    if(u==des) return a;\n    for(int i=head[u];~i;i=e[i].nxt)\n    {\n        int v=e[i].v,t=0;\n        if(e[i].cap>0&&dis[v]==dis[u]+1&&(t=Dfs(v,min(a,e[i].cap))))\n        {\n            e[i].cap-=t;\n            e[i^1].cap+=t;\n            return t;\n        }\n    }\n    dis[u]=-1;\n    return 0;\n}\nint Dinic()\n{\n    int ans=0;\n    while(Bfs())\n    {\n        int t=0;\n        while(t=Dfs(src,inf)) ans+=t;\n    }\n    return ans;\n}\nint main()\n{\n    int num,u,v;\n    ecnt=0;\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&num);\n    src=0;des=2*num+1;\n    for(int i=1;i<=num;i++)\n        Addedge(0,i,1);\n    for(int i=num+1;i<=2*num;i++)\n        Addedge(i,2*num+1,1);\n    for(int i=1;i<=num;i++)\n    {\n        scanf(\"%d\",&u);\n        while(u--)\n        {\n            scanf(\"%d\",&v);\n            Addedge(i,num+v+1,1);\n        }\n    }\n    n=num+2;\n    printf(\"%d\\n\",num-Dinic());\n    return 0;\n}\n```\n\n\n\nE. 求次短路是否等于最短路长。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#define MAXN (10000 + 10)\n#define INF (5000*5000*2)\nusing namespace std;\n\nstruct edge\n{\n    int to, cost;\n    edge(int tv = 0, int tc = 0):\n        to(tv), cost(tc) {}\n};\ntypedef pair<int,int> P;\nint N, R;\nvector<edge> graph[MAXN];\nint dist[MAXN];     //最短距离\nint dist2[MAXN];    //次短距离\n\nvoid solve()\n{\n    fill(dist, dist+N, INF);\n    fill(dist2, dist2+N, INF);\n    //从小到大的优先队列\n    //使用pair而不用edge结构体\n    //是因为这样我们不需要重载运算符\n    //pair是以first为主关键字进行排序\n    priority_queue<P, vector<P>, greater<P> > Q;\n    //初始化源点信息\n    dist[0] = 0;\n    Q.push(P(0, 0));\n    //同时求解最短路和次短路\n    while(!Q.empty())\n    {\n        P p = Q.top();\n        Q.pop();\n        //first为s->to的距离，second为edge结构体的to\n        int v = p.second, d = p.first;\n        //当取出的值不是当前最短距离或次短距离，就舍弃他\n        if(dist2[v] < d) continue;\n        for(unsigned i = 0; i < graph[v].size(); i++)\n        {\n            edge &e = graph[v][i];\n            int d2 = d + e.cost;\n            if(dist[e.to] > d2)\n            {\n                swap(dist[e.to], d2);\n                Q.push(P(dist[e.to], e.to));\n            }\n            if(dist2[e.to] > d2 && dist[v] < d2)\n            {\n                dist2[e.to] = d2;\n                Q.push(P(dist2[e.to], e.to));\n            }\n        }\n    }\n}\nint main()\n{\n    int A, B, D,K;\n    scanf(\"%d%d%d\", &N, &R,&K);\n    while(K--)\n        scanf(\"%d\",&A);\n    for(int i = 0; i < R; i++)\n    {\n        scanf(\"%d%d%d\", &A, &B, &D);\n        graph[A-1].push_back(edge(B-1, D));\n        graph[B-1].push_back(edge(A-1, D));\n    }\n    solve();\n    if(dist2[N-1]==dist[N-1])\n        printf(\"yes\\n\");\n    else\n        printf(\"no\\n\");\n    return 0;\n}\n```\n\nF. 求大数因子个数，用大数分解求出质因数\n\n7-12[German Collegiate Programming Contes...](https://www.jisuanke.com/contest/1405) \n\n7-14 [https://www.jisuanke.com/contest/1444](qq://txfile/#) \n\n7-17[The 2018 ACM-ICPC Chinese Collegiate...](https://www.jisuanke.com/contest/1406) \n\n7-19[ German Collegiate Programming Contes...](https://www.jisuanke.com/contest/1407) \n\n\n\n<h2>7.23 [多校1 ](http://acm.hdu.edu.cn/contests/contest_show.php?cid=802)</h2>\n\n\n\n1001 [ Maximum Multiple](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&cid=802)  水。\n\n1002 [ Balanced Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=6299) 贪心题。对于左右括号的情况分类，然后按照规则排序。具体见代码。\n\n```c++\n#include <bits/stdc++.h>\n#pragma comment(linker, “/STACK:1024000000,1024000000”)\nusing namespace std;\nstruct node{\n    int left_no,right_no,yes;\n    node()\n    {\n        left_no=right_no=yes=0;\n    }\n};\nbool cmp(node a,node b)\n{\n    if(a.left_no>=a.right_no&&b.left_no<=b.right_no)//左少右多 + 左多右少 a前面\n        return true;\n    if(a.left_no<=a.right_no&&b.left_no>=b.right_no) //左少右多 + 左多右少 b前面\n        return false;\n    if(a.left_no<=a.right_no&&b.left_no<=b.right_no) //左少右多+左少右多 谁的左面数量多谁放前面\n        return a.left_no>b.left_no;\n    return a.right_no<b.right_no; // 左多右少 左多右少 谁的右边多谁放后面\n\n}\nchar s[5000010];\nint main()\n{\n    int n,t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d\",&n);\n        vector<node>a(n);\n        int len;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%s\",s);\n            len=strlen(s);\n            long long left=0,right=0,ans=0;\n            for(int j=0;j<len;j++)\n            {\n                if(s[j]=='(')\n                    left++;\n                else\n                {\n                    if(left>0)  left--,ans++;\n                    else    right++;\n                }\n            }\n            a[i].left_no=left;\n            a[i].right_no=right;\n            a[i].yes=ans;\n        }\n        sort(a.begin(),a.end(),cmp);\n        long long left=0,right=0,ans=0;\n        for(int i=0;i<n;i++)\n        {\n            ans+=a[i].yes;\n            if(left>=a[i].right_no)\n                left-=a[i].right_no,ans+=a[i].right_no;\n            else\n                ans+=left,left=0;\n            left+=a[i].left_no;\n        }\n        printf(\"%lld\\n\",ans*2);\n    }\n    return 0;\n}\n```\n\n1003 [ Triangle Partition](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=802) 水。 对x,y按照升序排序再每次取三个就好了。\n\n1004 [  Distinct Values](http://acm.hdu.edu.cn/showproblem.php?pid=6301) 给你一个n，一个q，表示数列中有n个元素，q个区间询问，每次一个[l,r]，表示此区间内的数字不能有重复，要求输出最小字典序的。用set维护一下区间内的数字出现情况就好了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int,int>a,pair<int,int>b)\n{\n    if(a.first==b.first)\n        return a.second>b.second;\n    return a.first<b.first;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,q,l,r;\n        scanf(\"%d%d\",&n,&q);\n        set<int>val;\n        vector<pair<int,int> >p;\n        vector<int>x(n+5);\n        for(int i = 1 ;i <= n ; i++)\n            p.push_back( make_pair(i,i) );\n        for(int i=1;i<=n;i++)\n            val.insert(i);\n        for(int i=1;i<=n;i++)\n            x[i]=1;\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d\",&l,&r);\n            p.push_back(make_pair(l,r));\n        }\n        sort(p.begin(),p.end());\n        int left=1,cur=1;\n        set<int>::iterator it,bef;\n        for(int i=0;i<p.size();i++)\n        {\n            while(left<p[i].first)\n                val.insert(x[left++]);\n            for(it=val.begin();it!=val.end()&&cur<=p[i].second;)\n            {\n                x[cur++]=*it;\n                int s=*it;\n                it++;\n                val.erase(s);\n            }\n        }\n        for(int i=1;i<=n-1;i++)\n            printf(\"%d \",x[i]);\n        printf(\"%d\\n\",x[n]);\n    }\n    return 0;\n}\n```\n\n1007 [ Chiaki Sequence Revisited](http://acm.hdu.edu.cn/showproblem.php?pid=6304)  数学题。\n\n```c++\n#include <bits/stdc++.h>\n#define mst(a,b) memset(a,b,sizeof(a))\n#define ALL(x) x.begin(),x.end()\n#define pii pair<int,int>\n#define eps 1e-4\ninline long long lowbit(long long x){return x&-x;}\nconst int N = 1e6+10;\nconst long long mod = (long long)1e9+7;\nconst int INF=0x3f3f3f3f;\nconst long long LINF=(1LL<<62);\ntypedef long long LL;\ntypedef unsigned long long ULL;\n//#define LOCAL\nconst double PI = acos(-1.0);\nusing namespace std;\n\nLL n,inv2,p[63];\n\nLL q_pow(LL base, LL b){\n  LL res = 1;\n  while(b){\n    if(b&1) res = res*base%mod;\n    base = base*base%mod;\n    b>>=1;\n  }\n  return res;\n}\nbool check(LL x){   //为什么要这么写呢，看上面打的表，除以每个2^i就可以得出2^i有多少个，这样子加完就得到对应的a[x]是多少。\n  LL temp = 0;\n  for(int i = 0; i <= 62; i++){\n    temp += x/p[i];\n    if(temp >= n-1) return true;\n  }\n  return temp >= n-1;\n}\nLL cal(LL x){\n  LL temp = 0;\n  for(int i = 0; i <= 62; i++) temp += x/p[i];\n  return temp;\n}\nint main(){\n#ifdef LOCAL\n    freopen(\"out.txt\", \"w\", stdout);\n#endif // LOCAL\n    inv2 = q_pow(2,mod-2);  //2的逆元，等下等差数列求和的时候要用\n    p[0] = 1;\n    for(int i = 1; i <= 62; i++) p[i] = p[i-1]*2; //预处理2^i\n    int T; scanf(\"%d\",&T);\n    while(T--){\n      scanf(\"%lld\",&n);\n      if(n==1){\n        printf(\"1\\n\");\n        continue;\n      }\n      LL l = max(1LL,n/2-30), r = min(n,n/2+30), mid, pos;\n      while(l<=r){\n        mid = (l+r)>>1;\n        if(check(mid)){   //二分找n对应的a[n]；\n          pos = mid;      //pos即为a[n]\n          r = mid-1;\n        }else l = mid+1;\n      }\n      LL res = pos-1, now = 0;  //这里pos-1是因为在a[n]位置的n可能不是刚好符合2^i，所以要找前面一个，前面一个必定是符合2^i个的。\n      for(int i = 0; i <= 62; i++){\n        if(p[i]>res) break;\n        LL temp = res/p[i];\n        temp %= mod;\n        now = (now+p[i]%mod*(temp+1)%mod*temp%mod*inv2%mod)%mod;  //等差数列求和，不要忘记Mod\n      }\n      now = (now+(n-1-cal(res)%mod)%mod*pos%mod)%mod;  //剩下这里就是那些不完整的a[n]了\n      printf(\"%lld\\n\",(1+now)%mod);\n    }\n    return 0;\n}\n```\n\n1011 [ Time Zone](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1011&cid=802)  水。\n\n\n\n<h2>7.25  [ 多校2](http://acm.hdu.edu.cn/contests/contest_show.php?cid=803)</h2>\n\n\n\n1003 [Cover](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=803)  没看题，听了题解，大概是给你一个无向图，让你求至少要多少一笔画才能把它画完。一笔画有两种情况，一种是欧拉路，一种是欧拉回路，也就是说，对于图中的所有点，度数为奇数的要么是0（回路），要么是2（一个进来的点，一个出去的点）。所以要把一个图构造成欧拉路/回路的话，就意味着要在图中x个奇数度的点中连接x/2条边，然后在对于新生成的图，找欧拉路，然后再把添上去的x/2条边删去，分成的几条路就是一笔画的结果。\n\n1004 [ Game](http://acm.hdu.edu.cn/showproblem.php?pid=6312)  水题，先手必赢。先手可以取或者不取1。\n\n1005 [ Hack It](http://acm.hdu.edu.cn/showproblem.php?pid=6313)  不知所措的构造题。要求是构造出一个n*n(n<=2000)的矩阵，你可以在里面填黑点，但是你不能让任意四个黑点组成一个矩形（四个角），要求是至少包含85000个黑点。老实说，我无法理解构造方法。\n\n1007 [Naive Operations](http://acm.hdu.edu.cn/showproblem.php?pid=6315) 线段树 [题解](http://xheartbeat.top/2018/07/29/HDU%206315%20Naive%20Operations/)\n\n1010[ Swaps and Inversions](http://acm.hdu.edu.cn/showproblem.php?pid=6318)  水题。数逆序数对，再乘以min(x,y)即可。这里我发现逆序数对数有x个，就可以通过交换相邻数字x次使得它不存在逆序数。\n\n用归并排序可以得到逆序数对个数。\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nlong long sum;\nint a[500005];\nint temp[500005];\nvoid sort2(int a[],int l,int mid,int r)\n{\n    int i=l,j=mid+1,k=0;\n    while(i<=mid&&j<=r)\n    {\n        if(a[i]<=a[j])\n        {\n            temp[k++]=a[i++];\n        }\n        else\n        {\n            temp[k++]=a[j++];\n            sum+=mid-i+1;\n        }\n    }\n    while(i<=mid)  temp[k++]=a[i++];\n    while(j<=r)    temp[k++]=a[j++];\n\n    for(int i=l,k=0; i<=r; k++,i++)\n        a[i]=temp[k];\n}\n\nvoid sort1(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)/2;\n        sort1(a,l,mid);\n        sort1(a,mid+1,r);\n        sort2(a,l,mid,r);\n    }\n}\nint main()\n{\n    int n;\n    long long x,y;\n    while(scanf(\"%d%lld%lld\",&n,&x,&y)!=EOF)\n    {\n        sum=0;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort1(a,0,n-1);\n        printf(\"%lld\\n\",sum*min(x,y));\n    }\n    return 0;\n}\n```\n\n\n\n<h2>7.24 [ The 2018 ACM-ICPC China JiangSu Prov..](https://www.jisuanke.com/contest/1408)</h2>\n\n\n\nA. [Plague Inc](https://nanti.jisuanke.com/t/28865) 水题暴力，遍历每个点到感染源的路求最远。\n\nB. [Array](https://nanti.jisuanke.com/t/28866)  n个数，k对逆序数，求可能的方案数。这是一道DP 。\n\nD.  [Persona5](https://nanti.jisuanke.com/t/28868) 公式题\n\nE.  [Massage](https://nanti.jisuanke.com/t/28869) 公式结论题\n\nI. [T-shirt](https://nanti.jisuanke.com/t/28873)  ////////////////////////////////////\n\nJ.  [Set](https://nanti.jisuanke.com/t/28874) 结论是(n+1)!-1，用java写\n\nK.  [Road](https://nanti.jisuanke.com/t/28875) 连通图，删去尽可能多的路，使得每个城市到第0号城市的最短路长度不变，求可能的方案数量。\n\n用floyd先求出每个城市之间的最短路，然后对每条0~i城市的最短路，判断0~j城市的距离加上i到j的原始距离是否还和最短路相等，相等的话，在j城市上的最短路径+1。最后将他们乘起来。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=350;\nconst long long MOD=1e9+7;\nint dist[maxn],g[maxn][maxn],f[maxn][maxn],N;\nlong long road[maxn];\nlong long floyd()\n{\n    long long ans=1;\n    memset(road,0,sizeof(road));\n\n    for (int k=0;k<N;k++)\n        for (int i=0;i<N;i++)\n            for (int j=0;j<N;j++)\n                if (i!=k&&i!=j&&j!=k)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    g[0][0]=0;\n    for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n        if(i!=j&&g[0][i]+f[i][j]==g[0][j])\n    {\n        road[j]++;\n    }\n    for(int i=1;i<N;i++)\n        if(road[i])\n            ans=(ans*road[i])%MOD;\n    return ans;\n\nint main()\n{\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        memset(g,INF,sizeof(g));\n        string s;\n        for(int i=0;i<N;i++)\n        {\n            cin>>s;\n            for(int j=0;j<s.size();j++)\n            {\n                if(s[j]=='0')\n                    f[i][j]=g[i][j]=INF;\n                else\n                \tf[i][j]=g[i][j]=s[j]-'0';\n            }\n        }\n        printf(\"%lld\\n\",floyd());\n    }\n    return 0;\n}\n\n```\n\n<h2>7.26 [ Nordic Collegiate Programming Contes...](https://www.jisuanke.com/contest/1410)</h2>\n\n\n\nA. [Adjoin the Networks](https://nanti.jisuanke.com/t/28876)  回头补把。\n\nB. [Bell Ringing](https://nanti.jisuanke.com/t/28877)  用生成全排列的邻位互换法：（具体方法解释可以看排列组合的文章）\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1; 1\n\nn=2; 12 , 21\n\nn=3; 123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint A[15];\nint dir[15];\n\nvoid print()\n{\n    for(int i=1;i<n;i++)\n        printf(\"%d \",A[i]);\n    printf(\"%d\\n\",A[n]);\n}\nbool IF_Active(int i) //判断是否活跃（前面的数字比它小就是活跃）\n{\n    if(i+dir[i]<=0||i+dir[i]>n)\n        return false;\n    if(A[i+dir[i]]<A[i])\n        return true;\n    return false;\n}\n\nint MAX_Active() //找到最大的活跃数字\n{\n    int id=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(IF_Active(i)&&A[id]<A[i])\n            id=i;\n    }\n    return id;\n}\nint Swap(int i) //交换最大的活跃数字和它前面的那个数字，注意方向也要交换\n{\n    int c=A[i];\n    A[i]=A[i+dir[i]];\n    A[i+dir[i]]=c;\n\n    c=dir[i];\n    dir[i]=dir[i+c];\n    dir[i+c]=c;\n\n    return i+c;\n}\nvoid UPdate(int index)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(A[index]<A[i])\n            dir[i]=-dir[i];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        A[i]=i;\n        dir[i]=-1;\n    }\n    print();\n    \n    while(1)\n    {\n        int id=MAX_Active();\n        if(id==n+1) break;\n        id=Swap(id);\n        UPdate(id);\n        print();\n    }\n    return 0;\n}\n```\n\nC. [Cryptographer's Conundrum](https://nanti.jisuanke.com/t/28878) 水\n\nD. [Disastrous Downtime](https://nanti.jisuanke.com/t/28879) 水，取最大的ai~ai+1000范围内的数字个数即可。\n\nE.[Entertainment Box](https://nanti.jisuanke.com/t/28880)  n个节目，k个录像带，给出每个节目的播放时间，求最多能录几个节目。\n\n用multiset维护当前正在录制的所有节目的结束时间，二分找到最接近下一个要录的节目的起始时间且小于起始时间的录像带，把这个录像带中的r替换成下一个要录的节目，cnt++，如果没有找到并且集合的size还不到k个的话，就直接把r放进去，cnt++。最后输出cnt。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstruct node\n{\n    int l,r;\n} nn[N];\nbool cmp(node a,node b)\n{\n    if(a.r==b.r)\n        return a.l<b.l;\n    return a.r<b.r;\n}\n\nmultiset<int>q;\nmultiset<int>::iterator pos;\nint main()\n{\n    int n,k;\n    int cnt=0;\n    int i;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d\",&nn[i].l,&nn[i].r);\n    sort(nn,nn+n,cmp);\n    for(i=0; i<n; i++)\n    {\n        if(q.empty())\n        {\n            cnt++;q.insert(nn[i].r);\n            continue;\n        }\n        if(*q.begin()>nn[i].l)\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n            continue;\n        }\n        pos=q.upper_bound(nn[i].l);\n        pos--;\n        if(*pos<=nn[i].l)\n        {\n            cnt++;\n            q.erase(pos);\n            q.insert(nn[i].r);\n        }\n        else\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    return 0;\n}\n```\n\nG.[Goblin Garden Guards](https://nanti.jisuanke.com/t/28882)  给n个哥布林的位置（x，y），给出m个圆，对于每一个圆，输出最大的不在圆内的哥布林数目。\n\n由于哥布林的位置是整数，那么对于圆，可以预处理出距离圆心0~r范围内的x最大偏差值和y的最大偏差值，如果哥布林的x，y与圆心的偏差值有一者在最大偏差值之外，就cnt++。\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nstruct point\n{\n    int x,y;\n}p[100010];\nbool cmp(point a,point b)\n{\n    return a.y<b.y;\n}\nvector<int>v[100010];\nvector<int>d[110];\nvoid init()\n{\n    for(int r=1;r<=100;r++)\n        for(int i=0;i<=r;i++)\n            d[r].push_back((int)floor(sqrt(1.0*r*r-i*i)));\n}\nint main()\n{\n    init();\n    int g,m,x,y,r;\n    scanf(\"%d\",&g);\n    for(int i=0;i<g;i++)\n        scanf(\"%d%d\",&p[i].x,&p[i].y);\n    sort(p,p+g,cmp);\n    for(int i=0;i<g;i++)\n        v[p[i].x].push_back(p[i].y);\n    scanf(\"%d\",&m);\n    int ans=0;\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&r);\n        int left=max(0,x-r),right=min(10000,x+r);\n        for(int dd=left;dd<=right;dd++)//横坐标\n        {       \n            int c=abs(dd-x);\n            int yl=max(0,y-d[r][c]),yr=min(10000,y+d[r][c]);\n            int pos1=lower_bound(v[dd].begin(),v[dd].end(),yl)-v[dd].begin();\n            int pos2=upper_bound(v[dd].begin(),v[dd].end(),yr)-v[dd].begin();\n            v[dd].erase(v[dd].begin()+pos1,v[dd].begin()+pos2);\n            ans+=pos2-pos1;\n        }\n    }\n    printf(\"%d\\n\",g-ans);\n    return 0;\n}\n```\n\n<h2>7.28 teemo场</h2>\n\n\n\nA. [Teemo's bad day](https://nanti.jisuanke.com/t/29203)  裸的并查集，判断两个数字的根是否一样，不一样就cnt++，顺便union即可。（好久没写并查集find都写炸）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[500010],b[500010];\nint fa[100010];\nint Find(int x)\n{\n    if(fa[x]==x)return x;\n    return fa[x]=Find(fa[x]);\n}\nvoid Union(int p,int q)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n        fa[rp]=rq;\n}\nvoid init(int n)\n{\n    for(int i=0;i<100010;i++)\n        fa[i]=i;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,cnt=0;\n        scanf(\"%d\",&n);\n        init(n);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d\",&b[i]);\n            if(a[i]==b[i]) continue;\n            if(Find(a[i])!=Find(b[i]))\n            {\n                cnt++;Union(a[i],b[i]);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n```\n\nB. [Teemo's hard problem](https://nanti.jisuanke.com/t/29204) 题目意思是给你一个数列，你可以任意反转[L,R]，使得这个数列的非递减序列最长。\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint a[2010];\nint pre[2010];//1的前缀长度（包括自己）\nint suf[2010];//2的后缀长度（包括自己）\nint dp[2005][2005][4];//[i,j]中以k结尾的最长非递增序列长度\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        memset(pre,0,sizeof(pre));\n        memset(suf,0,sizeof(suf));\n        memset(dp,0,sizeof(dp));\n        for(int i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&a[i]);\n            if(a[i]==1)pre[i]=pre[i-1]+1;\n            else pre[i]=pre[i-1];\n        }\n        for(int i=n; i>=1; i--)\n        {\n            if(a[i]==2)suf[i]=suf[i+1]+1;\n            else suf[i]=suf[i+1];\n        }\n        for(int i=1; i<=n; i++)\n        {\n            dp[i][i][a[i]]=1;\n            for(int j=i+1; j<=n; j++)\n            {\n                if(a[j]==1)\n                {\n                    dp[i][j][1]=max(dp[i][j-1][1],dp[i][j-1][2])+1;\n                    dp[i][j][2]=dp[i][j-1][2];\n                }\n                else if(a[j]==2)\n                {\n                    dp[i][j][1]=dp[i][j-1][1];\n                    dp[i][j][2]=dp[i][j-1][2]+1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1; i<=n; i++)\n            for(int j=i; j<=n; j++)\n            {\n                ans=max(ans,pre[i-1]+max(dp[i][j][1],dp[i][j][2])+suf[j+1]);\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nC. [Teemo's tree problem](https://nanti.jisuanke.com/t/29228) 又是一个dp \n\nF. [Teemo's dream](https://nanti.jisuanke.com/t/29245)  没看题\n\nG .[Teemo's convex polygon](https://nanti.jisuanke.com/t/29294)  将多边形对角线相连，其对角线最多被分割成多少段？\n$$\nmax=(n^4-6*n^3+17*n^2-24*n)/12\n$$\nJ. [Teemo's formula](https://nanti.jisuanke.com/t/29324) 结论是$Σ_{k=1}^nk^2C_n^k=2^{n-2}n(n+1)$\n\nK.[Teemo's reunited](https://nanti.jisuanke.com/t/29326) 求的是其他所有的点到某一点的距离和的最小值，就是曼哈顿距离。[HDU 4311Meeting point-1](http://acm.hdu.edu.cn/showproblem.php?pid=4311) \n\n> 这题也是用“分治”，虽说题目要求的是曼哈顿距离，但是我们为什么真的就要一步到位的求呢，可以横纵坐标分开求，先x排序，然后遍历一遍，求出横坐标的距离，然后y排序，遍历一遍求出坐标的距离加在刚才求得的x的距离上，就是曼哈顿距离了。\n>\n> 这里有一个非常巧妙但是其实很显而易见的东西：假定现在我们已经按x排好序了分别是ABC三个点，那么C到AB的距离和是|C-A|+|C-B|，又因为已经排序了，那么绝对值可以去掉，得(C-A)+(C-B)，那么就是2*C-(A+B)，也就是说一个点到它前面的点的距离的和等于它前面的点的个数乘以它的自己再减去前面所有点的和，到这里你是不是想到求一个数列的和的时候我们遍历一遍数列就得到了，通过这个方法我们用O(n)就得到了一个点到它前面的点的距离和，然后再倒着遍历一遍数列用相似的思想把它到它后面的点的距离再加上就行了。\n>\n> 还有一种也是分开x,y排序求和，不过可以这么做：先直接求出最前面的点到所有点的距离，然后依次遍历数列，通过后面一个点跟前面一个点的关系，找出差值相减，就是了。不明白的话仔细想想或者画图看看。\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1000000000000007\nusing namespace std;\nstruct node{\n\tlong long x,y;\n\tlong long sum;\n}a[100005];\nbool cmp1(node a,node b)\n{\n\treturn a.x<b.x;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.y<b.y;\n}\nint main(){\n\tint t,n;\n\tscanf(\"%d\",&n);\n\tlong long ans=INF;\n\tmemset(a,0,sizeof(0));\n\tfor(int i=0;i<n;i++)  \n        scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tsort(a,a+n,cmp1);\n\tlong long sum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum=i*a[i].x-sum;\n\t\tsum+=a[i].x;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].x;\n\t\tsum+=a[i].x;\n\t}\n\tsort(a,a+n,cmp2);\n\tsum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum+=i*a[i].y-sum;\n\t\tsum+=a[i].y;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].y;\t\t\t\n\t\tsum+=a[i].y;\n\t\tans=min(ans,a[i].sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n<h2>7.29</h2>\n\n\n\nA.  [Coins](https://nanti.jisuanke.com/t/28960) 概率dp....不懂不懂\n\nB. [The Difference](https://nanti.jisuanke.com/t/28961) 水题\n\nD. [Fence Building](https://nanti.jisuanke.com/t/28963)  一个圆，一个圆的内接n边形，连接多边形对角线，求整个圆被分割成几块。\n\nOEIS大法好。。。\n\n```c++\n#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<time.h>\n#include<stdlib.h>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\n#define MAXN 10000000\nusing namespace std;\ntypedef long long ll;\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)   //a,b都为正整数\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    for(int cs=1;cs<=t;cs++)\n    {\n        scanf(\"%lld\",&n);\n        n%=MOD;\n        ll temp1=n,temp2=(temp1*n)%MOD,temp3=(temp2*n)%MOD,temp4=(temp3*n)%MOD;\n        temp1=(temp1*18ll)%MOD,temp2=(temp2*23ll)%MOD,temp3=(temp3*6ll)%MOD;\n        ll temp=inverse(24ll,MOD);\n        //printf(\"%lld %lld %lld %lld %lld\\n\",temp1,temp2,temp3,temp4,temp);\n        ll fz=(temp4-temp3+MOD)%MOD;\n        fz=(fz+temp2)%MOD;\n        fz=(fz-temp1+24+MOD)%MOD;\n        ll ans=(fz*temp)%MOD;\n        printf(\"Case #%d: %lld\\n\",cs,ans);\n    }\n    return 0;\n}\n```\n\nG.[The Mountain](https://nanti.jisuanke.com/t/28966)  水\n\nI. [A Possible Tree](https://nanti.jisuanke.com/t/28968) 给你一棵树，q个询问，问的是x->y路径上的异或和为val , 问你最多有几个询问是真的？\n\n带权并查集。由于异或的特点，假设某个点为根，比如0，那么比如2->5的异或值，就是2->1的异或值和5->1的异或值异或一下。所以我们用yihuo[i]来表示i到源点的异或和。如果两个数的源点已经一样，那么判断一下val==yihuo[i]^yihuo[j]即可，若是不一样，就把他们union，同时yihuo[rootp]=yihuo[p]^yihuo[q]^val。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint fa[100010],yihuo[100010];\nint Find(int x)\n{\n    if(x!=fa[x])\n    {\n        int tmp=fa[x];\n        fa[x]=Find(fa[x]);\n        yihuo[x]^=yihuo[tmp];\n        return fa[x];\n    }\n    return x;\n}\n\nbool Union(int p,int q,int val)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n    {\n        fa[rp]=rq;\n        yihuo[rp]=yihuo[p]^yihuo[q]^val;\n        return true;\n    }\n    if((yihuo[p]^yihuo[q])!=val)\n        return false;\n    return true;\n}\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        fa[i]=i;yihuo[i]=0;\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,k,u,v,val;\n        scanf(\"%d%d\",&n,&k);\n        init(n);\n        for(int i=0;i<n-1;i++)\n            scanf(\"%d%d\",&u,&v);\n        int flag=1,ans=0;\n        for(int i=0;i<k;i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&val);\n            if(!Union(u,v,val)&&flag)\n            {\n                flag=0;\n                ans=i;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nK.   [Sum of the Line](https://nanti.jisuanke.com/t/28970) 给你一个n，分析之后发现求的是所有gcd(n,i)=1（i<=n）的数的平方和。\n\n用容斥，先用公式$\\frac{n(n+1)(2n+1)}{6}$求出1~n的平方和，然后筛出sqrt(n)内的素数，并求出n的所有质因数，然后对于质因数的乘积tot，如果质因数的个数是奇数，就加上$tot^2*(1^2+2^2+3^2……+(n/tot)^2)$，是偶数就减去。\n\n或者用莫比乌斯反演来做\n\n（补莫比乌斯反演做法）\n\n```c++\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 998244353\n#define MAXN 10000\nusing namespace std;\ntypedef long long ll;\nll pri[10010],num=0;\nbool vis[10010];\nvector<ll>pr;\nvoid init()\n{\n    ll i,j;\n    for(i=2;i<MAXN;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAXN&&i%pri[j]!=0;j++)\n            vis[i*pri[j]]=true;\n    }\n}\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    init();\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        pr.clear();\n        ll xs=inverse(6ll,MOD);\n        ll tot=(((n*(n+1))%MOD*(2*n+1))%MOD*xs)%MOD;\n        ll temp=n;\n        for(int i=0;i<num;i++)\n        {\n            if(temp%pri[i]==0)\n            {\n                pr.push_back(pri[i]);\n                while(temp%pri[i]==0)\n                    temp/=pri[i];\n            }\n        }\n        if(temp>1)pr.push_back(temp);\n        int len=pr.size();\n        ll ans=0;\n        for(int i=1;i<(1<<len);i++)\n        {\n            int cnt=0;//有几个1\n            ll d=1;\n            for(int j=0;j<len;j++)\n            {\n                int temp=i>>j&1;\n                if(temp==1)\n                {\n                    cnt++;d=d*pr[j];\n                }\n            }\n            ll gs=n/d;\n            ll g=(((gs*(gs+1))%MOD*(2*gs+1))%MOD*xs)%MOD;\n            if(cnt%2==0)ans=(ans-((d*d)%MOD*g)%MOD+MOD)%MOD;\n            else ans=(ans+((d*d)%MOD*g))%MOD;\n            }\n        }\n        printf(\"%lld\\n\",(tot-ans+MOD)%MOD);\n    }\n    return 0;\n}\n```\n\n<h2>7.30 多校三</h2>\n\n\n\nA. [  Problem A. Ascending Rating](http://acm.hdu.edu.cn/showproblem.php?pid=6319) 输入n,m,k,p,q,r,MOD,表示一个长度为n的数列，给你前k个数字，（后面的要根据递推式自己写），然后m表示一个[l,l+m]的区间，从l=1开始，在这个区间中有两个值，一个是MAX，一个是CNT，起始都为0，从区间的第一个数开始扫，如果扫到的数字比MAX大，让MAX=ai，并且CNT++。求的是$A =\\sum_{i=1}^{n-m+1}{MAX_i 异或i}$ , $B=\\sum_{i=1}^{n-m+1}{CNT_i 异或i}$\n\n思路是用一个单调队列从最后一个区间往前倒着维护，如果队列为空，则直接放入ai，若ai>=队首元素，则将队列中的元素全部弹出，同时将ai放入，若ai小于队首元素，则将队尾中小于ai的元素弹出，将ai放入队尾中，每一个区间的cnt值即为队列中元素的个数，而MAX值则为队首元素。如果队首元素的位置不在下一个区间范围内，则弹出。注意STL的双端队列会被卡，这里可以用数组直接模拟。（可以补一个正向写的，但是我WA到死，主要就是用单调栈来维护每一个数字右边的第一个比他大的位置，最后一个栈里的数的stack设为n+1，然后从右到左，dp[n-1]=1，dp[i]=dp[stack[i]]+1，………然后单调队列维护区间最大值）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nlong long a[10000010];\nlong long que[20000010];\nint main()\n{\n    int t,n,m,k,p,q,r,MOD;\n    int size,front,rear;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        size=0;\n        front=rear=1e7+5;\n        scanf(\"%d%d%d%d%d%d%d\",&n,&m,&k,&p,&q,&r,&MOD);\n        for(int i=1;i<=k;i++)\n            scanf(\"%lld\",&a[i]);\n        for(int i=k+1;i<=n;i++)\n            a[i]=(1LL*p*a[i-1]+1LL*q*i+r)%MOD;\n        long long MAX=0,CNT=0;\n        for(int i=n;i>=1;i--)\n        {\n            if(size==0)\n            {\n                que[front]=i;size=1;\n            }\n            else\n            {\n                if(a[que[front]]<=a[i])\n                {\n                    front=rear=1e7+5;\n                    que[front]=i;\n                    size=1;\n                }\n                else\n                {\n                    while(size>0&&a[que[rear]]<=a[i])\n                        size--,rear--;\n                    que[rear+1]=i;rear++;\n                    size++;\n                }\n            }\n            if(i<=n-m+1)\n            {\n                MAX+=a[que[front]]^i;\n                CNT+=size^i;\n                while(que[front]>=(i+m-1))\n                    front++,size--;\n            }\n        }\n        printf(\"%lld %lld\\n\",MAX,CNT);\n    }\n    return 0;\n}\n```\n\nC. [ Problem C. Dynamic Graph Matching](http://acm.hdu.edu.cn/showproblem.php?pid=6321)  在一个图中，任意k条不共点的边可以构成一个匹配。给你n个点，有q个操作，操作分两种，一种是+ u v，在u v中间连线，一个是- u v，删边，两点之间可以连多条路线。问你对于每一次操作，k=1,2，…… n/2的匹配方案分别有多少？\n\n思路：树状DP。（补）\n\nD. [Problem D. Euler Function](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=804)  水。求φ(n)为合数的第k个数。根据规律可看到，从第7个开始就都是偶数。\n\nF. [ Problem F. Grab The Tree](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1006&cid=804) 水。很容易看出sum=0时平手，否则就是先手赢。\n\nL. [ Problem L. Visual Cube](http://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1012&cid=804)  水。直接写。\n\n## 7.31 [ACM-ICPC 2015 Shenyang Preliminary C...](https://www.jisuanke.com/contest/1466)\n\n\n\nB.  [Best Solver](https://nanti.jisuanke.com/t/29121)  （补）\n\n\n\nC. [Minimum Cut](https://nanti.jisuanke.com/t/29122)  （补）\n\nF.  [Fang Fang](https://nanti.jisuanke.com/t/29125)  水。\n\nJ.  [Jesus Is Here](https://nanti.jisuanke.com/t/29129) 有、搞的题。把递推关系算出来……表示不想再写一编代码，就那个意思反正。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 530600414\ntypedef long long ll;\nll sum[210000];\nll num[210000];\nll pre[210000],suf[210000],ans[210000];\nvoid init()\n{\n    sum[1]=5;sum[2]=8;num[1]=1;num[2]=2;\n    for(int i=3;i<=201314;i++)\n    {\n        sum[i]=(sum[i-1]+sum[i-2])%MOD;\n        num[i]=(num[i-1]+num[i-2]+1)%MOD;\n        if(i%2==1)sum[i]=(sum[i]+5)%MOD;\n        else sum[i]=(sum[i]+3)%MOD;\n    }\n    pre[1]=5;pre[2]=11;suf[1]=5;suf[2]=13;\n    for(int i=3;i<=201314;i++)\n    {\n        ll x;\n        if(i%2==1)x=5;else x=3;\n        pre[i]=((((num[i-1]+1)*(sum[i-2]+x))%MOD+pre[i-2])%MOD+pre[i-1])%MOD;\n        suf[i]=((((num[i-2]+1)*(sum[i-1]+x))%MOD+suf[i-2])%MOD+suf[i-1])%MOD;\n    }\n    ans[1]=5;ans[2]=16;\n    for(int i=3;i<=201314;i++)\n    {\n        ll x;\n        if(i%2==1)x=5;else x=3;\n        ll temp1=((num[i-1]+1)*suf[i-2])%MOD;\n        ll temp2=((num[i-2]+1)*pre[i-1])%MOD;\n        ll temp3=(((num[i-1]+1)*(num[i-2]+1))%MOD*x)%MOD;\n        ans[i]=((((temp1+temp2)%MOD+temp3)%MOD+ans[i-2])%MOD+ans[i-1])%MOD;\n    }\n}\nint main()\n{\n    init();\n    int t,n;\n    scanf(\"%d\",&t);\n    for(int kase=1;kase<=t;kase++)\n    {\n        scanf(\"%d\",&n);\n        if(n<5)printf(\"0\\n\");\n        else\n        {\n            n-=4;\n            printf(\"Case #%d: %lld\\n\",kase,ans[n]);\n        }\n    }\n    return 0;\n}\n```\n\nM.  [Largest Point](https://nanti.jisuanke.com/t/29131)  写的我脑子有点不清楚了……\n\n<h2>8.1多校4</h2>\n\n\n\nB. [Harvest of Apples](http://acm.hdu.edu.cn/showproblem.php?pid=6333)  题意是从n个苹果里面选取最多m个苹果的方案数量。m、n、t<=1e5\n\n思路：莫队分块+组合预处理，原来莫队中的区间[l,r]在这里用n、m代替了。\n\n接下来是推公式部分：\n\nS(n,m)表示$\\sum_{i=1}^n\\sum_{j=1}^mC_i^j$\n\n我们可以得出$S(n,m)=S(n,m-1)+C_n^m$ ,-------①\n\n又因为有$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$（组合数学的一个基本公式），因此又可以推出：$S(n,m)=S(n-1,m)+S(n-1,m-1)=2S(n-1,m)-C_{n-1}^m$--------②\n\n有了①②两个式子，我们就可以得到S(n,m)和S(n-1,m)、S(n+1,m)、S(n,m-1)、S(n,m+1)之间的关系，先预处理出n！和相应的需要的逆元，然后把输入的查询分块，按照代码中所示的“套路”排序法，排一排，然后对于每个n，m开始处理，分四种情况这样。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nll multi[N];\nll devide[N];\nll ans[N];\nll pos[N];\nll er;\nint D=(int)sqrt(1.0*N);\nstruct node{\n    int n,m;\n    int id;\n    bool operator <(const node& p) const{\n        if(pos[n]==pos[p.n]) return m<p.m;\n        return n<p.n;                           //N大的排前面\n    }\n};\nnode qujian[N];\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll n)//乘法逆元,n取模\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\nvoid init(int n)\n{\n    multi[0]=1;\n    multi[1]=1;\n    for(int i=2;i<=n;i++)\n        multi[i]=multi[i-1]*i%MOD;\n    devide[n]=mod_inverse(multi[n],MOD);\n    for(int i=n-1;i>=0;i--)\n        devide[i]=devide[i+1]*(i+1)%MOD;\n}\nll cal(int n,int m)\n{\n    return ((multi[n]*devide[m])%MOD*devide[n-m])%MOD;\n}\nvoid operation1(int n,int m,ll &res)\n{\n    res=((2ll*res)%MOD-cal(n,m)%MOD+MOD)%MOD;\n}\nvoid operation2(int n,int m,ll &res)\n{\n    res=(res+cal(n-1,m))%MOD*er%MOD;\n}\nvoid operation3(int n,int m,ll &res)\n{\n    res=(res+cal(n,m+1))%MOD;\n}\nvoid operation4(int n,int m,ll &res)\n{\n    res=(res-cal(n,m)+MOD)%MOD;\n}\nint main()\n{\n    init(100000);\n    int t;\n    int n,m;\n    er=mod_inverse(2ll,MOD);\n    scanf(\"%d\",&t);\n    for(int i=1;i<=t;i++)\n    {\n        scanf(\"%d%d\",&qujian[i].n,&qujian[i].m);\n        qujian[i].id=i;\n        pos[i]=i/D;\n    }\n    sort(qujian+1,qujian+t+1);\n    int curl,curr;\n    curl=curr=1;\n    ll res=2;\n    for(int j=1;j<=t;j++)\n    {\n        while(curl<qujian[j].n) operation1(curl++,curr,res);\n        while(curr<qujian[j].m) operation3(curl,curr++,res);\n        while(curl>qujian[j].n) operation2(curl--,curr,res);\n        while(curr>qujian[j].m) operation4(curl,curr--,res);\n        ans[qujian[j].id]=res;\n    }\n    for(int i=1;i<=t;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\nD. [Nothing is Impossible](http://acm.hdu.edu.cn/showproblem.php?pid=6335) 水，按占比来算就好。\n\nE. [Matrix from Arrays](http://acm.hdu.edu.cn/showproblem.php?pid=6336)  讲一下思想吧，再写一边代码的话可能又要写一万年。对于这个块的计算，比如这个块的四个角顺时针分别叫：a,b,c,d，将(0,0)点到(i,j)点的里面所有的数字和叫做pre，那么就是pre[b]-pre[b]-pre[d]+pre[a]。分析一下就可以得到，对于所有的无限大的矩阵，他都是重复某个特定的矩阵来的。这些矩阵有以下长度规律：（L为给定数组的长度，L从1~10，）\n\nlen[1]=1,len[2]=4,len[3]=3,len[4]=8,len[5]=10,len[6]=12,len[7]=14,len[8]=16,len[9]=18,len[10]=20。\n\n矩阵为n*n。\n\n故对于给定的L和数组可以先处理出重复矩阵的样子，然后再进行分块和的计算。\n\n关于分块和的计算（pre），把块内完整的小矩阵的个数算出来求个和，除了完整的还有不完整的，不完整的其实也好看，就是矩阵最左边和最上面的部分，也用pre算出来就行。\n\nJ. [Let Sudoku Rotate](http://acm.hdu.edu.cn/showproblem.php?pid=6341)  数独，有一个16*16的数独 数独内的数字从0~E，一开始数独是完美的，可是有个人逆时针旋转了数独中的某几块（4x4），导致数独不完美了，给你这个旋转后的数独，要求还原他至少要再旋转几步？\n\ndfs+剪枝。\n\n写出下列几个操作：\n\n1. 顺时针旋转4*4的方块；\n2. 判断每行的总和是否都为120；\n3. 判断每行和每列的元素是否都不重复；\n4. dfs，由于一行块有4个分块，因此四重循环，同一个x分别对应y的起始：0，4，8，12，循环+1表示旋转次数+1，如果在2、3的判断中都满足这写要求，说明可以进行下一个x+4（起始行）块的旋转操作dfs，step+本次旋转的操作（i，j，k，l四重循环），要是不满足还是要继续。当x==16或者是step比当前已知的最小ans要大的时候都可以return。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst int INF = 0x3f3f3f3f;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nchar m[20][20];\nchar cop[4][4];\nint ans=64;\nvoid print()\n{\n    printf(\"\\n\");\n    for(int i=0;i<16;i++,printf(\"\\n\"))\n        for(int j=0;j<16;j++)\n            printf(\"%c\",m[i][j]);\n    printf(\"\\n\");\n}\nint rol(int x,int y)\n{\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            cop[i][j]=m[x+3-j][y+i];\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            m[i+x][j+y]=cop[i][j];\n}\nbool sum(int x)\n{\n    for(int j=x;j<x+4;j++)\n    {\n        int temp=0;\n        for(int i=0;i<16;i++)\n        {\n            temp=temp+((m[x][i]>='0'&&m[x][i]<='9')?(m[x][i]-'0'):(m[x][i]-'A'+10));\n        }\n        if(temp!=120) return false;\n    }\n    return true;\n}\nbool multi(int x)\n{\n    int vis[16]={0};\n    for(int j=x;j<x+4;j++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<16;i++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n\n    for(int i=0;i<16;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int j=0;j<=x+3;j++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n    return true;\n}\nvoid dfs(int x,int step)\n{\n    if(step>ans) return;\n    if(x==16)\n    {\n        ans=min(ans,step);return;\n    }\n    for(int i=0;i<4;i++,rol(x,0))\n    for(int j=0;j<4;j++,rol(x,4))\n    for(int k=0;k<4;k++,rol(x,8))\n    for(int l=0;l<4;l++,rol(x,12))\n    {\n        if(!(sum(x)&&multi(x))) continue;\n        dfs(x+4,step+i+j+k+l);\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        getchar();\n        for(int i=0;i<16;i++)\n            scanf(\"%s\",m[i]);\n        ans=64;\n        dfs(0,0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\nK. [Expression in Memories](http://acm.hdu.edu.cn/showproblem.php?pid=6342)  表达式中有一些是用？代替的，问你这个表达式能否符合正确的要求，能的话输出任意成立的表达式（不含？）。注意细节，一开始对“+0?”单独扫，？填运算符号。完了之后就按顺序扫，判断是否符合。（注意细节，容易wa）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        string a;\n        cin>>a;\n        int flag=1;\n        int len=a.size();\n        for(int i=2;i<len;i++)\n        {\n            if(a[i]=='?'&&a[i-1]=='0'&&(a[i-2]=='+'||a[i-2]=='*'))\n                a[i]='+';\n        }\n        for(int i=0;i<len&&flag;i++)\n        {\n            if(a[i]=='?') {a[i]='1';continue;}\n            if(a[i]=='+'||a[i]=='*')\n            {\n                if(i==len-1||i==0) flag=0;\n                else if(a[i+1]=='+'||a[i+1]=='*') flag=0;\n            }\n            else if(a[i]=='0')\n            {\n                if(i==0&&len>1&&(a[i+1]!='+'&&a[i+1]!='*'&&a[i+1]!='?')) {flag=0;continue;} \n                if((i-1)<0||a[i-1]=='+'||a[i-1]=='*') \n                    if(i+1<len)\n                    {\n                        if(a[i+1]=='?') a[i+1]='+'; \n                        else if(a[i+1]!='+'&&a[i+1]!='*') flag=0;\n                    }\n            }\n        }\n        if(!flag)\n            printf(\"IMPOSSIBLE\\n\");\n        else\n            cout<<a<<endl;\n    }\n    return 0;\n}\n```\n\nL. [ Graph Theory Homework](http://acm.hdu.edu.cn/showproblem.php?pid=6343) 水，得到结论：根号函数的性质：$\\sqrt{a+b+c+…}\\le\\sqrt{a}+\\sqrt{b}+\\sqrt{c}+…$\n\n\n\n","categories":["算法"]},{"title":"Journey with Knapsack(令人自闭的母函数+五边形定理)","url":"/2018/08/11/Journey-with-Knapsack(令人自闭的母函数+五边形定理)/","content":"\n# [ Journey with Knapsack](http://acm.hdu.edu.cn/showproblem.php?pid=6042) \n\n## 题意\n\n有一个*容量*为2n的背包，n种食物，每种食物的体积为i，最多有$a_i$个，除了食物，还有m件装备，每件装备的体积是$b_i$，必须带一件装备，问2n的背包能够装下的所有情况种数？\n\n1<=n<=5e4 , 0<=ai<=2n , 1<=m<=2n，0<=bi<=2n。\n\n## 思路\n\n**背包全部装食物的方案数：**\n\n\n$$\n\\prod_{i=1}^n(1+x^i+x^{2i}+…+x^{a_ii})=\\prod_{i=1}^n\\frac{1-x^{i(a_i+1)}}{1-x^i}\n$$\n\n$$\n=\\prod_{i=1}^n(1-x^{i(a_i+1)}) \\prod_{i=1}^n(\\frac{1}{1-x^i})\n$$\n\n**对于左边的累乘进行分析：**\n\n1. 假设右边部分已经求得，是一个2n项（后面会求到）多项式：$\\sum_{i=1}^{2n}dp[i]*x^i$(dp[i]的i指的是体积，dp的值是种数)\n2. 那么原式子就变成，左边的n个两项式与右边的的2n项式相乘，有：\n\n$$\n(1-x^{i(a_i+1)})(\\sum_{j=1}^{2n}dp[j]x^j)\n$$\n\n$$\n=\\sum_{j=1}^{2n}dp[j]x^j-\\sum_{j=1}^{2n}dp[j]x^{i(a_i+1)+j}\n$$\n\n​\t我们将j向右移$i*(a_i+1)$位，则：\n\n$$\n=\\sum_{j=1}^{2n}dp[j]x^j-\\sum_{j=i(a_i+1)}^{2n+i(a_i+1)}dp[j-i(a_i+1)]x^j\n$$\n\n\n$$\n=\\sum_{j=1}^{i(a_i+1)}dp[j]x^j+\\sum_{j=i(a_i+1)}^{2n}(dp[j]-dp[j-i(a_i+1)])x^j\n$$\n\n \t（由于2n以后的项都没有意义，所以可以减少到2n）\n\n3. 由于前面的假设1，dp[j]已经求得，因此我们只要再求得对所有$i*(a_i+1)\\le{j}\\le2n$，再求：\n\n$$\ndp[j]=dp[j]-dp[j-i*(a_i+1)]\n$$\n\n**对于右边的累乘：**\n$$\n\\prod_{i=1}^n(\\frac{1}{1-x^i}) = \\prod_{i=1}^{2n}(\\frac{1}{1-x^i}) \\prod_{i=n+1}^{2n}({1-x^i})（不满2n所以补上）\n$$\n\n1. 对于左边的式子，根据五边形定理：\n\n$$\nQ(x)=\\sum_{i\\ge1}(1-x^i)=\\sum_{i\\ge1}(-1)^i(x^{\\frac{3i^2-i}{2}}+x^{\\frac{3i^2+i}{2}})=(1-x)(1-x^2)…=1-x-x^2+x^5+x^7+……\n$$\n\n​\t整数拆分的式子是这样的：\n$$\nP(x)=(1+x+x^2+…)（1+x^2+x^4+…）(1+x^3+x^6+…)\n$$\n\n$$\n=\\prod_{i\\ge1}(1+x^i+x^{2i}+…)=\\prod_{i\\ge1}\\frac{1}{1-x^i} （x<1无穷等比数列求级数）\n$$\n\n​\t因此我们可以看到：Q(x)P(x)=1，也就是说：\n$$\n(1-x-x^2+x^5+x^7+……)(1+p(1)x+p(2)x^2+p(3)x^3+…)=1\n$$\n​\t因此我们考虑，对于每项x^n前面的系数，必定有：\n$$\np(n)-p(n-1)-p(n-1)+p(n-5)+p(n-7)……=0\n$$\n​\t因此得递推式：\n$$\np(n)=p(n-1)+p(n-1)-p(n-5)-p(n-7)……\n$$\n​\t可以求出dp[i]=p[i]。（i<=2n）\n\n2. 对于右边的式子$\\prod_{i=n+1}^{2n}({1-x^i})$，由于累乘$x^a*x^b=x^{(a+b)}$，故对于a+b>2n的都可以舍去。\n\n   就化为了：\n\n$$\n1-\\sum_{i=n+1}^{2n}x^i\n$$\n\n3. 整个式子就变成：\n\n$$\nP(x)(1-\\sum_{i=n+1}^{2n}x^i),P(x)=\\sum_{i=1}^{2n}dp[i]x^i\n$$\n\n​\t\n$$\n=\\sum_{i=1}^{2n}dp[i]x^i -\\sum_{i=n+1}^{2n}dp[i-n-1]x^i-\\sum_{i=n+2}^{2n}dp[i-n-2]x^i-……\n$$\n\n$$\n=\\sum_{i=1}^{n}dp[i]x^i+x^{n+1}(dp[n+1]-dp[0])+x^{n+2}(dp[n+2]-dp[1]-dp[0])+……\n$$\n\n$$\n+x^{2n}(dp[2n]-dp[n-1]-dp[n-2]-…-dp[0])\n$$\n\n​\t也就是说对于所有dp[i]，i>=n+1,<=2n的，都进行减去sum[i-n-1] (前缀和)的操作。即：\n$$\ndp[i]=dp[i]-\\sum_{j=1}^{i-n-1}dp[j]\n$$\n​\t那么所有的部分就都算完啦！！！！！！\n\n啊啊啊啊啊啊啊啊啊啊啊啊啊\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL INF = 1e9+5;\nconst int MAXN = 100005;\nconst LL MOD = 1e9+7;\nusing namespace std;\nint n;\nlong long q[2005],f[MAXN];\nlong long dp[MAXN];\nvoid five()\n{\n    for(int i=1;i<=2000;i+=2)\n    {\n        LL temp=(i+1)/2;\n        q[i]=(3*temp*temp-temp)/2;\n        q[i+1]=(3*temp*temp+temp)/2;\n    }\n    f[0]=1;\n    for(int i=1;i<=MAXN;i++)\n    {\n        for(int j=1,c=1;j<=2000;j+=2,c*=-1)\n        {\n            if(i-q[j]<0) break;\n            f[i]=(f[i]+f[i-q[j]]*c+MOD)%MOD;\n            if(i-q[j+1]<0) break;\n            f[i]=(f[i]+f[i-q[j+1]]*c+MOD)%MOD;\n        }\n    }\n}\nint main()\n{\n    int n,m,cas=1;\n    LL a;\n    five();\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        for(int i=0;i<=(n<<1);i++) dp[i]=f[i];\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%lld\",&a);\n            LL b=(a+1)*i;\n            for(int j=n<<1;j>=b;j--) \n                dp[j]=(dp[j]-dp[j-b]+MOD)%MOD;\n        }\n        for(int i=n+1,sum=0;i<=(n<<1);i++)\n        {\n            sum=(sum+dp[i-n-1])%MOD;\n            dp[i]=(dp[i]-sum+MOD)%MOD;\n        }\n        long long ans=0;\n        while(m--)\n        {\n            scanf(\"%lld\",&a);\n            ans=(ans+dp[2*n-a])%MOD;\n        }\n        printf(\"Case #%d: %lld\\n\",cas++,ans);\n    }\n    return 0;\n}\n/** 来自大神的参考思想！！\nHDU 6042 - Journey with Knapsack [ 生成函数,五边形定理 ]  |  2017 Multi-University Training Contest 1\n题意:\n    n种物品，每种 a[i] 个，体积为 i，m 个武器，每个体积为 b[i]\n    求2*n大小的背包里只能装一个武器，任意食物的方案数\n    限制条件：\n        a[i]各不相同且 0 <= a[1] <= a[2] <= ... a[n] <= 2*n\n        n <= 5e4\n分析：\n    先不考虑武器，求出任意i <= 2*n 的放食物的方案数ans[2*n]，答案即为 ∑ ans[2*n - b[i]]\n    其实本质和整数划分相同，限制了每个数字选择的次数\n    考虑选择食物的生成函数：\n        第i种食物的贡献因子 f(x) = 1 + x^i + x^2i + ... + x^(a[i]*i) = ( 1 - x^((ai+1)*i) ) / ( 1 - x^i )\n    故   F(x) =  ∏ f(i) [1<=i<=n]\n             = ∏ (1 - x^((ai+1)*i)) / (1-x^i) [1<=i<=n]\n             = ∏ (1 - x^((ai+1)*i)) [1<=i<=n]  *  ∏ 1/(1-x^i) [1<=i<=n]\n ///////////////////////////////////////////////////////////\n    研究一下乘号左边这一项累乘：\n        假设已求得乘号右边这一项 F'(x) = ∏ 1/(1-x^i) [1<=i<=2*n] = ∑ dp[i]*x^i [1<=i<=2*n]\n        则两边多项式合并时，相当于一个n项的多项式（右边） 和 n个两项的多项式（左边）相乘\n        假设左边第i项 (1 - x^((ai+1)*i)) 与 F'(x) 合并，则：\n            (1 - x^((ai+1)*i)) * ( ∑ dp[j]*x^j [1<=j<=2*n] ) =\n             ∑ dp[j]*x^j [1<=j<=n] - ∑ dp[j-(ai+1)*i] * x^j [(ai+1)*i) <= j <= 2*n+(ai+1)*i)]\n              （多项式右移(ai+1)*i)次）\n        由于体积只有2*n大小，故x^(2*n+1)项及以后无意义\n            故上式 = ∑ dp[j]*x^j [1<=j<=n]  -  ∑ dp[j-(ai+1)*i] * x^j [(ai+1)*i) <= j <= 2*n]\n                   = ∑ dp[j]*x^j [1<=j< (ai+1)*i)]  +  ∑ (dp[j]- dp[j-(ai+1)*i])*x^j [(ai+1)*i) <= j <= 2*n]\n        即对于所有 (ai+1)*i <= j <= 2*n 的项，执行操作：\n            dp[j] = dp[j] - dp[j-a(i+1)*i] （按01背包形式，至高往低）\n\n        由于合并后 F'(x) 形式不变，故可循环合并 n 次\n        单次合并复杂度 O(2*n - a(i+1)*i) = O(n)\n        根据限制条件 0 <= a[1] <= a[2] <= ... a[n] <= 2*n ，可推得 ai >= i-1, (ai+1)*i >= i^2 （鸽巢原理）\n        故 (ai+1)*i <= 2*n 的项只有 O(n^0.5) 项\n        故合并总时间复杂度 O(n^1.5)\n //////////////////////////////////////////\n    研究一下乘号右边这一项累乘：\n        其形式与无限制的整数划分的方案数的生成函数相同，由于目前只有n项累乘，按题意先补齐至2n项\n        F'(x) = ∏ 1/(1-x^i) [1<=i<=n]\n              = ∏ 1/(1-x^i) [1<=i<=2n]  *  ∏ (1-x^i) [n+1<=i<=2n]\n\n        乘号左边这一项 P(x) 即2*n以内无限制的整数划分的方案数，根据五边形定理可以在 O(n^1.5) 预处理出\n\n        观察乘号右边那一项，虽然形式与上面讨论的累乘形式相近，但可以分析暴力合并复杂度 O(n^2)\n        打开这个累乘，由于 n+1<=i<=2n ，任意两项 x^i * x^j = x^(i+j) ，此时i+j > 2*n\n        故去掉指数为 2n 以上的无效项后：\n        ∏ (1-x^i) [n+1<=i<=2n]  =  1 - ∑x^i [n+1<=i<=2n]\n        F'(x) = P(x)  *  ( 1 - ∑x^i ) [n+1<=i<=2n]\n        令   P(x) = ∑ dp[i]*x^i [1<=i<=2n]，考虑合并：\n        F'(x) =   ∑ dp[i] * x^i [1<=i<=2n]\n                - ∑ dp[i-n-1] * x^i [n+1<=i<=2n]\n                - ∑ dp[i-n-2] * x^i [n+2<=i<=2n]\n                - ∑ dp[i-n-3] * x^i [n+3<=i<=2n]\n                - ...\n              =   ∑ dp[i] * x^i [1<=i<=n]\n                + ∑ x^(n+1)  *  (dp[n+1] - dp[0])\n                + ∑ x^(n+2)  *  (dp[n+1] - dp[0] - dp[1])\n                + ∑ x^(n+2)  *  (dp[n+1] - dp[0] - dp[1] - dp[2])\n                ...\n        即对于所有 n+1 <= j <= 2*n 的项，执行操作：\n            dp[j] = dp[j] - sum[j-n-1],  sum[]为dp[]的前缀和\n        合并复杂度O(n)\n\n    总时间复杂度O(n^1.5)\n*/\n```\n\n","tags":["母函数"],"categories":["算法"]},{"title":"Unknown Treasure(Lucas+中国剩余定理）","url":"/2018/08/11/Unknown Treasure/","content":"\n# [Unknown Treasure](https://nanti.jisuanke.com/t/29337) \n\n## 题意\n\n给你n，m，和K个素数$p_1,p_2 …… p_k$，求$C_n^mmod\\prod{p_i}$。\n\nn,m<=1e18。\n\n## 思路\n\n计算组合数用Lucas即可，每次取模Pi，然后由于最终是要模$\\prod{p_i}$，所以用中国剩余定理。\n\n>令 $tot = \\prod{p_i} $，$X=C_n^mmod\\prod{p_i}$，$K=\\lfloor C_n^m/\\prod{p_i}\\rfloor$\n>\n>有：$C_n^m=K*tot+X$\n>\n>两边同对$pi$取模， \n\n$$\nX \\% p_1 = C_n^m \\% p_1 = Lucas(n,m,p_1) \n$$\n\n$$\nX \\% p_2 = C_n^m \\% p_2 = Lucas(n,m,p_2)\n$$\n\n$$\n…\n$$\n\n$$\nX \\% p_n = C_n^m \\% p_n = Lucas(n,m,p_n)\n$$\n\n$$\nX \\% p_1 = C_n^m \\% p_1 = Lucas(n,m,p_1)\n$$\n\n>利用中国剩余定理求出X即可。\n>\n>因为做乘法过程中可能会超long long ，所以我们要用快速乘法去处理，方便取模 \n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100005;\n\nll fac[N];\n\nll modpow(ll a, ll b, ll MOD)\n{\n    ll ret = 1;\n    while(b)\n    {\n        if(b & 1) ret = (ret * a)%MOD;\n        a = (a * a)%MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll modmul(ll a, ll b, ll MOD)  //快速乘\n{\n    ll ret = 0;\n    while(b)\n    {\n        if(b & 1) ret = (ret + a) % MOD;\n        a = (a + a) % MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll getFactor(ll p) \n{\n    fac[0] = 1;\n    for(int i = 1; i <= p; i++)\n        fac[i] = (fac[i-1]*i) % p;\n}\n\nll Lucas(ll n, ll m, ll p)\n{\n    ll ret=1;\n    while(n && m)\n    {\n        ll a = n%p, b = m%p;\n        if(a < b) return 0;\n        ret = (ret * fac[a] * modpow(fac[b]*fac[a-b]%p, p-2, p)) % p;\n        n/=p;\n        m/=p;\n    }\n    return ret;\n}\n\nll exgcd (ll a, ll b, ll &x, ll &y)\n{\n    if (!b)\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int ans = exgcd ( b, a % b, y, x );\n    y -= a / b * x;\n    return ans;\n}\n\n//中国剩余定理，a[i]存放余数，m[i]存放两两互质的数\nll remainder(ll a[], ll m[], int len)\n{\n    ll d, x, y, ret = 0;\n    ll M = 1;\n    for (int i = 0; i < len; i++) M *= m[i];\n    for (int i = 0; i < len; i++)\n    {\n        ll w = M / m[i];\n        d = exgcd(m[i], w, x, y);\n        ret = (ret + modmul(modmul(y, w, M), a[i], M) ) % M; //这里 y*w*a[i]直接乘会超long long，所以要用快速乘，M为每次的MOD。\n    }\n    return (ret + M) % M;\n}\n\nll n, m;\nint K;\nll p[15], lucas[15];\n\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while(T--)\n    {\n        scanf(\"%lld%lld%d\", &n, &m, &K);\n        for(int i = 0; i < K; i++)\n        {\n            scanf(\"%lld\", &p[i]);\n            getFactor(p[i]);\n            lucas[i] = Lucas(n, m, p[i]); //对于每一个pi计算一次C(n,m)\n        }\n        ll ans = remainder(lucas, p, K);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n","tags":["中国剩余定理"],"categories":["算法"]},{"title":"在比赛中遇到的稀奇古怪的结论","url":"/2018/08/09/在比赛中遇到的稀奇古怪的结论/","content":"\n\n\n**将多边形对角线相连，其对角线最多被分割成多少段？**\n\n$$\nmax=(n^4-6n^3+17n^2-24n)/12\n$$\n\n**一个圆，一个圆的内接n边形，连接多边形对角线，求整个圆被分割成几块?**\n\n$$\nmax=(n^4-6n^3+23n^2-18n+24)/24\n$$\n\n**根号函数的性质：**\n$$\n\\sqrt{a+b+c+…}\\le\\sqrt{a}+\\sqrt{b}+\\sqrt{c}+…\n$$\n **求$(\\sum_{i=1}^mx_i )= k (0≤x_i < n)​$的整数解的组数**([Character Encoding](http://acm.hdu.edu.cn/showproblem.php?pid=6397) )\n\n分析后发现答案为$(1+x+x^2+x^3+…+x^n)^m$的展开式中项的次数为k的项的系数，对于n,m,k，有答案：\n$$\n    \\sum_{i=0}^{\\lfloor{\\frac{k}{n}}\\rfloor}(-1)^iC_m^iC_{m+k-1-n*i}^{m-1}\n$$\n**多边形公式**\n\n$$S=\\frac{1}{2}\\left|\\sum\\limits_{i=0}^{n-1}(X_iY_{i+1}-X_{i+1}Y_i)\\right|$$\n\n其中是相邻的点，对于n-1的i+1是0代表这第一个点，由于顺时针逆时针会使正负号改变，所以取绝对值。\n\n**摆线与圆面积关系**\n\n1. 摆线留下的面积是圆面积的三倍。\n2. 它的长度等于旋转圆直径的 4 倍，是 一个不依赖于π的有理数。\n\n摆线定义：摆线(cycloid)是数学中众多的迷人曲线之一．它是这样定义的：一个圆沿一直线缓慢地滚动，则圆上一固定点所经过的轨迹称为摆线．\n\n**两条直线夹角**\n\n$${\\left|\\frac{A_{1}B_{2}-A_{2}B_{1}}{A_{1}A_{2}+B_{1}B_{2}}\\right|}$$\n\n**素数定理**\n$$\\lim\\limits_{n->\\infty}\\frac{\\pi(n)}{n/\\ln{n}}$$\n\n描述素数的分布，素数分布规律，以36N（N+1）为单位，随着N的增大，素数的个数发波浪形式渐渐增多。素数定理可以给出第n个素数p(n)的渐近估计： 它也给出从整数中抽到素数的概率。从不大于n的自然数随机选一个，它是素数的概率大约是1/ln n。 π(n)为小于等于n的素数的个数。\n\n**GCD(1)**\na> 0；m,n > 0，那么有$$\\gcd(a^m-1,a^n-1)=a^{gcd(m,n)}-1$$\n\n**GCD(2)**\na>b;gcd(a,b)=1,那么$\\gcd(a^m-b^m,a^n-b^n)=a^{\\gcd(m,n)}-{b^{\\gcd(m,n)}} $\n\n**GCD(3)**\n设$$\\gcd(a^m-1,a^n-1)=a^{gcd(m,n)}-1$$,那么G的值为\n(1)n为素数，那么答案就是n。\n(2)n有多个素因子，那么答案就是1。\n(3)n只有一个素因子，那么答案就是该因子。\n\n**GCD(4)**\n\n$$\\sum\\limits_{i=1}^{N}\\gcd(i,N)=\\sum\\limits_{d|N}dφ(\\frac{N}{d})=\\sum\\limits_{d|N}\\frac{N}{d}φ(d)$$\n\nφ(x)为欧拉函数，d是N的质因子\n\n**欧拉函数**\n\n$\\sum_{d|n}\\varphi(d)=n $\n\n**Fibonacci(1)**\n设Fn为Fib数，那么有$$\\gcd(F_m,F_n) = F_{gcd(m,n)}​$$\n\n**Fibonacci(2)**\n给定两个互素的正整数A和B，那么它们最大不能组合的数为A∗B−A−B不能组合的个数为$$num=\\frac{(A-1)(B-1)}{2}$$\n\n**lcm(1)**\n$$(n+1)lcm(C_n^0,C_n^1,\\cdots,C_n^n)=lcm(1,2,\\cdots,n+1)$$\n\n**lcm(2)**\n给一个正整数n，求lcm(1,2,3,⋯,n)lcm(1,2,3,⋯,n)的值，(1<=n<=10^8)\n\n定义L(n)L(n)为1,2,3,……,n的最小公倍数。则可以发现：\n$$\nL(n+1)=L(n)*p \\ \\ \\ \\ \\   \\ \\ \\ \\ \\ 如果(n+1)是p的次方数\n$$\n\n$$\n= L(n) \t\\ \\  \\ \\ \\ \\  \\ \\  \\ \\ \\  \\ 否则 \n$$\n\n所以有: \n\nL(1) = 1 \nL(2) = 1 x 2 \nL(3) = 1 x 2 x 3 \nL(4) = 1 x 2 x 3 x 2 \nL(5) = 1 x 2 x 3 x 2 x 5 \nL(6) = 1 x 2 x 3 x 2 x 5 \nL(7) = 1 x 2 x 3 x 2 x 5 x 7\n\n**φ(ab)和gcd(a,b)的关系**\n$$\n\\frac{φ(ab)}{φ(a)φ(b)}=\\frac{gcd(a,b)}{φ(gcd(a,b))}\n$$\n\n\n","categories":["算法"]},{"title":"Harvest of Apples (莫队)","url":"/2018/08/09/Harvest-of-Apples-(莫队)/","content":"\n# [Harvest of Apples](http://acm.hdu.edu.cn/showproblem.php?pid=6333) \n\n## 题意\n\n题意是从n个苹果里面选取最多m个苹果的方案数量。m、n、t<=1e5\n\n<h2>思路</h2>\n\n莫队分块+组合预处理，原来莫队中的区间[l,r]在这里用n、m代替了。\n\n接下来是推公式部分：\n\nS(n,m)表示$\\sum_{i=1}^n\\sum_{j=1}^mC_i^j$\n\n我们可以得出$S(n,m)=S(n,m-1)+C_n^m$ ,-------①\n\n又因为有$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$（组合数学的一个基本公式），因此又可以推出：$S(n,m)=S(n-1,m)+S(n-1,m-1)=2S(n-1,m)-C_{n-1}^m$--------②\n\n有了①②两个式子，我们就可以得到S(n,m)和S(n-1,m)、S(n+1,m)、S(n,m-1)、S(n,m+1)之间的关系，先预处理出n！和相应的需要的逆元，然后把输入的查询分块，按照代码中所示的“套路”排序法，排一排，然后对于每个n，m开始处理，分四种情况这样。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nll multi[N];\nll devide[N];\nll ans[N];\nll pos[N];\nll er;\nint D=(int)sqrt(1.0*N);\nstruct node{\n    int n,m;\n    int id;\n    bool operator <(const node& p) const{\n        if(pos[n]==pos[p.n]) return m<p.m;\n        return n<p.n;                           //N大的排前面\n    }\n};\nnode qujian[N];\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll n)//乘法逆元,n取模\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\nvoid init(int n)\n{\n    multi[0]=1;\n    multi[1]=1;\n    for(int i=2;i<=n;i++)\n        multi[i]=multi[i-1]*i%MOD;\n    devide[n]=mod_inverse(multi[n],MOD);\n    for(int i=n-1;i>=0;i--)\n        devide[i]=devide[i+1]*(i+1)%MOD;\n}\nll cal(int n,int m)\n{\n    return ((multi[n]*devide[m])%MOD*devide[n-m])%MOD;\n}\nvoid operation1(int n,int m,ll &res)\n{\n    res=((2ll*res)%MOD-cal(n,m)%MOD+MOD)%MOD;\n}\nvoid operation2(int n,int m,ll &res)\n{\n    res=(res+cal(n-1,m))%MOD*er%MOD;\n}\nvoid operation3(int n,int m,ll &res)\n{\n    res=(res+cal(n,m+1))%MOD;\n}\nvoid operation4(int n,int m,ll &res)\n{\n    res=(res-cal(n,m)+MOD)%MOD;\n}\nint main()\n{\n    init(100000);\n    int t;\n    int n,m;\n    er=mod_inverse(2ll,MOD);\n    scanf(\"%d\",&t);\n    for(int i=1;i<=t;i++)\n    {\n        scanf(\"%d%d\",&qujian[i].n,&qujian[i].m);\n        qujian[i].id=i;\n        pos[i]=i/D;\n    }\n    sort(qujian+1,qujian+t+1);\n    int curl,curr;\n    curl=curr=1;\n    ll res=2;\n    for(int j=1;j<=t;j++)\n    {\n        while(curl<qujian[j].n) operation1(curl++,curr,res);\n        while(curr<qujian[j].m) operation3(curl,curr++,res);\n        while(curl>qujian[j].n) operation2(curl--,curr,res);\n        while(curr>qujian[j].m) operation4(curl,curr--,res);\n        ans[qujian[j].id]=res;\n    }\n    for(int i=1;i<=t;i++)\n        printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n```\n\n","tags":["莫队"],"categories":["算法"]},{"title":"Glad You Came（线段树||ST表）","url":"/2018/08/09/Glad-You-Came（线段树）/","content":"\n# [Glad You Came](http://acm.hdu.edu.cn/showproblem.php?pid=6356) \n\n## 题意\n\n不晓得咋说……反正就是把m个区间对应m个vi，对于每一个区间的数字，小于vi的都变成vi，最后求最终结果的i*a[i]的异或。\n\n1、线段树：肯定要维护一个最小值，而且这题由于初始的ai都是0，因此min也是0，而且暴力单点更新，我们只需要建一个一维的数组就好了。然后一个update函数，一个最终结果的计算函数，注意剪枝：\" $if(tree[index].val>=v) return \"$。\n\n2、反向ST表：我的理解是，对于一个区间$dp[i][d]$，表示的是从i位置开始长度为$2^d$的区间,也就是$[i , i+2^d-1]$。\n\n比如对于区间[1,10]，长度为10，那么我们找到最大的那个<10的$2^d$，即8，d=3，可将区间分成两个：[1,8],[3,10]，用dp[],[]表示就是$dp[1][3]$和$dp[10-2^3+1][3]$。这样对于每一次询问L,R，从一个大区间分出来的两个小区间，维护他们的max值，取max(dp ,val ) 。这样，我们就从最大的区间开始往小了维护，直到$dp[i][0]$这样。\n\n\n\n<h2>看！代码</h2>\n\n```c++\n/*线段树莽过的做法*/\n#include <bits/stdc++.h>\n#define MAXN 100010\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef unsigned int uint;\n\nlong long tree[MAXN<<2];//一定要开到4倍多的空间\nint cnt;\nlong long ans;\n\nuint mod=1<<30;\nuint fx(uint &x,uint &y,uint &z)\n{\n    x=x^(x<<11);\n    x=x^(x>>4);\n    x=x^(x<<5);\n    x=x^(x>>14);\n    uint w=x^(y^z);\n    x=y;\n    y=z;\n    z=w;\n    return z;\n}\n\nint L,R;\nlong long v;\nvoid update(int l,int r,int index)\n{\n    if(tree[index]>=v)\n        return;\n    if(l==r&&tree[index]<v)\n    {\n        tree[index]=v;\n        return ;\n    }\n    int mid=l+r>>1;\n    if(L<=mid)update(l,mid,index<<1);\n    if(R>mid)update(mid+1,r,index<<1|1);\n\n    tree[index]=min(tree[index<<1],tree[index<<1|1]);\n}\nlong long cal(int l,int r,int index)\n{\n    if(l==r)\n        return tree[index];\n    int mid=l+r>>1;\n    if(cnt<=mid)\n        return cal(l,mid,index<<1);\n    else\n        return cal(mid+1,r,index<<1|1);\n\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        memset(tree,0,sizeof(tree));\n        int n,m;\n        cnt=1;\n        long long ans=0;\n        scanf(\"%d%d\",&n,&m);\n        uint x,y,z;\n        scanf(\"%u%u%u\",&x,&y,&z);\n        for(int i=1;i<=m;i++)\n        {\n            L=fx(x,y,z)%n+1;\n            R=fx(x,y,z)%n+1;\n            v=fx(x,y,z)%mod;\n            if(L>R) swap(L,R);\n            update(1,n,1);\n        }\n        for(cnt=1;cnt<=n;cnt++)\n            ans=ans^(cnt*cal(1,n,1));\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n```\n\n```c++\n#include <bits/stdc++.h>\n#define MAXN 100010\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef unsigned int uint;\nuint f[15000010];\nuint mod=1<<30;\nuint fx(uint &x,uint &y,uint &z)\n{\n    x=x^(x<<11);\n    x=x^(x>>4);\n    x=x^(x<<5);\n    x=x^(x>>14);\n    uint w=x^(y^z);\n    x=y;\n    y=z;\n    z=w;\n    return z;\n}\n\nint l[5000010],r[5000010];\nlong long v[5000010];\nlong long dp[100010][18];\nint lg[100010];\nint main()\n{\n    int t;\n    for(int i=1;i<=100000;i++) lg[i]=log2(i);\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        uint x,y,z;\n        scanf(\"%u%u%u\",&x,&y,&z);\n        for(int i=1;i<=3*m;i++)\n            f[i]=fx(x,y,z);\n        for(int i=1;i<=m;i++)\n        {\n            l[i]=min(f[i*3-2]%n+1,f[i*3-1]%n+1);\n            r[i]=max(f[i*3-2]%n+1,f[i*3-1]%n+1);\n            v[i]=f[i*3]%mod;\n        }\n        memset(dp,0,sizeof(dp));\n        int d,MAX=-1;\n        for(int i=1;i<=m;i++)\n        {\n            d=lg[r[i]-l[i]+1];\n            MAX=max(MAX,d);//记录最长的长度\n            dp[l[i]][d]=max(v[i],dp[l[i]][d]); //分为两部分，每一部分取覆盖的最小值和v比较\n            dp[r[i]-(1<<d)+1][d]=max(v[i],dp[r[i]-(1<<d)+1][d]);\n        }\n        for(int j=MAX;j>0;j--)\n        {\n            for(int i=1;i+(1<<j)-1<=n;i++)\n            {\n                dp[i][j-1]=max(dp[i][j],dp[i][j-1]);\n                dp[i+(1<<(j-1))][j-1]=max(dp[i][j],dp[i+(1<<(j-1))][j-1]);\n            }\n        }\n        long long ans=0;\n        for(int i=1;i<=n;i++)\n            ans=ans^(1ll*i*dp[i][0]);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n```\n\n","tags":["ST表"],"categories":["算法"]},{"title":"莫比乌斯题集（有丶意思）","url":"/2018/08/09/莫比乌斯题集/","content":"\n<h1>[YY的GCD](https://www.luogu.org/problemnew/show/P2257)</h1>\n\n## 题意\n\n给你一个n,m，求gcd(i,j)=质数的(x,y)有多少对？(1<=x<=N,1<=y<=M)\n\n## 思路\n\n题目实际上是要求：\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^Mgcd(i,j)=prim\n$$\n由莫比乌斯反演的基本公式：\n$$\nF(n)=\\sum_{n|d}f(d)\n$$\n\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)\n$$\n\n听说一般这种题都是设f(d)= gcd(i,j)==d的个数，F(n) =gcd(i,j)== d和d的倍数的个数 (那么对于上界N和M，就有$F(n)=\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor$，因为对于(i,j)，它们的上限为(N,M)，gcd(i,j)=n,而F(n)求的是d和d的倍数的个数，所以对于i，j来说，这样的搭配有N/n*M/n个）。\n\n所以我们可以得到下面的式子：\n$$\nf(d)=\\sum_{i=1}^N\\sum_{j=1}^M[gcd(i,j)==d]\n$$\n\n$$\nF(n)=\\sum_{n|d}f(d) =\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor\n$$\n\n带入莫比乌斯公式：\n\n\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)=\\lfloor\\frac{N}{n}\\rfloor \\lfloor\\frac{M}{n}\\rfloor\\sum_{n|d}μ(\\frac{d}{n})\n$$\n\n$$\nans=\\sum_{i=1}^{N}\\sum_{j=1}^{M}[gcd==p]\n$$\n\n$$\n=\\sum_{p=prim}f(p)\n$$\n\n$$\n=\\sum_{p=prim}\\sum_{p|d}μ(\\frac{d}{p})\\lfloor\\frac{N}{p}\\rfloor \\lfloor\\frac{M}{p}\\rfloor\n$$\n\n枚举$\\lfloor\\frac{d}{p}\\rfloor$,或者说令d=dp，那么d就变成了p的倍数，所以sum枚举的值就变成了1~d(d最大可以取到N/p和M/p中的最小值，因为p是gcd(i,j)==p，那么就不可能取i，j中大的值)：\n$$\nans=\\sum_{p=prim}\\sum_{d=1}^{min(\\lfloor\\frac{N}{p}\\rfloor ,\\lfloor\\frac{M}{p}\\rfloor)}μ(d)\\lfloor\\frac{N}{dp}\\rfloor \\lfloor\\frac{M}{dp}\\rfloor\n$$\n将dp=T，则p∈{t|T%t==0&&t==prim}：\n$$\nans=\\sum_{T=1}^{min(N,M)}\\sum_{t|T,t∈prim}μ(\\lfloor\\frac{T}{t}\\rfloor)\\lfloor\\frac{N}{T}\\rfloor\\lfloor\\frac{M}{T}\\rfloor\n$$\n\n$$\n=\\sum_{T=1}^{min(N,M)}\\lfloor\\frac{N}{T}\\rfloor\\lfloor\\frac{M}{T}\\rfloor\\sum_{t|T,t∈prim}μ(\\lfloor\\frac{T}{t}\\rfloor)\n$$\n\n就可以做了。\n\n<h2>看！代码</h2>\n\n第一份O(n)直接求和的代码，当然会T。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000010;\nint prim[N];//316067\nbool vis[N];\nint mu[N];\nint cnt=0;\n//埃式筛法，这里没有用到\n//求n以内的质数的个数\nvoid get_list(int n)\n{\n    cnt=0;\n    memset(vis,false,sizeof(vis));\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]) prim[++cnt]=i;\n            for(int j=1;j<=cnt&&i*prim[j]<=n;j++){\n                   vis[i*prim[j]]=1;\n                   //合数标为1，同时，prime[j]是合数i*prime[j]的最小素因子\n                   if(i%prim[j]==0) break;\n                    //即比一个合数大的质数和该合数的乘积可用一个更大的合数和比其小的质数相乘得到\n             }\n       }\n}\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n}\nint main()\n{\n    get_mu(10000000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        long long ans=0;\n        for(int i=1;i<=Min;i++)\n        {\n            long long sum=0;\n            for(int j=1;j<=cnt&&prim[j]<=i;j++)\n            {\n                if(i%prim[j]==0)\n                    sum+=mu[i/prim[j]];\n            }\n            sum*=(n/i)*(m/i);\n            ans+=sum;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n第二份用了整数分块优化，写的我头真大，比如多加一个memset，T，int开了long long T，\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=10000010;\n\nbool vis[N];\nint prim[N],pre[N],mu[N];\nint cnt;\nlong long sum[N];\n\n/** 对于μ函数的线筛*/\nvoid get_mu(int n)\n{\n   // memset(vis,false,sizeof(vis));\n    cnt=0;\n\tmu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]){mu[i]=-1;prim[++cnt]=i;}\n        for(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n            vis[i*prim[j]]=1;\n            if(i%prim[j]==0)break;\n            else mu[prim[j]*i]=-mu[i];\n        }\n    }\n    sum[0]=0;\n\tfor(int j=1;j<=cnt;j++)\n        for(int i=1;i*prim[j]<=n;i++)\n        pre[i*prim[j]]+=mu[i];   //预处理对于某一个数，它的质数因子的mu（T/i）和\n    //为了得到区间i的mu和，通过求出前缀和来做\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+(long long)pre[i];\n}\nint main()\n{\n    get_mu(10000000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        long long ans=0;\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l)); //这里要注意\n            ans+=1ll*(m/l)*(n/l)*(sum[r]-sum[l-1]); \n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n<h1>POI2007[ZAP-Queries](https://www.luogu.org/problemnew/show/P3455)</h1>\n\n## 题意\n\n求$\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d] $，多组，$1\\le d\\le a,b\\le 50000$\n\n<h2>思路</h2>\n$$\nans=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d]\n$$\n\n我们假设：\n$$\nf(d)=\\sum_{i=1}^{a}\\sum_{j=1}^{b}[gcd(x,y)=d]\n$$\n\n$$\nF(n)=\\sum_{d|n}f(d)=\\lfloor\\frac{a}{n}\\rfloor\\lfloor\\frac{b}{n}\\rfloor\n$$\n\n$$\nf(d)=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)F(n)\n$$\n\n发现原来f(d)=ans，那么有：\n$$\nans=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)F(n)=\\sum_{d|n}μ(\\lfloor\\frac{n}{d}\\rfloor)\\lfloor\\frac{a}{n}\\rfloor\\lfloor\\frac{b}{n}\\rfloor\n$$\n枚举$\\lfloor{\\frac{n}{d}\\rfloor}$=t：\n$$\nans=\\sum_{t=1}^{min(a,b)}μ(t)\\lfloor\\frac{a}{dt}\\rfloor\\lfloor\\frac{b}{dt}\\rfloor\n$$\n就能做了。\n\n因为前面已经做了一道比这题难的，所以就不写O(n)的写法了，直接上代码，一遍过，爽歪歪。\n\n<h2>看！代码</h2>\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=50010;\n\nbool vis[N];\nint prim[N],pre[N],mu[N];\nint cnt;\nlong long sum[N];\n\n/** 对于μ函数的线筛*/\nvoid get_mu(int n)\n{\n   // memset(vis,false,sizeof(vis));\n    cnt=0;\n\tmu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        if(!vis[i]){mu[i]=-1;prim[++cnt]=i;}\n        for(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n            vis[i*prim[j]]=1;\n            if(i%prim[j]==0)break;\n            else mu[prim[j]*i]=-mu[i];\n        }\n    }\n    sum[0]=0;\n    for(int i=1;i<=n;i++)\n        pre[i]+=mu[i]; \n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+(long long)pre[i];\n}\nint main()\n{\n    get_mu(50000);\n    int t,a,b,d;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%d%d%d\",&a,&b,&d);\n        int Min=min(a,b);\n        long long ans=0;\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(a/(a/l),b/(b/l));\n            ans+=1ll*(a/(l*d))*(b/(l*d))*(sum[r]-sum[l-1]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n# [约数个数和](https://www.luogu.org/problemnew/show/P3327)\n\n## 题意\n\n设d(x)为x的约数个数，给定N、M，求$\\sum_{i=1}^{N}\\sum_{j=1}^{M}d(ij)$\n\n多组，N,M。1<=N, M<=50000 \n\n## 思路\n\n关于这个约数的个数d(x)，它其实有下面这样的函数式：\n$$\nd(ij)=\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\n$$\n接下来套路的设：\n$$\nf(d)=\\sum_{i=1}^N\\sum_{j=1}^{M}[gcd(i,j)==d]\n$$\n\n$$\nF(n)=\\sum_{n|d}f(d)=\\lfloor\\frac{N}{n}\\rfloor\\lfloor\\frac{M}{n}\\rfloor      --①\n$$\n\n由莫比乌斯反演可以得到：\n$$\nf(n)=\\sum_{n|d}μ(\\frac{d}{n})F(n)\n$$\n因为：\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j}[gcd(x,y)==1]\n$$\n由于$∑_{d|n}μ(d)$的性质，即d=1的时候=1，其他都是0，可以将式子化为：\n\n\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} \\sum_{d|gcd(x,y)}μ(d)\n$$\n枚举d|gcd(x,y)的情况 ，d从1取到min(N,M)\n$$\nans=\\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} \\sum_{d=1}^{min(N,M)}μ(d)*[d|gcd(x,y)]\n$$\n由于μ(d)与x，y，i，j无关，所以可以提到最前面\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{i=1}^N\\sum_{j=1}^M\\sum_{x|i}\\sum_{y|j} [d|gcd(x,y)]\n$$\n对于x|i，y|j的情况，可以由①得到$=\\lfloor\\frac{N}{x}\\rfloor\\lfloor\\frac{M}{y}\\rfloor$\n\n> 由**枚举i,j和它们的约数**改变为**枚举它们的约数**再直接乘上这些约数的倍数的个数。因为每一个约数都会对它的倍数产生贡献。 \n\n$$\nc\n$$\n\n为了将d|gcd(x,y)这个条件消去，我们更换枚举项x->dx，y->dy：\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{x=1}^{\\frac{N}{d}}\\sum_{y=1}^{\\frac{M}{d}}\\lfloor\\frac{N}{dx}\\rfloor\\lfloor\\frac{M}{dy}\\rfloor\n$$\n\n$$\nans=\\sum_{d=1}^{min(N,M)}μ(d) \\sum_{x=1}^{\\frac{N}{d}}\\lfloor\\frac{N}{dx}\\rfloor\\sum_{y=1}^{\\frac{M}{d}}\\lfloor\\frac{M}{dy}\\rfloor\n$$\n\n就可以做了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint mu[50010];\nint prim[50010];\nbool vis[50010];\nlong long sum[50010],chu[50010];\nint cnt;\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n\tmu[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n\t}\n\t//这里是key\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+mu[i]; //第一个sum\n    for(int i=1;i<=n;i++)\n    {\n\n        long long ans=0;\n        for(int l=1,r;l<=i;l=r+1)\n        {\n            r=i/(i/l); \n            ans+=1ll*(r-l+1)*(i/l);\n        }\n        chu[i]=ans;//第2、3个sum，枚举n（n/d）来算\n    }\n\n}\nint main()\n{\n    get_mu(50000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        long long ans=0;\n        scanf(\"%d%d\",&n,&m);\n        int Min=min(n,m);\n        for(int l=1,r;l<=Min;l=r+1)\n        {\n            r=min(n/(n/l),m/(m/l)); //右边的数应当取min，这里只有一个n就没关系\n            ans+=(sum[r]-sum[l-1])*(chu[n/l])*(chu[m/l]);\n            //三个sum相乘\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n# [problem b](https://www.luogu.org/problemnew/show/P2522)\n\n## 题意\n\n- 对于给出的n个询问，每次求有多少个数对(x,y)，满足a≤x≤b，c≤y≤d，且gcd(x,y) = k，gcd(x,y)函数为x和y的最大公约数。\n- 输入格式：\n  第一行一个整数n，接下来n行每行五个整数，分别表示a、b、c、d、k\n- 输出格式：\n  共n行，每行一个整数表示满足要求的数对(x,y)的个数\n- 1≤n≤50000，1≤a≤b≤50000，1≤c≤d≤50000，1≤k≤50000 \n\n## 思路\n\n这里用了容斥的思想：\n$$\nans=\\sum_{i=a}^{b}\\sum_{j=c}^{d}[gcd(i,j)==k]\n$$\n实际上，（画个图就明白了）\n$$\nans=sum{(1,b)(1,d)}-sum(1,b)(1,c-1)-sum(1,a-1)(1,d)+sum(1,a-1)(1,c-1)\n$$\n所以还是老套路，ans的每一部分可以分别套入公式算出来，所以只要求出一个公式：\n$$\nans=\\sum_{t=1}^{min(X,Y)}μ(t)\\lfloor\\frac{X}{kt}\\rfloor\\lfloor\\frac{Y}{kt}\\rfloor\n$$\n将x、y分别用b、d；b、c-1；a-1、d；a-1，c-1带入公式加加减减就好了。\n\np.s.现在的题目都T的很。。。无聊。。。我把计算的式子用ans来接收返回的函数然后输出ans,T掉，直接输出结果。。。。就快一点。。话是这样说。。。但是这也太。。。。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint mu[50010];\nint prim[50010];\nbool vis[50010];\nlong long sum[50010],chu[50010];\nint cnt;\n/** 对于μ函数的线筛 */\nvoid get_mu(int n)\n{\n    mu[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n    \tif(!vis[i]){prim[++cnt]=i;mu[i]=-1;}\n   \t \tfor(int j=1;j<=cnt&&prim[j]*i<=n;j++)\n        {\n        \tvis[prim[j]*i]=1;\n        \tif(i%prim[j]==0)break;\n        \telse mu[i*prim[j]]=-mu[i];\n    \t}\n    }\n    //这里是key\n    for(int i=1;i<=n;i++)\n        sum[i]=sum[i-1]+mu[i];\n\n}\nll cal(int n,int m,int k)\n{\n    ll ans=0;\n    int Min=min(n,m);\n    for(int l=1,r;l<=Min;l=r+1)\n    {\n        r=min(n/(n/l),m/(m/l)); //右边的数应当取min，这里只有一个n就没关系\n        ans+=(sum[r]-sum[l-1])*(n/(l*k))*(m/(l*k));\n            //这里根据情况改啊！r-（l-1）是因为这里的积性函数可以看作是μ(i)=1，n/l是后面的那个n/i\n    }\n   // printf(\"%lld\\n\",ans);\n    return ans;\n}\nint main()\n{\n    get_mu(50000);\n    int t,n,m;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int a,b,c,d,k;\n        scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&k);\n        printf(\"%lld\\n\",cal(b,d,k)-cal(a-1,d,k)-cal(b,c-1,k)+cal(a-1,c-1,k));\n    }\n    return 0;\n}\n```\n\n# [crash的数字表格](https://www.luogu.org/problemnew/show/P1829)\n\n## 题意\n\n求$Ans=\\sum_{i=1}^{n}\\sum_{j=1}^{m}lcm(i,j) $\n\n- 输入格式：\n- 输入的第一行包含两个正整数，分别表示N和M。\n- 输出格式：\n- 输出一个正整数，表示表格中所有数的和mod20101009的值。\n\n## 思路\n\n由公式：$lcm(i,j)=\\frac{ij}{gcd(i,j)}$可以得到，\n$$\nans=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\frac{ij}{gcd(i,j)}\n$$\ngcd在分母中不好，枚举gcd=d，将其放到前面来：\n$$\nans=\\sum_{d=1}^{min(N,M)}\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\frac{ij}{d}[gcd(i,j)=d]\n$$\nd在分母中又不爽，还有gcd，枚举gcd（让i=di，j=dj）：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij[gcd(i,j)=1]\n$$\n由于性质$\\sum_{x|n}μ(x) = (n=1)$\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij \\sum_{x|gcd(i,j)}μ(x)\n$$\n要消去x|gcd(i,j)，因此枚举x：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{x=1}^{min(\\lfloor\\frac{N}{d}\\rfloor,\\lfloor\\frac{M}{d}\\rfloor)}μ(x)\\sum_{i=1}^{\\lfloor\\frac{N}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{M}{d}\\rfloor}ij[x|gcd(i,j)]\n$$\n为了消去那个[]的条件，我们让i=xi，j=xj：\n$$\nans=\\sum_{d=1}^{min(N,M)}d\\sum_{x=1}^{min(\\lfloor\\frac{N}{d}\\rfloor,\\lfloor\\frac{M}{d}\\rfloor)}x^2μ(x)\\sum_{i=1}^{\\lfloor\\frac{N}{dx}\\rfloor}i\\sum_{j=1}^{\\lfloor\\frac{M}{dx}\\rfloor}j\n$$\n","tags":["莫比乌斯反演"],"categories":["算法"]},{"title":"Color it (简单扫描)","url":"/2018/08/09/Color-it-(简单扫描)/","content":"\n<h1>Color it</h1>\n\n<h2>题意</h2>\n\n给你一个表格样，再给出m个圆，满足式子：$\\sqrt{(i-x_c)^2+(j-y_c)^2}\\le{r}$ 的，都要染成黑色，问你最后没有被染色的格子数。\n\n思路就是简单模拟一下扫描线的操作，可以先对每一个圆，处理出圆内列对应的扫描线的长度，存在相应的列中。然后再遍历每一列，对于列中存在的扫描线，按照l小r大排序，然后如果这个区间的l要大于上个区间的r，ans就减去this.r-this.l+1，否则如果this.l<last.r,并且this.r>last.r，就this.r-last.r（不加1因为last.r已经算过），如果this.r<last.r，则不必再计算。\n\n<h2>看！代码</h2>\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e4+10;\nstruct node{\n    int up,down;\n    node(int x,int y){\n        up=x;down=y;\n    }\n};\nbool cmp(node a,node b)\n{\n    if(a.up==b.up) return a.down>b.down;\n    return a.up<b.up;\n}\n\nint main()\n{\n    int t;\n    int n,m,q;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int x,y,r,ux,dx,ly,ry;\n        scanf(\"%d%d%d\",&n,&m,&q);\n        vector <node> v[MAXN*2];\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&r);\n            ly=max(0,y-r);\n            ry=min(y+r,m-1);\n            for(int j=ly;j<=ry;j++) //先处理出每列对应的扫描线，存下来\n            {\n                int derta=sqrt(r*r-(y-j)*(y-j));\n                ux=max(0,x-derta);\n                dx=min(n-1,x+derta);\n                v[j].push_back(node(ux,dx));\n            }\n        }\n        int len;\n        int last,ans=n*m;\n        for(int i=0;i<m;i++) //对应每一列存在的扫描线，先从l小，r大排序，然后判断计算\n        {\n            len=v[i].size();\n            if(len)\n            {\n                last=-1;\n                sort(v[i].begin(),v[i].end(),cmp);\n                for(int j=0;j<len;j++)\n                {\n                    if(v[i][j].down<=last)\n                        continue;\n                    if(v[i][j].up>last)\n                        ans-=v[i][j].down-v[i][j].up+1;\n                    else if(v[i][j].down>last)\n                        ans-=v[i][j].down-last;\n                    last=v[i][j].down;\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n\n}\n```\n\n","categories":["算法"]},{"title":"中国剩余定理模板","url":"/2018/08/08/中国剩余定理模板/","content":"\n```c++\n#include <iostream>\nusing namespace std;\n \nint Extended_Euclid(int a,int b,int &x,int &y)    //扩展欧几里得算法\n{\n\tint d;\n\tif(b==0)\n\t{\n\t\tx=1;y=0;\n\t\treturn a;\n\t}\n\td=Extended_Euclid(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n \nint Chinese_Remainder(int a[],int w[],int len)    //中国剩余定理  a[]存放余数  w[]存放两两互质的数\n{\n\tint i,d,x,y,m,n,ret;\n\tret=0;\n\tn=1;\n\tfor (i=0;i<len;i++)\n\t\tn*=w[i];\n\tfor (i=0;i<len;i++)\n\t{\n\t\tm=n/w[i];\n\t\td=Extended_Euclid(w[i],m,x,y);\n\t\tret=(ret+y*m*a[i])%n; //注意这里如果会超出longlong的范围就要用快速乘\n\t}\n\treturn (n+ret%n)%n;\n}\n \n \nint main()\n{\n\tint n,i;\n\tint w[15],b[15];\n\twhile (scanf(\"%d\",&n),n)   \n\t{\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&w[i],&b[i]);\n\t\t}\n\t\tprintf(\"%d/n\",Chinese_Remainder(b,w,n));\n\t}\n\treturn 0;\n}\n\n```\n\n","tags":["中国剩余定理"],"categories":["算法"]},{"title":"Lucas 模板","url":"/2018/08/08/Lucas-模板/","content":"\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n \nll quick_mod(ll a,ll b,ll m)\n{\n    ll ans = 1;\n    a %= m;\n    while(b)\n    {\n        if(b&1)\n            ans = ans * a % m;\n        b >>= 1;\n        a = a * a % m;\n    }\n    return ans;\n}\n \nll getC(ll n, ll m,ll mod)\n{\n    if(m > n)\n        return 0;\n    if(m > n-m)\n        m = n-m;\n    ll a = 1,b = 1;\n    while(m){\n        a = (a*n)%mod;\n        b = (b*m)%mod;\n        m--;\n        n--;\n    }\n    return a*quick_mod(b,mod-2,mod)%mod;\n}\n \nll Lucas(ll n,ll k,ll mod)\n{\n    if(k == 0)\n        return 1;\n    return getC(n%mod,k%mod,mod)*Lucas(n/mod,k/mod,mod)%mod;\n}\n \nint main()\n{\n    int T;\n    scanf(\"%d\",&T);\n    while(T--){\n        ll n,m,mod;\n        scanf(\"%lld%lld%lld\",&n,&m,&mod);\n        printf(\"%lld\\n\",Lucas(n+m,m,mod));\n    }\n    return 0;\n}\n```\n\n\n\n","tags":["Lucas"],"categories":["算法"]},{"title":"Ponds （并查集||拓扑+深搜）","url":"/2018/08/07/Ponds-（并查集拓扑+深搜）/","content":"\n# [Ponds](https://nanti.jisuanke.com/t/29329) \n\n## 题意\n\n给你n个点，m条无向边，每个点有vi的价值，你必须尽可能删去点，要求是删去的点的度数必须小于2。问你最后每个连通图中剩余奇数个点的总价值？\n\n## 思路\n\n1、一开始想是并查集吧，因为要计算每个环的点的数量，先把所有能删的点删去之后，再把剩下的边union起来，计算每个父亲所拥有的子的个数，奇数就加上去……\n\n2、拓扑+深搜。应该还是把能删掉的点先删掉，然后深搜也是找环的点数。\n\n## 看！代码\n\n```c++\n/**\n\t并查集做法\n\t*/\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst long long INF=0x3f3f3f3f;\nconst int N = 1e4+10;\nstruct node{\n    vector<int>next;\n    int deg;\n    int id;\n    node()\n    {\n        deg=0;\n    }\n};\nint id[N];\nint sz[N];\n\nll poor[N];\nint vis[N];\nint cnt[N];\nint edge[N][2];\nint Find(int x)  ///找跟根结点\n{\n    while(x!=id[x])\n    {\n        id[x]=id[id[x]];\n        x=id[x];\n    }\n    return x;\n}\n\nint un(int p,int q)\n{\n    int pr=Find(p);\n    int qr=Find(q);\n    if(pr==qr) return -1;\n    if(sz[pr]<=sz[qr])\n    {\n        sz[qr]+=sz[pr];id[pr]=qr;\n    }\n    else\n    {\n        sz[pr]+=sz[qr];id[qr]=pr;\n    }\n}\n\nvoid clear()\n{\n    for(int i=1;i<=N;i++)\n    {\n        id[i]=i;sz[i]=1;\n    }\n}\n\nint main()\n{\n    int t;\n    int p,m,u,v;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        node x[N];\n        memset(vis,0,sizeof(vis));\n        memset(cnt,0,sizeof(cnt));\n        clear();\n\n        scanf(\"%d%d\",&p,&m);\n        for(int i=1;i<=p;i++)\n            scanf(\"%lld\",&poor[i]);\n\n        for(int i=1;i<=p;i++)\n            x[i].id=i;\n\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            x[u].next.push_back(v);\n            x[u].deg++;\n            x[v].next.push_back(u);\n            x[v].deg++;\n            edge[i][0]=u;\n            edge[i][1]=v;\n        }\n        queue<node>q;\n        for(int i=1;i<=p;i++)\n            if(x[i].deg==1)\n                q.push(x[i]);\n            else if(x[i].deg==0)\n                vis[i]=1;\n        node temp;\n        while(!q.empty())\n        {\n            temp=q.front();\n            q.pop();\n            vis[temp.id]=1;\n            for(int i=0;i<temp.next.size();i++)\n                if(!vis[temp.next[i]])\n            {\n                x[temp.next[i]].deg--;\n                if(x[temp.next[i]].deg==1)\n                    q.push(x[temp.next[i]]);\n                else if(x[temp.next[i]].deg==0)\n                    vis[x[temp.next[i]].id]=1;\n            }\n        }\n\n        for(int i=0;i<m;i++)\n        {\n            int x=edge[i][0],y=edge[i][1];\n            if(vis[x]==1||vis[y]==1)continue;\n            un(x,y);\n        }\n        for(int i=1;i<=p;i++)\n        {\n            if(vis[i]==0)\n                cnt[Find(i)]++;\n        }\n\n        long long ans=0;\n        for(int i=1;i<=p;i++)\n        {\n            if(vis[i]==0&&cnt[Find(i)]>=3&&cnt[Find(i)]%2==1)\n                ans+=poor[i];\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["并查集"],"categories":["算法"]},{"title":"Fruit Ninja(头一次接触的随机化算法)","url":"/2018/08/05/Fruit-Ninja(头一次接触的随机化算法)/","content":"\n# [Fruit Ninja](https://www.nowcoder.com/acm/contest/163/A)\n\n<h2>题意</h2>\n\n屏幕上有n个水果，你可以画一条直线切掉其中一些，给你N和x，M/N>=x，M为切掉的水果数，x为0~1的纯小数，指的是切掉的水果比吧。问你是否有满足这个式子的这样一条直线，有输出yes，没有输出no。\n\nN<=1e4 , x小数点后一位（0,1）。\n\n## 思路\n\n随机化，巧妙巧妙，厉害厉害，佩服佩服，不过要分析一波随机的数量。由于m是切掉的水果数，n是总水果数，x是两者之比，也就是说在这条直线上的水果数是m个，意味着随机选一个水果，刚好在直线上的概率是x，因此随机选两个刚好组成这条直线的概率是x^2，而x∈[0.1,0.9]，因此概率最小为0.01，也就是说取100次就能取到那条我们需要的直线，反之如果没有满足的，就说明“NO”。为了保险起见，我们将随机范围设置为200。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct node{\n    ll x,y;\n};\nnode point[10010];\nint main()\n{\n    int t;\n    srand((unsigned)time(NULL));\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        double x;\n        scanf(\"%d%lf\",&n,&x);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lld%lld\",&point[i].x,&point[i].y);\n        }\n        int flag=0;\n        for(int i=0;i<200;i++)\n        {\n            int a=rand()%n;\n            int b=rand()%n;\n            while(a==b)\n                a=rand()%n;\n\n            int cnt=0;\n            for(int j=0;j<n;j++)\n                if((point[a].x-point[b].x)*(point[a].y-point[j].y)==(point[a].y-point[b].y)*(point[a].x-point[j].x))\n                    cnt++;\n\n            if(cnt>=n*x)\n            {\n                flag=1;break;\n            }\n        }\n        if(flag)    puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n```\n\n","tags":["随机化算法"],"categories":["算法"]},{"title":"太菜辣","url":"/2018/08/04/太菜辣/","content":"\n<h2>动态规划</h2>\n\n​\t基础\n​\t\t线性dp、区间dp，主要就是状态方程的设计和状态的转移\n​\t\t背包dp，及其扩展 《背包九讲》是很好的学习资料\n​\t\t用dp递推概率、期望（dp求期望一般分为两种。一种是dp状态保存的是概率，则期望=概率*花费。另一种是dp状态直接保存期望，这样一般都是逆推的。）\n​\t\t树形dp（有些会套个背包dp，有些需要多次树形dp）\n​\t\t状态压缩dp\n​\t\t数位dp\n​\t\tRMQ、二维RMQ\n​\t进阶\n​\t\tdp优化\n​\t\t\t使用数据结构优化，如线段树、树状数组、单调队列、单调栈、维护前缀和 ...\n​\t\t\t斜率优化（具有单调性可直接用单调队列或者二分，不具单调性要用平衡二叉树动态维护凸壳）\n​\t\t\t四边形不等式优化\n​\t\t插头dp\n\n<h2>数据结构</h2>\n\n​\t基础\n​\t\t~~队列、栈~~\n​\t\t~~树、图的存储、遍历 邻接表和邻接矩阵~~\n​\t\t~~单调队列、单调栈~~\n​\t\t~~线段树~~、~~树状数组~~\n​\t\t~~并查集~~、带权并查集\n​\t\t~~堆、优先队列~~\n​\t\t~~平衡二叉树~~\n​\t\t\tTreap\n​\t\t\tSpaly必须会\n​\t\t\t[红黑树]\n​\t\t\t[AVL树]\n​\t\t~~Hash散列表~~\n​\t进阶\n​\t\t分块数组（分块的思想很强大）\n​\t\t二维线段树（就是线段树套线段树，其实还有个[矩形树]）、二维树状数组（就是树状数组套树状数组）\n​\t\t树链剖分\n​\t\t树套树，如线段树套平衡二叉树、树状数组套平衡二叉树 ...\n​\t\tLink-Cut-Tree（解决一类动态树的问题，可以说是树的剖分+Splay）\n​\t\t可持久化数据结构，如主席树、可持久化线段树、可持久化字典树、可持久化并查集、可持久化Treap ...\n\n<h2>搜索</h2>\n\n​\t基础\n​\t\t~~深搜~~\n​\t\t~~广搜~~\n​\t\t记忆化搜索（也可以放到dp分类里）\n​\t\t~~使用优先队列的广搜~~\n​\t\t模拟退火、爬山算法\n​\t进阶\n​\t\t~~搜索剪枝~~\n​\t\t双向广搜\n​\t\tA*、IDA*\n​\t\t舞蹈链\n\n<h2/>图论</h2>\n\n​\t基础\n​\t\t~~最短路（Dijkstra、Spfa、Floyd）~~\n​\t\t~~最小生成树（Prim、Kruskal）~~\n​\t\t~~拓扑排序~~\n​\t\t二分图最大匹配（匈牙利算法）\n​\t\t\t二分图的最小顶点覆盖\n​\t\t\t~~DAG图的最小路径覆盖~~\n​\t\t\t二分图的最大独立集\n​\t\t二分图最优匹配（KM算法）\n​\t\t二分图多重匹配\n​\t\t网络流\n​\t\t\t~~最大流（Dinic~~、Sap）\n​\t\t\t最小费用最大流\n​\t\t\t带上下界的最大流\n​\t\t~~有向图强连通分量的Tarjan算法~~\n​\t\t最近公共祖先 Tarjan算法实现与RMQ实现各有千秋\n​\t\t差分约束系统\n​\t\t欧拉回路\n​\t\t构造哈密顿回路\n​\t\t最大团\n​\t\t无向图全局最小割（StoerWagner）\n​\t进阶\n​\t\t次小生成树\n​\t\t最优比率生成树\n​\t\t[度限制生成树]\n​\t\t[第k小生成树]\n​\t\t次短路、第k短路\n​\t\t网络流 胡伯涛的《最小割模型在信息学竞赛中的应用》是很好的学习资料\n​\t\t\t最大权闭合图\n​\t\t\t最大密度子图\n​\t\t\t二分图最小点权覆盖集\n​\t\t\t二分图最大点权独立集\n​\t\t\t区间k覆盖的模型\n​\t\t\t平面图网络流\n​\t\t无向图的割点和桥、边双联通分量、点双联通分量\n​\t\t2-SAT\n​\t\t最小树形图\n​\t\t一般图匹配\n​\t\t生成树计数、最小生成树计数\n\n<h2>数学</h2>\n\n​\t基础\n​\t\t数论\n​\t\t\t~~欧几里得算法、扩展欧几里得算法~~\n​\t\t\t~~乘法逆元~~\n​\t\t\t中国剩余定理\n​\t\t\t~~欧拉函数~~\n​\t\t\t~~欧拉定理~~\n​\t\t\t~~Miller_Rabin大素数判定~~\n​\t\t\t~~Pollard_rho大整数拆分~~\n​\t\t线性代数\n​\t\t\t~~矩阵乘法&快速幂~~\n​\t\t\t~~高斯消元~~\n​\t\t组合数学\n​\t\t\t容斥原理\n​\t\t\t鸽巢原理\n​\t\t\t~~[母函数]~~\n​\t\t\t[稳定婚姻问题]\n​\t\t概率统计\n​\t\t群论\n​\t\t\t置换群\n​\t\t\tBurnSide引理\n​\t\t\tPolya定理\n​\t进阶\n​\t\t~~莫比乌斯反演~~\n​\t\tBSGS\n​\t\tFFT\n​\t\t......\n​\t\t数学的进阶内容太多了\n\n<h2>字符串</h2>\n\n​\t基础\n​\t\t~~KMP、扩展KMP~~\n​\t\t~~字典树~~\n​\t\t最长回文子串的Manacher算法\n​\t\t字符串最小/最大表示法\n​\t\t许多字符串问题可以用dp甚至贪心求解\n​\t进阶\n​\t\t~~AC自动机、Trie图~~\n​\t\t回文树\n​\t\t后缀数组、后缀自动机、后缀树\n​\t\t序列自动机\n\n<h2>计算几何</h2>\n\n​\t基础\n​\t\t向量的点积、叉积\n​\t\t极角排序\n​\t\tGraham扫描法\n​\t\t二维最近点对\n​\t\t最小覆盖圆\n​\t\t圆面积并\n​\t\t......\n​\t\t计算几何的题目各种各样\n​\t进阶\n​\t\t半平面交\n​\t\t旋转卡壳\n​\t\t三维凸包\n​\t\t......\n​\t\t计算几何的题目各种各样\n\n<h2>杂</h2>\n\n​\t博弈\n​\t\t一些经典的博弈、SG函数、必胜必败态搜索\n​\tSTL\n​\t\tvector、set/mutiset、map、queue、stack、deque、string、rope...\n​\t排序\n​\t\t虽然都用sort但是堆排序的原理还是要知道的\n​\t分治\n​\t\t普通的分治\n​\t\tCDQ分治\n​\t\t整体二分\n​\t\t树分治\n​\t二分、三分\n​\t2-points\n​\t01分数规划\n​\t构造\n​\t树的同构（树的hash）\n​\t~~莫队算法~~、[树上莫队]\n​\t找规律、打表\n\n带[]的感觉没必要学","categories":["算法"]},{"title":"懵逼钨丝常用套路公式","url":"/2018/08/03/懵逼钨丝常用套路公式/","content":"\n1. $[n=1]=\\sum_{d|n}\\mu_d $ \n\n   **可以把一个“判一”的式子化成可以计算的函数** \n\n   $[\\gcd(a,b)=1]=\\sum_{d|\\gcd(a,b)}\\mu_d $\n\n2. $n=\\sum_{d|n}\\varphi_d $ \n\n   **把一个数化到枚举范围里面去** \n\n   $\\gcd(a,b)=\\sum_{d|\\gcd(a,b)}\\varphi_d $\n\n3. **重排变换**\n\n   $\\sum_{i=1}^n\\sum_{d|\\gcd(i,n)}f_d=\\sum_{d|n}f_d\\lfloor\\frac{n}{d}\\rfloor $\n\n4. **混合重排变换** \n\n   $\\sum_{i=1}^n\\sum_{d|\\gcd(i,m)}f_d=\\sum_{d|m}f_d\\lfloor\\frac{n}{d}\\rfloor $\n\n5. **扩展混合重排变换**  \n\n   $\\sum_{i=1}^n\\sum_{d|\\gcd(i,m)}f_dg_i=\\sum_{d|m}f_d\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}g_{id} $\n\n6. **扩展变换** \n\n   $\\sum_{i=1}^n[d|i]f_i=\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}f_{id}$\n\n7. **收缩变换** \n\n   $\\sum_{i=1}^n\\sum_{d|i}f_d=\\sum_{i=1}^n\\sum_{d=1}^{\\lfloor\\frac{n}{i}\\rfloor}f_d $\n\n8. **杜教筛变换** \n\n9. **约数个数变换** \n\n   $d(x)=d_{nm}=\\sum_{i|n}\\sum_{j|m}[\\gcd(i,j)=1] $\n\n   x的约数个数","tags":["模板"],"categories":["算法"]},{"title":"HDU1085 Holding Bin-Laden Captive!(母函数)","url":"/2018/08/03/HDU1085-Holding-Bin-Laden-Captive!(母函数)/","content":"\n# [Holding Bin-Laden Captive!](http://acm.hdu.edu.cn/showproblem.php?pid=1085) \n\n## 题意\n\n有面值为1、2、5的三种硬币，给你三个数字分别表示拥有的硬币数量，问最小的不能组成的面值为多少?\n\n1<=n<=1000\n\n## 思路\n\njust母函数，x上的指数代表v[i]*num，比如面值为2的硬币有3枚，那么就可以组成这样的多项式：\n\n\n$$\n1+x^2+x^4+x^6\n$$\n然后套模板就行。\n\n## 看！代码\n\n\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int a1,a2,a3;\n    int v[3]={1,2,5};\n    int n[3]={0,0,0};\n    int n2[3];\n\n    while(~scanf(\"%d%d%d\",&n2[0],&n2[1],&n2[2]))\n    {\n        if(n2[0]==0&&n2[1]==0&&n2[2]==0) break;\n        int a[10000]={0},b[10000];\n        a[0]=1;\n\n        int last=0;\n        int P=n2[0]+n2[1]*2+n2[2]*5;\n        int K=3;\n        for (int i=0;i<K;i++)\n        {\n            int last2=min(last+n2[i]*v[i],P);//计算下一次的last\n            memset(b,0,sizeof(int)*(last2+1));//只清空b[0..last2]\n            for (int j=n[i];j<=n2[i]&&j*v[i]<=last2;j++)//这里是last2\n                for (int k=0;k<=last&&k+j*v[i]<=last2;k++)//这里一个是last，一个是last2\n                    b[k+j*v[i]]+=a[k];\n            memcpy(a,b,sizeof(int)*(last2+1));//b赋值给a，只赋值0..last2\n            last=last2;//更新last\n        }\n        int flag=0;\n        for(int i=0;i<=P;i++)\n        {\n            if(a[i]==0)\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(!flag) printf(\"%d\\n\",P+1);\n        else printf(\"%d\\n\",i);\n    }\n    return 0;\n}\n```\n\n","tags":["母函数"],"categories":["算法"]},{"title":"A Possible Tree (带权并查集）","url":"/2018/08/03/A-Possible-Tree-(带权并查集）/","content":"\n# [ Possible Tree](https://nanti.jisuanke.com/t/28968)\n\n## 题意\n\n给你一棵树，q个询问，问的是x->y路径上的异或和为val , 问你最多有几个询问是真的？\n\n带权并查集。由于异或的特点，假设某个点为根，比如0，那么比如2->5的异或值，就是2->1的异或值和5->1的异或值异或一下。所以我们用yihuo[i]来表示i到源点的异或和。如果两个数的源点已经一样，那么判断一下val==yihuo[i]^yihuo[j]即可，若是不一样，就把他们union，同时yihuo[rootp]=yihuo[p]^yihuo[q]^val。\n\n\n\n## 看！代码\n\n``` c++\n#include <bits/stdc++.h>\nusing namespace std;\nint fa[100010],yihuo[100010];\nint Find(int x)\n{\n    if(x!=fa[x])\n    {\n        int tmp=fa[x];\n        fa[x]=Find(fa[x]);\n        yihuo[x]^=yihuo[tmp];\n        return fa[x];\n    }\n    return x;\n}\n\nbool Union(int p,int q,int val)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n    {\n        fa[rp]=rq;\n        yihuo[rp]=yihuo[p]^yihuo[q]^val;\n        return true;\n    }\n    if((yihuo[p]^yihuo[q])!=val)\n        return false;\n    return true;\n}\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        fa[i]=i;yihuo[i]=0;\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,k,u,v,val;\n        scanf(\"%d%d\",&n,&k);\n        init(n);\n        for(int i=0;i<n-1;i++)\n            scanf(\"%d%d\",&u,&v);\n        int flag=1,ans=0;\n        for(int i=0;i<k;i++)\n        {\n            scanf(\"%d%d%d\",&u,&v,&val);\n            if(!Union(u,v,val)&&flag)\n            {\n                flag=0;\n                ans=i;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["带权并查集"],"categories":["算法"]},{"title":"伯努利求自然数幂和","url":"/2018/08/03/伯努利求自然数幂和/","content":"\nhttps://blog.csdn.net/acdreamers/article/details/38929067 \n\n下面两个代码都是可以作为模板n<=1e18\n\nhttps://blog.csdn.net/acdreamers/article/details/38929067\n\n```c++\n#include <iostream>\n#include <string.h>\n#include <stdio.h>\n \nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1000000007;\nconst int N = 2005;\n \nLL C[N][N];\nLL B[N],Inv[N];\nLL Tmp[N];\nLL n;\n \nvoid Init()\n{\n    //预处理组合数\n    for(int i=0; i<N; i++)\n    {\n        C[i][0] = C[i][i] = 1;\n        if(i == 0) continue;\n        for(int j=1; j<i; j++)\n            C[i][j] = (C[i-1][j] % MOD + C[i-1][j-1] % MOD) % MOD;\n    }\n    //预处理逆元\n    Inv[1] = 1;\n    for(int i=2; i<N; i++)\n        Inv[i] = (MOD - MOD / i) * Inv[MOD % i] % MOD;\n    //预处理伯努利数\n    B[0] = 1;\n    for(int i=1; i<N; i++)\n    {\n        LL ans = 0;\n        if(i == N - 1) break;\n        for(int j=0; j<i; j++)\n        {\n            ans += C[i+1][j] * B[j];\n            ans %= MOD;\n        }\n        ans *= -Inv[i+1];\n        ans = (ans % MOD + MOD) % MOD;\n        B[i] = ans;\n    }\n}\n \nLL Work(int k)\n{\n    LL ans = Inv[k+1];\n    LL sum = 0;\n    for(int i=1; i<=k+1; i++)\n    {\n        sum += C[k+1][i] * Tmp[i] % MOD * B[k+1-i] % MOD;\n        sum %= MOD;\n    }\n    ans *= sum;\n    ans %= MOD;\n    return ans;\n}\n \nint main()\n{\n    int T;\n    Init();\n    scanf(\"%d\", &T);\n    while(T--)\n    {\n        int k;\n        scanf(\"%I64d %d\", &n, &k);\n        n %= MOD;\n        Tmp[0] = 1;\n        for(int i=1; i<N; i++)\n            Tmp[i] = Tmp[i-1] * (n + 1) % MOD;\n        printf(\"%I64d\\n\", Work(k));\n    }\n    return 0;\n}\n```\n\n\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 1e9+5;\nconst int MAXN = 2e3+5;\nconst LL MOD = 1e9+7;\nconst double eps = 1e-7;\nconst double PI = acos(-1);\nusing namespace std;\n\nLL c[MAXN][MAXN], Inv[MAXN], B[MAXN];\nvoid Exgcd(LL a, LL b, LL &x, LL &y)\n{\n    if(b == 0)\n    {\n        x = 1;\n        y = 0;\n        return ;\n    }\n    LL x1, y1;\n    Exgcd(b, a%b, x1, y1);\n    x = y1;\n    y = x1 - (a/b)*y1;\n}\n //预处理组合数\nvoid Get_Fac()\n{\n    for(int i=0; i<MAXN; i++)\n    {\n        c[i][0] = 1;\n        c[i][i] = 1;\n    }\n    for(int i=1; i<MAXN; i++)\n        for(int j=1; j<=i; j++)\n            c[i][j] = (c[i-1][j]+c[i-1][j-1])%MOD;\n}\n //预处理逆元\nvoid Get_Inv()\n{\n    for(int i=1; i<MAXN; i++)\n    {\n        LL x, y;\n        Exgcd(i, MOD, x, y);\n        x = (x%MOD+MOD)%MOD;\n        Inv[i] = x;\n    }\n}\nLL quick_MOD(LL a, LL b)\n{\n    LL ans = 1;\n    while(b)\n    {\n        if(b & 1)\n            ans = (ans*a)%MOD;\n        b>>=1;\n        a = (a*a)%MOD;\n    }\n    return ans;\n}\nvoid Get_Bonuli()\n{\n    B[0] = 1;\n    for(int i=1; i<MAXN-1; i++)\n    {\n        LL tmp = 0;\n        for(int j=0; j<i; j++)\n            tmp = (tmp+c[i+1][j]*B[j])%MOD;\n        B[i] = tmp;\n        B[i] = B[i]*(-Inv[i+1]);\n        B[i] = (B[i]%MOD+MOD)%MOD;\n    }\n}\nvoid Init()\n{\n    Get_Fac();\n    Get_Inv();\n    Get_Bonuli();\n}\nint main()\n{\n    Init();\n    int T, k;\n    LL n;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        scanf(\"%lld%d\",&n,&k);\n        n++;\n        n %= MOD;\n        LL ans = 0;\n        for(int i=1; i<=k+1; i++)\n        {\n            ans = (ans+((c[k+1][i]*B[k+1-i])%MOD)*quick_MOD(n,(LL)i))%MOD;\n            ans = (ans%MOD+MOD)%MOD;\n        }\n        ans = ans*Inv[k+1];\n        ans = (ans%MOD+MOD)%MOD;\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"乘法逆元模板","url":"/2018/08/03/乘法逆元模板/","content":"\n1. 扩展欧几里得\n\n```c++\nll ex_gcd(ll a,ll b,ll &x,ll &y)//扩展欧几里得（扩展gcd）\n{\n\tif (a==0&&b==0) return -1;\n\tif (b==0){x=1;y=0;return a;}\n\tll d=ex_gcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn d;\n}\n \nll mod_inverse(ll a,ll n)//乘法逆元，a与n必须互素\n{\n\tll x,y;\n\tll d = ex_gcd(a,n,x,y);\n\treturn (x%n+n)%n;\n}\n\n```\n\n2. 费马小定理，快速幂\n\n```c++\nint find(int x)  //x与mod互素，且mod为素数\n{  \n    int k=mod-2,ans=1;  \n    while(k)  \n    {  \n        if (k&1) ans=(ll)ans*x%mod;  \n        x=(ll)x*x%mod;  \n        k>>=1;  \n    }  \n    return ans;  \n}  \n//x在%mod下的逆元\n\n/*已知p是质数且gcd(a, p) = 1，则 ap-1 ≡ 1 (mod p),  所以 a*ap-2 ≡ 1 (mod p)。\na^(p-2)就是a的逆元了*/\n\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"高斯消元模板","url":"/2018/08/03/高斯消元模板/","content":"\n### 简单版本\n\n```c++\n（1）有解的方程组：\n#define N 205\nusing namespace std;\nconst double eps=1e-8;\nint n;\ndouble a[N][N],del;\nbool gauss(){\n    for(int i=1;i<=n;i++){\n        int k=i;\n        for(int j=i+1;j<=n;j++)if(fabs(a[j][i])>fabs(a[k][i]))k=j;\n        if(fabs(del=a[k][i])<eps)return 0;\n        for(int j=i;j<=n+1;j++)swap(a[i][j],a[k][j]);\n        for(int j=i;j<=n+1;j++)a[i][j]/=del;\n        for(k=1;k<=n;k++)if(k!=i){\n            del=a[k][i];\n            for(int j=i;j<=n+1;j++)a[k][j]-=a[i][j]*del;\n        }\n    }\n    return 1;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n+1;j++)scanf(\"%lf\",&a[i][j]);\n    bool flag=gauss();\n    if(!flag)puts(\"No Solution\");\n    else for(int i=1;i<=n;i++)printf(\"%.2lf\\n\",a[i][n+1]);\n    return 0;\n}\n```\n\n### kuangbin的模板\n\n```c++\n//来自kuangbin大神的模板\n#include<stdio.h>\n#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<math.h>\nusing namespace std;\n\nconst int MAXN=50;\n\nint a[MAXN][MAXN];//增广矩阵\nint x[MAXN];//解集\nbool free_x[MAXN];//标记是否是不确定的变元\n\n/*\nvoid Debug(void)\n{\n    int i, j;\n    for (i = 0; i < equ; i++)\n    {\n        for (j = 0; j < var + 1; j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n*/\n\n\ninline int gcd(int a,int b)\n{\n    int t;\n    while(b!=0)\n    {\n        t=b;\n        b=a%b;\n        a=t;\n    }\n    return a;\n}\ninline int lcm(int a,int b)\n{\n    return a/gcd(a,b)*b;//先除后乘防溢出\n}\n\n// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，\n//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)\n//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.\nint Gauss(int equ,int var)\n{\n    int i,j,k;\n    int max_r;// 当前这列绝对值最大的行.\n    int col;//当前处理的列\n    int ta,tb;\n    int LCM;\n    int temp;\n    int free_x_num;\n    int free_index;\n\n    for(int i=0;i<=var;i++)\n    {\n        x[i]=0;\n        free_x[i]=true;\n    }\n\n    //转换为阶梯阵.\n    col=0; // 当前处理的列\n    for(k = 0;k < equ && col < var;k++,col++)\n    {// 枚举当前处理的行.\n// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)\n        max_r=k;\n        for(i=k+1;i<equ;i++)\n        {\n            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;\n        }\n        if(max_r!=k)\n        {// 与第k行交换.\n            for(j=k;j<var+1;j++) swap(a[k][j],a[max_r][j]);\n        }\n        if(a[k][col]==0)\n        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.\n            k--;\n            continue;\n        }\n        for(i=k+1;i<equ;i++)\n        {// 枚举要删去的行.\n            if(a[i][col]!=0)\n            {\n                LCM = lcm(abs(a[i][col]),abs(a[k][col]));\n                ta = LCM/abs(a[i][col]);\n                tb = LCM/abs(a[k][col]);\n                if(a[i][col]*a[k][col]<0)tb=-tb;//异号的情况是相加\n                for(j=col;j<var+1;j++)\n                {\n                    a[i][j] = a[i][j]*ta-a[k][j]*tb;\n                }\n            }\n        }\n    }\n\n  //  Debug();\n\n    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).\n    for (i = k; i < equ; i++)\n    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.\n        if (a[i][col] != 0) return -1;\n    }\n    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.\n    // 且出现的行数即为自由变元的个数.\n    if (k < var)\n    {\n        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.\n        for (i = k - 1; i >= 0; i--)\n        {\n            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.\n            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.\n            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && free_x[j]) free_x_num++, free_index = j;\n            }\n            if (free_x_num > 1) continue; // 无法求解出确定的变元.\n            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.\n            temp = a[i][var];\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];\n            }\n            x[free_index] = temp / a[i][free_index]; // 求出该变元.\n            free_x[free_index] = 0; // 该变元是确定的.\n        }\n        return var - k; // 自由变元有var - k个.\n    }\n    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.\n    // 计算出Xn-1, Xn-2 ... X0.\n    for (i = var - 1; i >= 0; i--)\n    {\n        temp = a[i][var];\n        for (j = i + 1; j < var; j++)\n        {\n            if (a[i][j] != 0) temp -= a[i][j] * x[j];\n        }\n        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.\n        x[i] = temp / a[i][i];\n    }\n    return 0;\n}\nint main(void)\n{\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    int i, j;\n    int equ,var;\n    while (scanf(\"%d %d\", &equ, &var) != EOF)\n    {\n        memset(a, 0, sizeof(a));\n        for (i = 0; i < equ; i++)\n        {\n            for (j = 0; j < var + 1; j++)\n            {\n                scanf(\"%d\", &a[i][j]);\n            }\n        }\n//        Debug();\n        int free_num = Gauss(equ,var);\n        if (free_num == -1) printf(\"无解!\\n\");\n   else if (free_num == -2) printf(\"有浮点数解，无整数解!\\n\");\n        else if (free_num > 0)\n        {\n            printf(\"无穷多解! 自由变元个数为%d\\n\", free_num);\n            for (i = 0; i < var; i++)\n            {\n                if (free_x[i]) printf(\"x%d 是不确定的\\n\", i + 1);\n                else printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        else\n        {\n            for (i = 0; i < var; i++)\n            {\n                printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"Let Sudoku Rotate (dfs+剪枝)","url":"/2018/08/02/Let-Sudoku-Rotate-(dfs+剪枝)/","content":"\n# [Let Sudoku Rotate](http://acm.hdu.edu.cn/showproblem.php?pid=6341) \n\n## 题意\n\n数独，有一个16*16的数独 数独内的数字从0~E，一开始数独是完美的，可是有个人逆时针旋转了数独中的某几块（4x4），导致数独不完美了，给你这个旋转后的数独，要求还原他至少要再旋转几步？\n\n\n\n## 思路\n\ndfs+剪枝。\n\n写出下列几个操作：\n\n1. 顺时针旋转4*4的方块；\n2. 判断每行的总和是否都为120；\n3. 判断每行和每列的元素是否都不重复；\n4. dfs，由于一行块有4个分块，因此四重循环，同一个x分别对应y的起始：0，4，8，12，循环+1表示旋转次数+1，如果在2、3的判断中都满足这写要求，说明可以进行下一个x+4（起始行）块的旋转操作dfs，step+本次旋转的操作（i，j，k，l四重循环），要是不满足还是要继续。当x==16或者是step比当前已知的最小ans要大的时候都可以return。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nconst int INF = 0x3f3f3f3f;\nconst long long MOD =1e9+7;\ntypedef long long ll;\nchar m[20][20];\nchar cop[4][4];\nint ans=64;\nvoid print()\n{\n    printf(\"\\n\");\n    for(int i=0;i<16;i++,printf(\"\\n\"))\n        for(int j=0;j<16;j++)\n            printf(\"%c\",m[i][j]);\n    printf(\"\\n\");\n}\nint rol(int x,int y)\n{\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            cop[i][j]=m[x+3-j][y+i];\n    for(int i=0;i<4;i++)\n        for(int j=0;j<4;j++)\n            m[i+x][j+y]=cop[i][j];\n}\nbool sum(int x)\n{\n    for(int j=x;j<x+4;j++)\n    {\n        int temp=0;\n        for(int i=0;i<16;i++)\n        {\n            temp=temp+((m[x][i]>='0'&&m[x][i]<='9')?(m[x][i]-'0'):(m[x][i]-'A'+10));\n        }\n        if(temp!=120) return false;\n    }\n    return true;\n}\nbool multi(int x)\n{\n    int vis[16]={0};\n    for(int j=x;j<x+4;j++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<16;i++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n\n    for(int i=0;i<16;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        for(int j=0;j<=x+3;j++)\n        {\n            int temp=((m[j][i]>='0'&&m[j][i]<='9')?(m[j][i]-'0'):(m[j][i]-'A'+10));\n            vis[temp]++;\n            if(vis[temp]>1) return false;\n        }\n    }\n    return true;\n}\nvoid dfs(int x,int step)\n{\n    if(step>ans) return;\n    if(x==16)\n    {\n        ans=min(ans,step);return;\n    }\n    for(int i=0;i<4;i++,rol(x,0))\n    for(int j=0;j<4;j++,rol(x,4))\n    for(int k=0;k<4;k++,rol(x,8))\n    for(int l=0;l<4;l++,rol(x,12))\n    {\n        if(!(sum(x)&&multi(x))) continue;\n        dfs(x+4,step+i+j+k+l);\n    }\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        getchar();\n        for(int i=0;i<16;i++)\n            scanf(\"%s\",m[i]);\n        ans=64;\n        dfs(0,0);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["dfs"],"categories":["算法"]},{"title":"Ascending Rating（思维+单调队列）","url":"/2018/08/02/Ascending-Rating（思维+单调队列）/","content":"\n# [ Ascending Rating](http://acm.hdu.edu.cn/showproblem.php?pid=6319)\n\n## 题意\n\n 输入n,m,k,p,q,r,MOD,表示一个长度为n的数列，给你前k个数字，（后面的要根据递推式自己写），然后m表示一个[l,l+m]的区间，从l=1开始，在这个区间中有两个值，一个是MAX，一个是CNT，起始都为0，从区间的第一个数开始扫，如果扫到的数字比MAX大，让MAX=ai，并且CNT++。求的是$A =\\sum_{i=1}^{n-m+1}{MAX_i 异或i}$ , $B=\\sum_{i=1}^{n-m+1}{CNT_i 异或i}$\n\n思路是用一个单调队列从最后一个区间往前倒着维护，如果队列为空，则直接放入ai，若ai>=队首元素，则将队列中的元素全部弹出，同时将ai放入，若ai小于队首元素，则将队尾中小于ai的元素弹出，将ai放入队尾中，每一个区间的cnt值即为队列中元素的个数，而MAX值则为队首元素。如果队首元素的位置不在下一个区间范围内，则弹出。注意STL的双端队列会被卡，这里可以用数组直接模拟。（可以补一个正向写的，但是我WA到死，主要就是用单调栈来维护每一个数字右边的第一个比他大的位置，最后一个栈里的数的stack设为n+1，然后从右到左，dp[n-1]=1，dp[i]=dp[stack[i]]+1，………然后单调队列维护区间最大值）\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nlong long a[10000010];\nlong long que[20000010];\nint main()\n{\n    int t,n,m,k,p,q,r,MOD;\n    int size,front,rear;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        size=0;\n        front=rear=1e7+5;\n        scanf(\"%d%d%d%d%d%d%d\",&n,&m,&k,&p,&q,&r,&MOD);\n        for(int i=1;i<=k;i++)\n            scanf(\"%lld\",&a[i]);\n        for(int i=k+1;i<=n;i++)\n            a[i]=(1LL*p*a[i-1]+1LL*q*i+r)%MOD;\n        long long MAX=0,CNT=0;\n        for(int i=n;i>=1;i--)\n        {\n            if(size==0)\n            {\n                que[front]=i;size=1;\n            }\n            else\n            {\n                if(a[que[front]]<=a[i])\n                {\n                    front=rear=1e7+5;\n                    que[front]=i;\n                    size=1;\n                }\n                else\n                {\n                    while(size>0&&a[que[rear]]<=a[i])\n                        size--,rear--;\n                    que[rear+1]=i;rear++;\n                    size++;\n                }\n            }\n            if(i<=n-m+1)\n            {\n                MAX+=a[que[front]]^i;\n                CNT+=size^i;\n                while(que[front]>=(i+m-1))\n                    front++,size--;\n            }\n        }\n        printf(\"%lld %lld\\n\",MAX,CNT);\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Sum of the Line (容斥/莫比乌斯反演)","url":"/2018/08/02/Sum-of-the-Line-(容斥莫比乌斯反演)/","content":"\n# [Sum of the Line](https://nanti.jisuanke.com/t/28970) \n\n## 题意\n\n给你一个n，分析之后发现求的是所有gcd(n,i)=1（i<=n）的数的平方和。\n\n用容斥，先用公式$\\frac{n(n+1)(2n+1)}{6}$求出1~n的平方和，然后筛出sqrt(n)内的素数，并求出n的所有质因数，然后对于质因数的乘积tot，如果质因数的个数是奇数，就加上$tot^2*(1^2+2^2+3^2……+(n/tot)^2)$，是偶数就减去。\n\n或者用莫比乌斯反演来做\n\n\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 998244353\n#define MAXN 10000\nusing namespace std;\ntypedef long long ll;\nll pri[10010],num=0;\nbool vis[10010];\nvector<ll>pr;\nvoid init()\n{\n    ll i,j;\n    for(i=2;i<MAXN;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAXN&&i%pri[j]!=0;j++)\n            vis[i*pri[j]]=true;\n    }\n}\nvoid extgcd(ll a,ll b,ll d,ll &x,ll &y)\n{\n    if(b==0){d=a;x=1;y=0;}\n    else{extgcd(b,a%b,d,y,x);y=y-x*(a/b);}\n}\nll inverse(ll a,ll p)\n{\n    ll d,x,y;\n    extgcd(a,p,d,x,y);\n    return (x%p+p)%p;\n}\nint main()\n{\n    init();\n    int t;\n    ll n;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        pr.clear();\n        ll xs=inverse(6ll,MOD);\n        ll tot=(((n*(n+1))%MOD*(2*n+1))%MOD*xs)%MOD;\n        ll temp=n;\n        for(int i=0;i<num;i++)\n        {\n            if(temp%pri[i]==0)\n            {\n                pr.push_back(pri[i]);\n                while(temp%pri[i]==0)\n                    temp/=pri[i];\n            }\n        }\n        if(temp>1)pr.push_back(temp);\n        int len=pr.size();\n        ll ans=0;\n        for(int i=1;i<(1<<len);i++)\n        {\n            int cnt=0;//有几个1\n            ll d=1;\n            for(int j=0;j<len;j++)\n            {\n                int temp=i>>j&1;\n                if(temp==1)\n                {\n                    cnt++;d=d*pr[j];\n                }\n            }\n            ll gs=n/d;\n            ll g=(((gs*(gs+1))%MOD*(2*gs+1))%MOD*xs)%MOD;\n            if(cnt%2==0)ans=(ans-((d*d)%MOD*g)%MOD+MOD)%MOD;\n            else ans=(ans+((d*d)%MOD*g))%MOD;\n            }\n        }\n        printf(\"%lld\\n\",(tot-ans+MOD)%MOD);\n    }\n    return 0;\n}\n```\n\n","tags":["容斥"],"categories":["算法"]},{"title":"Teemo's reunited (曼哈顿距离，思维)","url":"/2018/08/02/Teemos-reunited-(曼哈顿距离，思维)/","content":"\n# [Teemo's reunited](https://nanti.jisuanke.com/t/29326) \n\n## 题意\n\n求的是其他所有的点到某一点的距离和的最小值，就是曼哈顿距离。\n\n>这题也是用“分治”，虽说题目要求的是曼哈顿距离，但是我们为什么真的就要一步到位的求呢，可以横纵坐标分开求，先x排序，然后遍历一遍，求出横坐标的距离，然后y排序，遍历一遍求出坐标的距离加在刚才求得的x的距离上，就是曼哈顿距离了。\n>\n>这里有一个非常巧妙但是其实很显而易见的东西：假定现在我们已经按x排好序了分别是ABC三个点，那么C到AB的距离和是|C-A|+|C-B|，又因为已经排序了，那么绝对值可以去掉，得(C-A)+(C-B)，那么就是2*C-(A+B)，也就是说一个点到它前面的点的距离的和等于它前面的点的个数乘以它的自己再减去前面所有点的和，到这里你是不是想到求一个数列的和的时候我们遍历一遍数列就得到了，通过这个方法我们用O(n)就得到了一个点到它前面的点的距离和，然后再倒着遍历一遍数列用相似的思想把它到它后面的点的距离再加上就行了。\n>\n>还有一种也是分开x,y排序求和，不过可以这么做：先直接求出最前面的点到所有点的距离，然后依次遍历数列，通过后面一个点跟前面一个点的关系，找出差值相减，就是了。不明白的话仔细想想或者画图看看。\n\n## 看！代码\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1000000000000007\nusing namespace std;\nstruct node{\n\tlong long x,y;\n\tlong long sum;\n}a[100005];\nbool cmp1(node a,node b)\n{\n\treturn a.x<b.x;\n}\nbool cmp2(node a,node b)\n{\n\treturn a.y<b.y;\n}\nint main(){\n\tint t,n;\n\tscanf(\"%d\",&n);\n\tlong long ans=INF;\n\tmemset(a,0,sizeof(0));\n\tfor(int i=0;i<n;i++)  \n        scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tsort(a,a+n,cmp1);\n\tlong long sum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum=i*a[i].x-sum;\n\t\tsum+=a[i].x;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].x;\n\t\tsum+=a[i].x;\n\t}\n\tsort(a,a+n,cmp2);\n\tsum=0;\n\tfor(int i=0;i<n;i++)\n    {\n\t\ta[i].sum+=i*a[i].y-sum;\n\t\tsum+=a[i].y;\n\t}\n\tsum=0;\n\tfor(int i=n-1;i>=0;i--)\n    {\n\t\ta[i].sum+=sum-(n-1-i)*a[i].y;\t\t\t\n\t\tsum+=a[i].y;\n\t\tans=min(ans,a[i].sum);\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Teemo's hard problem (dp)","url":"/2018/08/02/Teemos-hard-problem-(dp)/","content":"\n# [Teemo's hard problem](https://nanti.jisuanke.com/t/29204) \n\n## 题意\n\n题目意思是给你一个数列，你可以任意反转[L,R]，使得这个数列的非递减序列最长。\n\n\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nint a[2010];\nint pre[2010];//1的前缀长度（包括自己）\nint suf[2010];//2的后缀长度（包括自己）\nint dp[2005][2005][4];//[i,j]中以k结尾的最长非递增序列长度\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        memset(pre,0,sizeof(pre));\n        memset(suf,0,sizeof(suf));\n        memset(dp,0,sizeof(dp));\n        for(int i=1; i<=n; i++)\n        {\n            scanf(\"%d\",&a[i]);\n            if(a[i]==1)pre[i]=pre[i-1]+1;\n            else pre[i]=pre[i-1];\n        }\n        for(int i=n; i>=1; i--)\n        {\n            if(a[i]==2)suf[i]=suf[i+1]+1;\n            else suf[i]=suf[i+1];\n        }\n        for(int i=1; i<=n; i++)\n        {\n            dp[i][i][a[i]]=1;\n            for(int j=i+1; j<=n; j++)\n            {\n                if(a[j]==1)\n                {\n                    dp[i][j][1]=max(dp[i][j-1][1],dp[i][j-1][2])+1;\n                    dp[i][j][2]=dp[i][j-1][2];\n                }\n                else if(a[j]==2)\n                {\n                    dp[i][j][1]=dp[i][j-1][1];\n                    dp[i][j][2]=dp[i][j-1][2]+1;\n                }\n            }\n        }\n        int ans=0;\n        for(int i=1; i<=n; i++)\n            for(int j=i; j<=n; j++)\n            {\n                ans=max(ans,pre[i-1]+max(dp[i][j][1],dp[i][j][2])+suf[j+1]);\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["dp"],"categories":["算法"]},{"title":"Teemo's bad day  (并查集)","url":"/2018/08/02/Teemos-bad-day-(并查集)/","content":"\n# [Teemo's bad day](https://nanti.jisuanke.com/t/29203)  \n\n## 题意\n\n给两个相同长度的数组A，B，一次操作是改变A，B中相同的数字x为->y。如果A[i]=B[i]，i<=n，都成立，则完成。问最少的操作次数。\n\n裸并查集。find(a[i])!=find(b[i]),cnt++。\n\n## 看！代码\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[500010],b[500010];\nint fa[100010];\nint Find(int x)\n{\n    if(fa[x]==x)return x;\n    return fa[x]=Find(fa[x]);\n}\nvoid Union(int p,int q)\n{\n    int rp=Find(p),rq=Find(q);\n    if(rp!=rq)\n        fa[rp]=rq;\n}\nvoid init(int n)\n{\n    for(int i=0;i<100010;i++)\n        fa[i]=i;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,cnt=0;\n        scanf(\"%d\",&n);\n        init(n);\n        for(int i=0;i<n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d\",&b[i]);\n            if(a[i]==b[i]) continue;\n            if(Find(a[i])!=Find(b[i]))\n            {\n                cnt++;Union(a[i],b[i]);\n            }\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}\n```\n\n","tags":["并查集"],"categories":["算法"]},{"title":"Goblin Garden Guards  (思维)","url":"/2018/08/02/Goblin-Garden-Guards-(思维)/","content":"\n# [Goblin Garden Guards](https://nanti.jisuanke.com/t/28882)  \n\n## 题意\n\n给n个哥布林的位置（x，y），给出m个圆，对于每一个圆，输出最大的不在圆内的哥布林数目。\n\n由于哥布林的位置是整数，那么对于圆，可以预处理出距离圆心0~r范围内的x最大偏差值和y的最大偏差值，如果哥布林的x，y与圆心的偏差值有一者在最大偏差值之外，就cnt++。\n\n## 看！代码\n\n```c++\n//拿的队友的代码\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nstruct point\n{\n    int x,y;\n}p[100010];\nbool cmp(point a,point b)\n{\n    return a.y<b.y;\n}\nvector<int>v[100010];\nvector<int>d[110];\nvoid init()\n{\n    for(int r=1;r<=100;r++)\n        for(int i=0;i<=r;i++)\n            d[r].push_back((int)floor(sqrt(1.0*r*r-i*i)));\n}\nint main()\n{\n    init();\n    int g,m,x,y,r;\n    scanf(\"%d\",&g);\n    for(int i=0;i<g;i++)\n        scanf(\"%d%d\",&p[i].x,&p[i].y);\n    sort(p,p+g,cmp);\n    for(int i=0;i<g;i++)\n        v[p[i].x].push_back(p[i].y);\n    scanf(\"%d\",&m);\n    int ans=0;\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&x,&y,&r);\n        int left=max(0,x-r),right=min(10000,x+r);\n        for(int dd=left;dd<=right;dd++)//横坐标\n        {       \n            int c=abs(dd-x);\n            int yl=max(0,y-d[r][c]),yr=min(10000,y+d[r][c]);\n            int pos1=lower_bound(v[dd].begin(),v[dd].end(),yl)-v[dd].begin();\n            int pos2=upper_bound(v[dd].begin(),v[dd].end(),yr)-v[dd].begin();\n            v[dd].erase(v[dd].begin()+pos1,v[dd].begin()+pos2);\n            ans+=pos2-pos1;\n        }\n    }\n    printf(\"%d\\n\",g-ans);\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Entertainment Box (multiset+贪心)","url":"/2018/08/02/Entertainment-Box-(multiset+贪心)/","content":"\n# [Entertainment Box](https://nanti.jisuanke.com/t/28880)  \n\n## 题意\n\nn个节目，k个录像带，给出每个节目的播放时间，求最多能录几个节目。\n\n用multiset维护当前正在录制的所有节目的结束时间，二分找到最接近下一个要录的节目的起始时间且小于起始时间的录像带，把这个录像带中的r替换成下一个要录的节目，cnt++，如果没有找到并且集合的size还不到k个的话，就直接把r放进去，cnt++。最后输出cnt。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nstruct node\n{\n    int l,r;\n} nn[N];\nbool cmp(node a,node b)\n{\n    if(a.r==b.r)\n        return a.l<b.l;\n    return a.r<b.r;\n}\n\nmultiset<int>q;\nmultiset<int>::iterator pos;\nint main()\n{\n    int n,k;\n    int cnt=0;\n    int i;\n    scanf(\"%d%d\",&n,&k);\n    for(int i=0; i<n; i++)\n        scanf(\"%d%d\",&nn[i].l,&nn[i].r);\n    sort(nn,nn+n,cmp);\n    for(i=0; i<n; i++)\n    {\n        if(q.empty())\n        {\n            cnt++;q.insert(nn[i].r);\n            continue;\n        }\n        if(*q.begin()>nn[i].l)\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n            continue;\n        }\n        pos=q.upper_bound(nn[i].l);\n        pos--;\n        if(*pos<=nn[i].l)\n        {\n            cnt++;\n            q.erase(pos);\n            q.insert(nn[i].r);\n        }\n        else\n        {\n            if(q.size()<k)\n            {\n                cnt++;q.insert(nn[i].r);\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    return 0;\n}\n```\n\n","tags":["贪心"],"categories":["算法"]},{"title":"Bell Ringing  (全排列的邻位构造法)","url":"/2018/08/02/Bell-Ringing-(全排列的邻位构造法)/","content":"\n# [Bell Ringing](https://nanti.jisuanke.com/t/28877)  \n\n用生成全排列的邻位互换法：（具体方法解释可以看排列组合的文章）\n\n> 仔细想想不就是把n插入到已完成的n-1阶排列的不同位置中得到n阶排列吗？\n\nn=1; 1\n\nn=2; 12 , 21\n\nn=3; 123, 132, 312, 321, 231, 213\n\n……\n\n用这种方法可以产生出任意n阶全排列，（而且符合bellring中的移动规律，即每个数移动的位置最多为1，就能一下子构造出n！个不重复的全排列）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint A[15];\nint dir[15];\n\nvoid print()\n{\n    for(int i=1;i<n;i++)\n        printf(\"%d \",A[i]);\n    printf(\"%d\\n\",A[n]);\n}\nbool IF_Active(int i) //判断是否活跃（前面的数字比它小就是活跃）\n{\n    if(i+dir[i]<=0||i+dir[i]>n)\n        return false;\n    if(A[i+dir[i]]<A[i])\n        return true;\n    return false;\n}\n\nint MAX_Active() //找到最大的活跃数字\n{\n    int id=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(IF_Active(i)&&A[id]<A[i])\n            id=i;\n    }\n    return id;\n}\nint Swap(int i) //交换最大的活跃数字和它前面的那个数字，注意方向也要交换\n{\n    int c=A[i];\n    A[i]=A[i+dir[i]];\n    A[i+dir[i]]=c;\n\n    c=dir[i];\n    dir[i]=dir[i+c];\n    dir[i+c]=c;\n\n    return i+c;\n}\nvoid UPdate(int index)\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(A[index]<A[i])\n            dir[i]=-dir[i];\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        A[i]=i;\n        dir[i]=-1;\n    }\n    print();\n    \n    while(1)\n    {\n        int id=MAX_Active();\n        if(id==n+1) break;\n        id=Swap(id);\n        UPdate(id);\n        print();\n    }\n    return 0;\n}\n```\n\n","tags":["排列组合"],"categories":["算法"]},{"title":" Road(floyd+思维)","url":"/2018/08/02/Road(floyd+思维)/","content":"\n# [Road](https://nanti.jisuanke.com/t/28875)\n\n## 题意\n\n连通图，删去尽可能多的路，使得每个城市到第0号城市的最短路长度不变，求可能的方案数量。\n\n用floyd先求出每个城市之间的最短路，然后对每条0~i城市的最短路，判断0~j城市的距离加上i到j的原始距离是否还和最短路相等，相等的话，在j城市上的最短路径+1。最后将他们乘起来。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=350;\nconst long long MOD=1e9+7;\nint dist[maxn],g[maxn][maxn],f[maxn][maxn],N;\nlong long road[maxn];\nlong long floyd()\n{\n    long long ans=1;\n    memset(road,0,sizeof(road));\n\n    for (int k=0;k<N;k++)\n        for (int i=0;i<N;i++)\n            for (int j=0;j<N;j++)\n                if (i!=k&&i!=j&&j!=k)\n                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    g[0][0]=0;\n    for(int i=0;i<N;i++)\n        for(int j=0;j<N;j++)\n        if(i!=j&&g[0][i]+f[i][j]==g[0][j])\n    {\n        road[j]++;\n    }\n    for(int i=1;i<N;i++)\n        if(road[i])\n            ans=(ans*road[i])%MOD;\n    return ans;\n\nint main()\n{\n    while(scanf(\"%d\",&N)!=EOF)\n    {\n        memset(g,INF,sizeof(g));\n        string s;\n        for(int i=0;i<N;i++)\n        {\n            cin>>s;\n            for(int j=0;j<s.size();j++)\n            {\n                if(s[j]=='0')\n                    f[i][j]=g[i][j]=INF;\n                else\n                \tf[i][j]=g[i][j]=s[j]-'0';\n            }\n        }\n        printf(\"%lld\\n\",floyd());\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":" Swaps and Inversions  (归并排序)","url":"/2018/08/02/Swaps-and-Inversions-(归并排序)/","content":"\n# [ Swaps and Inversions](http://acm.hdu.edu.cn/showproblem.php?pid=6318)  \n\n## 题意\n\n数逆序数对，再乘以min(x,y)即可。这里我发现逆序数对数有x个，就可以通过交换相邻数字x次使得它不存在逆序数。\n\n用归并排序可以得到逆序数对个数。\n\n## 看！代码\n\n```c++\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nlong long sum;\nint a[500005];\nint temp[500005];\nvoid sort2(int a[],int l,int mid,int r)\n{\n    int i=l,j=mid+1,k=0;\n    while(i<=mid&&j<=r)\n    {\n        if(a[i]<=a[j])\n        {\n            temp[k++]=a[i++];\n        }\n        else\n        {\n            temp[k++]=a[j++];\n            sum+=mid-i+1;\n        }\n    }\n    while(i<=mid)  temp[k++]=a[i++];\n    while(j<=r)    temp[k++]=a[j++];\n\n    for(int i=l,k=0; i<=r; k++,i++)\n        a[i]=temp[k];\n}\n\nvoid sort1(int a[],int l,int r)\n{\n    int mid;\n    if(l<r)\n    {\n        mid=(l+r)/2;\n        sort1(a,l,mid);\n        sort1(a,mid+1,r);\n        sort2(a,l,mid,r);\n    }\n}\nint main()\n{\n    int n;\n    long long x,y;\n    while(scanf(\"%d%lld%lld\",&n,&x,&y)!=EOF)\n    {\n        sum=0;\n        for(int i=0; i<n; i++)\n            scanf(\"%d\",&a[i]);\n        sort1(a,0,n-1);\n        printf(\"%lld\\n\",sum*min(x,y));\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Distinct Values (set思维构造)","url":"/2018/08/02/Distinct-Values-(set思维构造)/","content":"\n# [Distinct Values](http://acm.hdu.edu.cn/showproblem.php?pid=6301) \n\n## 题意\n\n给你一个n，一个q，表示数列中有n个元素，q个区间询问，每次一个[l,r]，表示此区间内的数字不能有重复，要求输出最小字典序的。\n\n## 思路\n\n先对区间进行排序，按照l从小到大，另外，如果有相同l的，按r从大到小。\n\n然后用set维护可以放在此区间的数字。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbool cmp(pair<int,int>a,pair<int,int>b)\n{\n    if(a.first==b.first)\n        return a.second>b.second;\n    return a.first<b.first;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        int n,q,l,r;\n        scanf(\"%d%d\",&n,&q);\n        set<int>val;\n        vector<pair<int,int> >p;\n        vector<int>x(n+5);\n        for(int i = 1 ;i <= n ; i++)\n            p.push_back( make_pair(i,i) );\n        for(int i=1;i<=n;i++)\n            val.insert(i);\n        for(int i=1;i<=n;i++)\n            x[i]=1;\n        for(int i=0;i<q;i++)\n        {\n            scanf(\"%d%d\",&l,&r);\n            p.push_back(make_pair(l,r));\n        }\n        sort(p.begin(),p.end());\n        int left=1,cur=1;\n        set<int>::iterator it,bef;\n        for(int i=0;i<p.size();i++)\n        {\n            while(left<p[i].first)\n                val.insert(x[left++]);\n            for(it=val.begin();it!=val.end()&&cur<=p[i].second;)\n            {\n                x[cur++]=*it;\n                int s=*it;\n                it++;\n                val.erase(s);\n            }\n        }\n        for(int i=1;i<=n-1;i++)\n            printf(\"%d \",x[i]);\n        printf(\"%d\\n\",x[n]);\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"Divisions(大整数分解)","url":"/2018/08/02/Divisions(大整数分解)/","content":"\n# [Divisions](https://nanti.jisuanke.com/t/28395) \n\n## 思路\n\n输入一个整数，输出他的因子个数。n<=1e18\n\nPollard-Rho算法 随机算法 \n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nusing namespace std;\nconst int S=20;//随机算法判定次数，S越大，判错概率越小\n//计算 (a*b)%c.   a,b都是long long的数，直接相乘可能溢出的\n//  a,b,c <2^63\nlong long mult_mod(long long a,long long b,long long c)\n{\n    a%=c;\n    b%=c;\n    long long ret=0;\n    while(b)\n    {\n        if(b&1){ret+=a;ret%=c;}\n        a<<=1;\n        if(a>=c)a%=c;\n        b>>=1;\n    }\n    return ret;\n}\n\n\n//计算  x^n %c\nlong long pow_mod(long long x,long long n,long long mod)//x^n%c\n{\n    if(n==1)return x%mod;\n    x%=mod;\n    long long tmp=x;\n    long long ret=1;\n    while(n)\n    {\n        if(n&1) ret=mult_mod(ret,tmp,mod);\n        tmp=mult_mod(tmp,tmp,mod);\n        n>>=1;\n    }\n    return ret;\n}\n\n\n//以a为基,n-1=x*2^t      a^(n-1)=1(mod n)  验证n是不是合数\n//一定是合数返回true,不一定返回false\nbool check(long long a,long long n,long long x,long long t)\n{\n    long long ret=pow_mod(a,x,n);\n    long long last=ret;\n    for(int i=1;i<=t;i++)\n    {\n        ret=mult_mod(ret,ret,n);\n        if(ret==1&&last!=1&&last!=n-1) return true;//合数\n        last=ret;\n    }\n    if(ret!=1) return true;\n    return false;\n}\n\n// Miller_Rabin()算法素数判定\n//是素数返回true.(可能是伪素数，但概率极小)\n//合数返回false;\n\nbool Miller_Rabin(long long n)\n{\n    if(n<2)return false;\n    if(n==2)return true;\n    if((n&1)==0) return false;//偶数\n    long long x=n-1;\n    long long t=0;\n    while((x&1)==0){x>>=1;t++;}\n    for(int i=0;i<S;i++)\n    {\n        long long a=rand()%(n-1)+1;//rand()需要stdlib.h头文件\n        if(check(a,n,x,t))\n            return false;//合数\n    }\n    return true;\n}\n\n\n//************************************************\n//pollard_rho 算法进行质因数分解\n//************************************************\nmap<ll,int>factor;//质因数分解结果（刚返回时是无序的）\n\nlong long gcd(long long a,long long b)\n{\n    if(a==0)return 1;//???????\n    if(a<0) return gcd(-a,b);\n    while(b)\n    {\n        long long t=a%b;\n        a=b;\n        b=t;\n    }\n    return a;\n}\n\nlong long Pollard_rho(long long x,long long c)\n{\n    long long i=1,k=2;\n    long long x0=rand()%x;\n    long long y=x0;\n    while(1)\n    {\n        i++;\n        x0=(mult_mod(x0,x0,x)+c)%x;\n        long long d=gcd(y-x0,x);\n        if(d!=1&&d!=x) return d;\n        if(y==x0) return x;\n        if(i==k){y=x0;k+=k;}\n    }\n}\n//对n进行素因子分解\nvoid findfac(long long n)\n{\n    if(Miller_Rabin(n))//素数\n    {\n        factor[n]++;\n        return;\n    }\n    long long p=n;\n    while(p>=n)p=Pollard_rho(p,rand()%(n-1)+1);\n    findfac(p);\n    findfac(n/p);\n}\n\nint main()\n{\n    srand(time(NULL));//需要time.h头文件//POJ上G++不能加这句话\n    long long n;\n    scanf(\"%lld\",&n);\n    if(n==1){printf(\"1\\n\");return 0;}\n    findfac(n);\n    ll ans=1;\n    for(auto it=factor.begin();it!=factor.end();it++)\n        ans*=(it->second+1);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```\n\n","tags":["大数分解"],"categories":["算法"]},{"title":"Change of Scenery（次短路）","url":"/2018/08/02/Change-of-Scenery（次短路）/","content":"\n# [Change of Scenery](https://nanti.jisuanke.com/t/28394) \n\n# 题意\n\n求是否存在一条不同于最短路但长度相同的路。\n\n1. 求次短路是否等于最短路\n2. dijstra的时候标记一下\n\n## 看！代码\n\n```c++\n//求次短\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#define MAXN (10000 + 10)\n#define INF (5000*5000*2)\nusing namespace std;\n\nstruct edge\n{\n    int to, cost;\n    edge(int tv = 0, int tc = 0):\n        to(tv), cost(tc) {}\n};\ntypedef pair<int,int> P;\nint N, R;\nvector<edge> graph[MAXN];\nint dist[MAXN];     //最短距离\nint dist2[MAXN];    //次短距离\n\nvoid solve()\n{\n    fill(dist, dist+N, INF);\n    fill(dist2, dist2+N, INF);\n    //从小到大的优先队列\n    //使用pair而不用edge结构体\n    //是因为这样我们不需要重载运算符\n    //pair是以first为主关键字进行排序\n    priority_queue<P, vector<P>, greater<P> > Q;\n    //初始化源点信息\n    dist[0] = 0;\n    Q.push(P(0, 0));\n    //同时求解最短路和次短路\n    while(!Q.empty())\n    {\n        P p = Q.top();\n        Q.pop();\n        //first为s->to的距离，second为edge结构体的to\n        int v = p.second, d = p.first;\n        //当取出的值不是当前最短距离或次短距离，就舍弃他\n        if(dist2[v] < d) continue;\n        for(unsigned i = 0; i < graph[v].size(); i++)\n        {\n            edge &e = graph[v][i];\n            int d2 = d + e.cost;\n            if(dist[e.to] > d2)\n            {\n                swap(dist[e.to], d2);\n                Q.push(P(dist[e.to], e.to));\n            }\n            if(dist2[e.to] > d2 && dist[v] < d2)\n            {\n                dist2[e.to] = d2;\n                Q.push(P(dist2[e.to], e.to));\n            }\n        }\n    }\n}\nint main()\n{\n    int A, B, D,K;\n    scanf(\"%d%d%d\", &N, &R,&K);\n    while(K--)\n        scanf(\"%d\",&A);\n    for(int i = 0; i < R; i++)\n    {\n        scanf(\"%d%d%d\", &A, &B, &D);\n        graph[A-1].push_back(edge(B-1, D));\n        graph[B-1].push_back(edge(A-1, D));\n    }\n    solve();\n    if(dist2[N-1]==dist[N-1])\n        printf(\"yes\\n\");\n    else\n        printf(\"no\\n\");\n    return 0;\n}\n```\n\n","tags":["次短路"],"categories":["算法"]},{"title":"Bounty Hunter II（最小路径覆盖）","url":"/2018/08/02/Bounty-Hunter-II（最小路径覆盖）/","content":"\n# [Bounty Hunter II](https://nanti.jisuanke.com/t/28391) \n\n## 题意\n\n求最小路径覆盖数（不交叉），套最大流模板即可。\n\n结点总数-匹配数=覆盖数\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=5010;\nconst int M=3000010;\nconst int inf=0x3f3f3f3f;\nstruct Edge\n{\n    int v,cap,nxt;\n}e[M];;//邻接表要开边数的两倍\nint src,des,dis[N],head[N],ecnt;  //memset dis,head-1 ecnt=0,src=0,des=2*n+1;\nint n,m;\nvoid Addedge(int u,int v,int w)\n{\n    e[ecnt].v=v;\n    e[ecnt].cap=w;\n    e[ecnt].nxt=head[u];\n    head[u]=ecnt++;\n    e[ecnt].v=u;\n    e[ecnt].cap=0;\n    e[ecnt].nxt=head[v];\n    head[v]=ecnt++;\n}\nbool Bfs()\n{\n    queue<int>q;\n    q.push(src);\n    memset(dis,-1,sizeof(dis));\n    dis[src]=0;\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();\n        for(int i=head[u];~i;i=e[i].nxt)\n        {\n            int v=e[i].v;\n            if(e[i].cap>0&&dis[v]==-1)\n            {\n                dis[v]=dis[u]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[des]>=0;\n}\nint Dfs(int u,int a)\n{\n    if(u==des) return a;\n    for(int i=head[u];~i;i=e[i].nxt)\n    {\n        int v=e[i].v,t=0;\n        if(e[i].cap>0&&dis[v]==dis[u]+1&&(t=Dfs(v,min(a,e[i].cap))))\n        {\n            e[i].cap-=t;\n            e[i^1].cap+=t;\n            return t;\n        }\n    }\n    dis[u]=-1;\n    return 0;\n}\nint Dinic()\n{\n    int ans=0;\n    while(Bfs())\n    {\n        int t=0;\n        while(t=Dfs(src,inf)) ans+=t;\n    }\n    return ans;\n}\nint main()\n{\n    int num,u,v;\n    ecnt=0;\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&num);\n    src=0;des=2*num+1;\n    for(int i=1;i<=num;i++)\n        Addedge(0,i,1);\n    for(int i=num+1;i<=2*num;i++)\n        Addedge(i,2*num+1,1);\n    for(int i=1;i<=num;i++)\n    {\n        scanf(\"%d\",&u);\n        while(u--)\n        {\n            scanf(\"%d\",&v);\n            Addedge(i,num+v+1,1);\n        }\n    }\n    n=num+2;\n    printf(\"%d\\n\",num-Dinic());\n    return 0;\n}\n```\n\n","tags":["网络流"],"categories":["算法"]},{"title":"HDU 6315 Naive Operations(线段树)","url":"/2018/07/29/HDU 6315 Naive Operations/","content":"\n\n\n[HDU 6315 Naive Operations](http://acm.hdu.edu.cn/showproblem.php?pid=6315)\n\nn个数，q个询问\n\n起始a、b数组都是n个元素，a数组全是0，b是1~n的全排列\n\nadd l r  ：a中【l，r】都加1\n\nquery l r ：询问∑floor(ai/bi) (i : l~r)\n\n思路：\n\n区间更新的线段树，维护区间最小值min（bi-ai%bi） 当min=0时sum++。\n\n具体看代码注释\n\n```c++\n#include <bits/stdc++.h>\n#define MAXN 100010\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct node{\n    long long l,r;//区间[l,r]\n    long long add;//区间的延时标记\n    long long sum;//区间和\n    long long mn; //区间最小值\n    long long bi; //对应bi\n}tree[MAXN<<2];//一定要开到4倍多的空间\n\nvoid pushup(int index)\n{\n    tree[index].sum = tree[index<<1].sum+tree[index<<1|1].sum;\n    tree[index].mn = min(tree[index<<1].mn,tree[index<<1|1].mn);\n}\nvoid pushdown(int index)\n{\n    //说明该区间之前更新过\n    //要想更新该区间下面的子区间，就要把上次更新该区间的值向下更新\n    if(tree[index].add)\n    {\n        tree[index<<1].mn -= tree[index].add;\n        tree[index<<1|1].mn -= tree[index].add;\n        tree[index<<1].add += tree[index].add;\n        tree[index<<1|1].add += tree[index].add;\n        tree[index].add = 0;\n    }\n}\nvoid print(int l,int r,int index) //测试数据 输出具体\n{\n    printf(\"l:%d r:%d bi:%lld min:%lld sum:%lld lazy:%d\\n\",l,r,tree[index].bi,tree[index].mn,tree[index].sum,tree[index].add);\n    if(tree[index].l==tree[index].r)\n    {\n         return;\n    }\n    int mid=(l+r)>>1;\n    print(l,mid,index<<1);\n    print(mid+1,r,index<<1|1);\n}\nvoid build(int l,int r,int index)\n{\n    tree[index].l = l;\n    tree[index].r = r;\n    tree[index].add = 0;//刚开始一定要清0\n    tree[index].sum=0;\n    if(l == r)\n    {\n        scanf(\"%lld\",&tree[index].bi);\n        tree[index].mn = tree[index].bi;\n        tree[index].sum=0;\n        return ;\n    }\n    int mid = (l+r)>>1;\n    build(l,mid,index<<1);\n    build(mid+1,r,index<<1|1);\n    pushup(index);\n}\nvoid updata(int l,int r,int index)\n{\n    if(l<=tree[index].l&&r>=tree[index].r&&tree[index].mn>1) \n    {\n        tree[index].mn--;\n        tree[index].add++;\n        return ;\n    }\n    if(tree[index].l==tree[index].r)\n    {\n        tree[index].mn--;\n        tree[index].add++;\n        if(tree[index].mn<=0)\n        {\n            tree[index].sum++;\n            tree[index].mn=tree[index].bi;\n        }\n        return ;\n    }\n    pushdown(index);\n    int mid = (tree[index].l+tree[index].r)>>1;\n\n    if (r <= mid) updata(l,r,index<<1);\n    else if (l>mid) updata(l,r,index<<1|1);\n    else {\n        updata(l,mid,index<<1);\n        updata(mid+1,r,index<<1|1);\n    }\n\n    pushup(index);\n}\nlong long query(int l,int r,int index)\n{\n    if(l == tree[index].l && r == tree[index].r)\n        return tree[index].sum;\n\n    pushdown(index);\n    int mid = (tree[index].l+tree[index].r)>>1;\n    long long ans = 0;\n    if(r<=mid) ans = query(l,r,index<<1);\n    else if(l>mid) ans = query(l,r,index<<1|1);\n    else{\n        return ans = query(l,mid,index<<1)+query(mid+1,r,index<<1|1);\n    }\n    pushup(index);\n    return ans;\n}\nint main()\n{\n    int n,m,q,x,y,z;\n    char s[100];\n    while(~scanf(\"%d%d\",&n,&m)){\n    build(1,n,1);\n    while(m--)\n    {\n        scanf(\"%s%d%d\",s,&x,&y);\n        if(s[0] =='q' )\n            printf(\"%lld\\n\",query(x,y,1));\n        else\n            updata(x,y,1);\n    //    print(1,n,1);\n     //   printf(\"m:%d\\n\",m);\n    }\n    }\n    return 0;\n}\n/*\n5 12\n1 5 2 4 3\nadd 1 4\nquery 1 4\nadd 2 5\nquery 2 5\nadd 3 5\nquery 1 5\nadd 2 4\nquery 1 4\nadd 2 5\nquery 2 5\nadd 2 2\nquery 1 5\n*/\n\n```\n\n","tags":["线段树"],"categories":["算法"]},{"title":"测时间","url":"/2018/06/05/测时间/","content":"\n\n\n```c++\n#include<iostream>\n#include<windows.h>\nint main()\n{\n    DWORD start_time=GetTickCount();\n    {\n        //此处为被测试代码\n    }\n    DWORD end_time=GetTickCount();\n    cout<<\"The run time is:\"<<(end_time-start_time)<<\"ms!\"<<endl;//输出运行时间\n    return 0;\n}\n\n```\n\n","tags":["模板"],"categories":["算法"]},{"title":"飞行员配对(最大流模板)","url":"/2018/05/11/2018-05-11-飞行员配对(最大流模板)/","content":"\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int MAXN = 201;\n\nint g[MAXN][MAXN];        //残留网络，初始为原图\nint flow[MAXN][MAXN];\nint nodeNum;            //节点总数量\nint pre[MAXN];\n\n//bfs找增广路\nint bfs(const int &s, const int &t)\n{\n    int que[201],p,q,v,i;\n    for (i=0;i<=nodeNum+1;i++)\n        pre[i]=-1;\n    que[0]=s;\n    pre[s]=s;\n    p=0,q=1;\n    while(p<q)\n    {\n        v=que[p++];\n        for(i=0;i<=nodeNum+1;i++)\n            if (pre[i]==-1&&(flow[v][i]<g[v][i]||flow[i][v]>0))\n            {\n                pre[i]=v;\n                que[q++]=i;\n                if (i==t) return 1;\n            }\n    }\n    return 0;\n}\n\n//修改残留矩阵和增广路\nvoid track_back(const int &s, const int &t)\n{\n    int i=t,v,MIN=INF;\n    while (i!=s)\n    {\n        v = pre[i];\n        if (flow[v][i]<g[v][i])\n        {\n            if(MIN>g[v][i]-flow[v][i])\n                MIN=g[v][i]-flow[v][i];\n        }\n        else if (flow[i][v]>0)\n        {\n            if(MIN>flow[i][v])\n                MIN=flow[i][v];\n        }\n        i=v;\n    }\n    i=t;\n    while (i!=s)\n    {\n        v = pre[i];\n        if (flow[v][i]<g[v][i])\n            flow[v][i]+=MIN;\n        else if (flow[i][v]>0)\n            flow[i][v]-= MIN;\n        i = v;\n    }\n}\n\n//返回 从节点s到节点t的最大流\nint max_flow(const int &s, const int &t)\n{\n    while (bfs(s,t))\n        track_back(s,t);\n    int res=0,i;\n    for (i=0;i<=nodeNum+1;i++)\n        if (i!=s)res+=flow[s][i];\n    return res;\n}\n\nint main()\n{\n    int m,b,e,c;\n    scanf(\"%d%d\",&m,&nodeNum);\n    memset(g,0,sizeof(g));\n    memset(flow,0,sizeof(flow));\n    while (scanf(\"%d%d\",&b,&e))\n    {\n        if(b==-1&&e==-1) break;\n        g[e][b]=1;\n    }\n    for(int i=1;i<=m;i++)\n        g[i][nodeNum+1]=1;\n\n    for(int i=m+1;i<=nodeNum;i++)\n        g[0][i]=1;\n\n    printf(\"%d\\n\",max_flow(0,nodeNum+1));\n    return 0;\n}\n\n\n```\n\n","tags":["网络流"],"categories":["算法"]},{"title":"我依赖成瘾了的你","url":"/2018/04/24/2018-04-24-我依赖成瘾了的你/","content":"\n<img src=\"https://xheartbeat.top/mdpicture/他.jpg\" alt=\"我依赖成瘾了的你，想念你，记挂你\">\n\n他回家了，从今天开始，我们两个人就是半个小时的异地恋。\n\n在一起的这一年，我们吵过无数次的架，觉得自己委屈，觉得他没有那么爱自己了，为什么他要乱发脾气，好多好多的想起来就头疼的回忆，也后悔过很多，怎么两个人在一起久了，就变得有些小单调了呢？我还是很爱吃醋，不喜欢你身边围着太多的人，又希望你玩的开心，又希望你也能时时刻刻想起我，只做我一个人的小可爱。啊，变得自私又刻薄。还是心甘情愿。\n\n也是他让我的大学生活与众不同。我们看很多很多部电影，吃不一样的美食，在家里烧烤到烟雾缭绕，煮着火锅，吃着水泡饭就着酱瓜，还有黄豆酱，没钱的时候买了一大筒挂面，连吃几天的雪菜面，我们去不同的地方，做不同的事情，走在街上，光明正大的牵你的手，晚上一起骑车回家，路过跳着广场舞的大妈，在网吧过夜，在车上睡觉，和他在一起，做了数不清的稀奇古怪的事情，又是那么意义非凡，一桩桩一件件，是我的最美好的一年。尤其是在寒冷的夜晚相拥而眠，比较遗憾的是某人是屁精，总是放很臭很臭的屁给我闻，早上醒来第一眼看到的人，晚上最后说晚安的人，三百六十五天过的飞快，我都反应不过来。\n\n中午下了他的车，看着车屁股离开，心里陈杂，然后又匆匆赶去教室，没有想他的机会，直到晚上选修课看了那部电影《托斯卡纳艳阳下》，在漆黑的教室里挂不住的眼泪流下来，赶紧擦去了，怕身旁的人看到，是没有泪点的片段，可我却看得感同身受，“我一个人住这么大的房子干什么呢”，又羡慕着他们的幸福。然后一回到出租屋就哭了，想念是一件止不住的事。然后哭的停不下来才发现，他是我活到这把年纪，头一个，让我想到掉眼泪的人。\n\n哭泣的时候，我有好多好多好多好多的话想要说，想要写下来，听他讲了那么多之后，写到这里，我就不知道下一句应该接什么了。\n\n他真的很好很好，我没有选错人。\n\n“想要告诉身边每一个人，我在和你谈恋爱”\n\n“我心里是真的好爱你”\n\n“在一起不觉得什么，只是平常，一分开好难受”\n\n“一直想要你不要难过，想要你自己一个人好好过”\n\n“可是我都劝不住自己的心，空荡荡的”\n\n“既然分开，以后一定会给你幸福的生活，每天都抱在一起睡，肉贴肉”\n\n“想要什么我都会给你”\n\n“谢谢你一直以来忍受我那么久的坏脾气”\n\n“或许是因为知道你很爱我，不会离开我，才那么肆无忌惮”\n\n“可是真的离开了，真想以前要对你好一点”\n\n“我现在一无所有，什么都不能给你，不能一直这样”\n\n“以后我们的日子还很长很长，我要让你在以后的日子里，都很幸福”\n\n“坐自行车，在出租房，那不是幸福”\n\n“我要和你有一个完整的家”\n\n“晚安，我的老婆”\n\n恩，老公是生命之光，晚安，我的小可爱。\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"网络流 【待续】","url":"/2018/04/23/2018-04-23-网络流/","content":"\n例如：有一个自来水管道输送系统，起点是S，目标是T，图中经过的管道都有一个最大的容量：\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E6%B0%B4%E7%AE%A1%E6%B5%81%E9%87%8F.jpg\" alt=\"水管流量最大该是多少呢\"/>\n\n## 网络流的定义\n\n在有向图G=（V,E）中：\n\n1、有唯一的一个源点S（入度为0：出发点）\n\n2、有唯一的一个汇点（出度为0：结束点）\n\n3、图中的每条弧（u,v）都有一个非负的容量c（u,v）\n\n满足上述条件的图G称为网络流图。\n\n记为：G=（V,E,C）\n\n<!--more-->\n\n### 可行流\n\n每条管道中可以通过的流量。\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E5%8F%AF%E8%A1%8C%E6%B5%81.JPG\" alt=\"可行流\"/>\n\n### 最大流\n\n在所有的可行流中，流量最大的一个流。（最大流可能不止一个）\n\n解决最大流的问题常用到Ford-Fulkerson方法（在此方法下，存在着若干种不同时间复杂度下的实现）\n\n#### Ford-Fulkerson和Edmonds-Karp\n\n1、残存网络\n\n第一个图是流网络，边上的12/16,12指的是流量，16是容量。\n\n第二个图是残存网络，可能会存在一对相反的边，如刚刚12/16在残存网络中，体现为 v1->s = 12，s->v1 = 16-12。与流网络中对应的边代表的是该边的残余容量，流网络中不存在的边是一条反向的已有流量边，这部分流量**可以通过回流减少**。（残存网络中值为0的边不画出）\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E6%AE%8B%E4%BD%99%E7%BD%91%E7%BB%9C.JPG\" alt=\"残存网络和流网络对比\">\n\n2、增广路径\n\n假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量<容量，注意，是严格的<,而不是<=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。\n\n3、方法\n\n我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。**当找不到增广路的时候，当前的流量就是最大流**，这个结论非常重要。\n\n<!--而Ford-Fulkerson方法和Edmonds-Karp的区别就是在寻找增广路时，前者是随便找一条，dfs深搜，后者找一条节点数最少的，bfs广搜-->\n\n寻找增广路的时候我们可以简单的从源点开始做bfs，并不断修改这条路上的delta量，直到找到源点或者找不到增广路。\n\n4、代码\n\n```c++\nint c[MAX][MAX];  //残留网络容量\nint pre[MAX];  //保存增广路径上的点的前驱顶点\nbool visit[MAX];\n\nint Ford_Fulkerson(int src,int des,int n){   //src：源点 des：汇点 n：顶点个数\n     int i,_min,total=0;\n     while(true){\n         if(!Augmenting_Path(src,des,n))return total; //如果找不到增广路就返回，在具体实现时替换函数名\n         _min=(1<<30);\n         i=des;\n         while(i!=src){   //通过pre数组查找增广路径上的边，求出残留容量的最小值\n             if(_min>c[pre[i]][i])_min=c[pre[i]][i];\n             i=pre[i];\n         }\n         i=des;\n         while(i!=src){    //再次遍历，更新增广路径上边的流值\n             c[pre[i]][i]-=_min;\n             c[i][pre[i]]+=_min;\n             i=pre[i];\n         }\n         total+=_min;     //每次加上更新的值\n     }\n}\n\n```\n\n```c++\nint dfs(int u,int t,int f)\n{\n\tif(u==t)\n\t  return f;\n\t  used[u]=1;\n\tfor(int i=0;i<g[u].size();i++)\n\t{\n\t\tEdge &e=g[u][i];\n\t\tint v=e.to;\n\t\tif(!used[v]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(v,t,min(e.cap,f));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t)\n{\n\tint res=0,f;\n\twhile(1)\n\t{\n\t\tf=INF;\n\t\tmemset(used,0,sizeof(used));\n\t\tint d=dfs(s,t,f);\n\t\tif(d<=0)\n\t\t\tbreak;\n\t\tres+=d;\n\t}\n\treturn res;\n}\n```\n\n```c++\n--*\n    Ford-fulkerson最短扩充路\n    调用前输入残余矩阵 g[][]\n    直接调用max_flow(源点, 汇点) 返回最大流\n    \n    注意初始化：nodeNum（节点总数量）\n    注意节点标号： 0 - (nodeNum-1)\n*/\n//pku1273\n#include <stdio.h>\n#include <string.h>\n\nconst int MAXN = 201;\n\nint g[MAXN][MAXN];        //残留网络，初始为原图\nint flow[MAXN][MAXN];\nint nodeNum;            //节点总数量\nint pre[MAXN];\n\n//bfs找增广路\nint bfs(const int &s, const int &t)\n{\n    int que[201], p, q, v, i;\n    for (i = 0; i < nodeNum; i++)\n        pre[i] = -1;  \n    que[0] = s;\n    pre[s] = s;\n    p = 0, q = 1;\n    while (p < q)\n    {\n        v = que[p++];\n        for (i = 0; i < nodeNum; i++)\n            if (pre[i] == -1 && (flow[v][i] < g[v][i] || flow[i][v] > 0))\n            {\n                pre[i] = v;\n                que[q++] = i;\n                if (i == t) return 1;\n            }\n    }\n    return 0;\n}\n\n//修改残留矩阵和增广路\nvoid track_back(const int &s, const int &t)\n{\n    int i = t, v, min = 0x7fffffff;\n    while (i != s)\n    {\n        v = pre[i];\n        if (flow[v][i] < g[v][i])\n        {\n            if(min > g[v][i] - flow[v][i])\n                min = g[v][i] - flow[v][i];\n        }\n        else\n            if (flow[i][v] > 0)\n            {\n                if(min > flow[i][v])\n                    min = flow[i][v];\n            }\n        i = v;\n    }\n    i = t;\n    while (i != s)\n    {\n        v = pre[i];\n        if (flow[v][i] < g[v][i])\n            flow[v][i] += min;\n        else\n            if (flow[i][v] > 0)\n                flow[i][v] -= min;\n        i = v;\n    }\n}\n\n//返回 从节点s到节点t的最大流\nint max_flow(const int &s, const int &t)\n{\n    while (bfs(s, t))\n        track_back(s, t);\n    int res = 0, i;\n    for (i = 0; i < nodeNum; i++)\n        if (i != s) res += flow[s][i];\n    return res;\n}\n\nint main()\n{\n    int m, b, e, c;\n    while(scanf(\"%d%d\", &m, &nodeNum)!=EOF)\n    {\n        memset(g, 0, sizeof(g));\n        memset(flow, 0, sizeof(flow));\n        while (m--)  \n            scanf(\"%d %d %d\", &b, &e, &c), g[b - 1][e - 1] += c;\n        printf(\"%d\\n\", max_flow(0, nodeNum-1));\n    }\n    return 0;\n} \n```\n\n### 最小割\n\n就是从图G(V,E)中去除一些边，使得图G中源点S到终点T不连通。如果去除的这些边的权和最小，就是最小割。这个权和可以证明等于网络的最大流量！因此，最大流等价于最小割。求解最大流问题，也可以转化为最小割。求最大流和求最小割集是两类不同的算法。求解最小割集普遍采用**Stoer-Wagner**算法。\n\n#### Stoer-Wagner\n\n```c++\nint min_cut(int now)\n{\n    int ret = INF;\n    for(int i = 0; i < n; i++) node[i] = i;\n    while(now > 1) {\n        int k, pre = 0;\n        memset(vis, 0, sizeof(vis));\n        memset(dis, 0, sizeof(dis));\n        for(int i = 1; i < now; i++) {\n            k = -1;\n            for(int j = 1; j < now; j++) if(!vis[node[j]]) {\n                dis[node[j]] += G[node[pre]][node[j]];\n                if(k == -1 || dis[node[k]] < dis[node[j]]) {\n                    k = j;\n                }\n            }\n            vis[node[k]] = true;\n            if(i == now - 1) {\n                ret = min(ret, dis[node[k]]);\n                for(int j = 0; j < now; j++) {\n                    G[node[pre]][node[j]] += G[node[j]][node[k]];\n                    G[node[j]][node[pre]] = G[node[pre]][node[j]];\n                }\n                node[k] = node[--now];\n            }\n            pre = k;\n        }\n    }\n    return ret;\n}\n```","tags":["网络流"],"categories":["算法"]},{"title":"Clever King (最大权闭合子图模板)","url":"/2018/04/23/2018-04-23-Clever-King-(最大权闭合子图模板)/","content":"\n# [Clever King](https://nanti.jisuanke.com/t/26172)\n\n## 题意\n\nT组数据，有n个产品，m个矿坑。接下来n个数字happiness[i]表示第i个产品的幸福指数，接下来m个数字，ori[i]表示第i个矿坑的开发费用。接下来n行，每行先输入两个数字n1，n2，分别表示第i号产品需要开发的矿坑，和需要的原材料产品。（矿坑开发后材料无限，产品生产后幸福指数一定会增加，不管是作为产品本身还是原材料），要求 幸福指数 - 费用  的最大值。\n\n## 思路\n\n最大权闭合子图模板。[【关于网络流】](https://blog.csdn.net/jingmiaa/article/details/52814814)（ND）\n\n### 定义\n\n一个子图（点集）， 如果它的所有的出边都在这个子图当中，那么它就是闭合子图。 \n点权和最大的闭合子图就是最大闭合子图。\n\n简单说就是有一些点，每个点有一些点权（正负都有），要选一个点，就必须要选它所连向的点。\n\n有可能连成一条链，像这样：x->y->z->…\n\n求合法的点集的最大的点权和。\n\n### 构图\n\n设s为源点，t为汇点。\n\n使s连向所有的正权点（非负权点），边权为点权。\n\n使所有非负权点（负权点）连向t，边权为点权的绝对值。\n\n若需要选y才能选x，连一条由x到y的边，边权是∞。\n\n**最大点权和 = 正权点和 - 最小割**\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\nstruct node{\n    int to,next,flow;\n}e[maxn*maxn*2];\nint cur[maxn],co[maxn],d[maxn],Final[maxn],tot,s,t;\n// s源点 t终点\n\nvoid link(int x,int y,int z)\n{\n    e[++tot].to=y,e[tot].next=Final[x],e[tot].flow=z,Final[x]=tot;\n    e[++tot].to=x,e[tot].next=Final[y],e[tot].flow=0,Final[y]=tot;\n}\nint dg(int x,int flow) //模板 \n{\n    if(x==t) return flow;\n    int use=0;\n    for(int i=cur[x];i;i=e[i].next)\n    {\n        cur[x]=i;\n        if(e[i].flow>0&&d[e[i].to]+1==d[x])\n        {\n            int c=dg(e[i].to,min(flow-use,e[i].flow));\n            use+=c;\n            e[i].flow-=c;\n            e[i^1].flow+=c;\n            if(flow==use) return use;\n        }\n    }\n    cur[x]=Final[x];\n    if(!(--co[d[x]])) d[0]=t;\n    ++co[++d[x]];\n    return use;\n}\nint main()\n{\n    int T,n1,n2,temp,n,m;\n    int ans;\n    long long sum;\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        sum=0;tot=1;s=t=0;\n        memset(cur,0,sizeof(cur));\n        memset(co,0,sizeof(co));\n        memset(d,0,sizeof(d));\n        memset(Final,0,sizeof(Final));\n        scanf(\"%d%d\",&n,&m);\n        ans=n+m;s=ans+1;t=ans+2;\n        for(int i=1;i<=n;i++) //s和正权相连\n        {\n            scanf(\"%d\",&temp);\n            sum+=temp;\n            link(s,i,temp);\n        }\n        for(int i=1;i<=m;i++)  //t和负权相连\n        {\n            scanf(\"%d\",&temp);\n            link(i+n,t,temp);\n        }\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d\",&n1,&n2);\n            for(int j=1;j<=n1;j++)  //i个点需要j的话，就把i->j，边权是inf\n            {\n                scanf(\"%d\",&temp);\n                link(i,temp+n,1<<30);\n            }\n            for(int j=1;j<=n2;j++)\n            {\n                scanf(\"%d\",&temp);\n                link(i,temp,1<<30);\n            }\n        }\n        co[0]=t;\n        for(;d[0]<t;) sum-=dg(s,1<<30); //最小割\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}\n\n```\n\n","tags":["最大权闭合子图"],"categories":["算法"]},{"title":"Goldbach （Miller Rabin模板+埃氏筛模板)","url":"/2018/04/23/2018-04-23-Goldbach-（Miller-Rabin模板+埃氏筛模板)/","content":"\n# [Goldbach](https://nanti.jisuanke.com/t/25985)\n\n## 题意\n\n哥德巴赫猜想：输入一个T（100），输入一个偶数n（2<n<2^63），输出任意一组素数a，b，使得a+b=n。\n\n## 思路\n\na和b必定为一大一小，从小的入手，用埃氏筛筛出1e6内的所有素数prim[]（猜想到小的那个素数一定不超过1e6），然后遍历prim[]，算出n-prim[i]，用基于概率的素数测试算法MillerRabin判断它是不是素数即可。\n\n[【Miller Rabin素数判定】](https://blog.csdn.net/sunshine_cfbsl/article/details/52425798)\n\n这里注意，由于2^63次过大，在相乘得过程中会超longlong，因此要改用unsigned long long。\n\n> 做题的时候，遇到范围是2^63，取模2^64的这种题目。遇到这种限制条件时就要想到用unsigned long long类型。这样，如果ull类型的整数溢出了，就相当于取模2^64了。因为ull的范围是[0,2^64-1]。而ll的范围是[-2^63,2^63-1]，因为有符号的第63位表示“正负”而不表示数值。\n\n**附一个公式：(1+a1)(1+a2)(1+a3)……(1+an-1)(1+an) = 1+sum{ai}+sum{ai·aj}+sum{ai·aj·ak}+……+sum{a1·a2·…·an}**\n\n## 看！代码\n\n```C++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 65;\nconst int MAX=1e6;\ntypedef ULL ULL;\nULL n, x[MAXN];\n\nULL pri[MAX+5],num=0;\nbool vis[MAX+5];\n\nvoid init()\n{\n    int i,j;\n    for(i=2;i<MAX;i++)\n    {\n        if(vis[i]==false)pri[num++]=i;\n        for(j=0;j<num&&i*pri[j]<MAX;j++)\n            vis[i*pri[j]]=true;\n    }\n}\n\nULL multi(ULL a, ULL b, ULL p) {\n    ULL ans = 0;\n    while(b) {\n        if(b&1LL) ans = (ans+a)%p;\n        a = (a+a)%p;\n        b >>= 1;\n    }\n    return ans;\n}\n\nULL qpow(ULL a, ULL b, ULL p) {\n    ULL ans = 1;\n    while(b) {\n        if(b&1LL) ans = multi(ans, a, p);\n        a = multi(a, a, p);\n        b >>= 1;\n    }\n    return ans;\n}\n\nbool Miller_Rabin(ULL n) {\n    if(n == 2) return true;\n    int s = 20, i, t = 0;\n    ULL u = n-1;\n    while(!(u & 1)) {\n        t++;\n        u >>= 1;\n    }\n    while(s--) {\n        ULL a = rand()%(n-2)+2;\n        x[0] = qpow(a, u, n);\n        for(i = 1; i <= t; i++) {\n            x[i] = multi(x[i-1], x[i-1], n);\n            if(x[i] == 1 && x[i-1] != 1 && x[i-1] != n-1) return false;\n        }\n        if(x[t] != 1) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    int t;\n    ULL n,temp;\n    init();\n    scanf(\"%d\",&t);\n    while(t--)\n    {\n        scanf(\"%lld\",&n);\n        for(int i=0;i<num;i++)\n        {\n            if(Miller_Rabin(n-pri[i]))\n            {\n                printf(\"%lld %lld\\n\",pri[i],n-pri[i]);break;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["素数"],"categories":["算法"]},{"title":"ACM-ICPC & U","url":"/2018/04/19/2018-04-19-ACM-ICPC-&-U/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=32574246&auto=0&height=66\"></iframe>\n\n<img  src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/ACM.jpg\" arc=\"ACM-ICPC :) \">\n\nworld final的直播，窝在图书馆的角落看了一下午，这种感觉真的很棒，真的让我有一种ACM即是力量的冲动。看着这么多的队伍们提交，Pending的进度条一点一点增加，然后高亮，切到队伍的镜头，一阵紧张，最后AC后的欢呼和击掌，然后匆匆进入下一题。\n\n代码的力量是什么呢？\n\nACM的力量是什么呢？\n\n让我明明笨拙到坚持不下去，却又不舍得放弃它。\n\n大概是等待pending的期待的心情，WA了之后自言自语的不服，TLE绞尽脑汁优化的苦恼，或者是看着队友疯狂输出的感叹，大家叽里呱啦实在是很吵闹的讨论 …… 以及最后出现的世界上最好看的单词Accept的欣喜若狂。\n\n真是充满着魔力的一切。\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E9%94%AE%E7%9B%98%E4%B8%8A%E7%9A%84%E7%A7%98%E5%AF%86.jpg\" arc=\"键盘上的星星点点\">\n\n----\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/%E8%A5%BF%E8%A3%85%E5%92%8C%E7%8B%97%E6%AF%9B.jpg\" arc=\"西装领带，狗毛\">\n\n> 四月十九号，倒计时：三天。\n\n----\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/JJ%E5%9C%A3%E6%89%80.jpg\" arc=\"丹宁执着\">\n\n> 许下演唱会的心愿。\n\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"木棒切割（二分+DP+滚动数组优化）","url":"/2018/04/18/2018-04-18-木棒切割（二分+DP+滚动数组优化）/","content":"\n# [木棒切割](https://vjudge.net/problem/HYSBZ-1044)\n\n## 题意\n\n有n个木棒，最多能切m下，接下来n行，给出n个木棒的长度，求出切割后最大长度的最小值，并求出有多少种切割方式，取模10007\n\nn<=50000，0<=m<=min(n-1,1000)，1<=Li<=1000\n\n## 思路\n\n二分答案，low=0，high=sum[n]。\n\n得到最小值ans。\n\n接下来用DP，求出切割种数。\n\n**dp[i][j]表示前i个木棒切割j下的种数，设sum[i] 是前i个木棒的长度和 ，那么dp[i][j]=求和{ dp[k][j-1] }，满足条件：k<i && sum[i] - sum[k]<=ans** 。\n\n但是写完之后，我们发现，诶，这个时间复杂度……O(n^2 * m)，这不超时有鬼……\n\n于是我们可以进行下面的优化：\n\n### 1、空间\n\n由于当前的dp[][j]只与dp[][j-1]有关，所以呢，我们可以用滚动数组，用dp[][now]代替dp[i][j]，用dp[][pre]代替dp[][j-1]，其中pre=now^1。\n\n这样空间就小啦~\n\n### 2、时间\n\n这个好难理解啊我觉得……大概是太笨了哼唧\n\n对于dp[i][now],其实是dp[Mink][pre]……dp[i-1][Mink]的和！！Mink 就是满足 k<i && sum[i]-sum[k]<=ans的最小的k。那么，对于从 1 到 n 枚举的 i ，相对应的 Mink 也一定是非递减的（因为 Sum[i] 是递增的）。我们记录下 dp[1][pre]...dp[i-1][pre] 的和 S ，Mink 初始设为 1，每次对于 i 将 Mink 向后推移，推移的同时将被舍弃的 p 对应的 dp[p][pre] 从 S 中减去。那么 dp[i][Now] 就是 S 的值。\n\n时间复杂度O(nm)。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=10007;\nint n,m,ans;\nint a[50010],sum[50010];\nint cnt=0;\n\nint check(int mid) //看看有没有单比mid还大的 或者分割不了的\n{\n    int s=0,cnt=0;\n    for(int i=1;i<=n;i++)\n    {\n        s+=a[i];\n        if(s>mid) cnt++,s=a[i];\n        if(cnt>m) return 0;\n        if(a[i]>mid) return 0;\n    }\n    return 1;\n}\n\nvoid solve() //二分答案\n{\n    int l=0,r=sum[n];\n    int mid;\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(check(mid)) ans=mid,r=mid-1; \n        else l=mid+1;\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    sum[0]=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        sum[i]=sum[i-1]+a[i];\n    }\n    solve();\n    int dp[50010][2]={0}; //滚动数组，前i块切j下的数量\n    int now=0,pre=1,s,Mink; //mink 最小的满足k<j && s[i]-s[k]<=ans 的\n    int res=0;\n    for(int i=0;i<=m;i++) //切i下\n    {\n         s=0,Mink=1; \n         for(int j=1;j<=n;j++) //前j块\n         {\n             if(i==0) //如果一下不割\n             {\n                 if(sum[j]<=ans) dp[j][now]=1; //如果这块东西比要求的要小，就前j块割0下是1钟\n                 else dp[j][now]=0;\n             }\n             else\n             {\n                 //s=sum{dp[k][j-1]} k<j&&s[i]-s[k]<=ans ，sum也相当于减去那些不满足条件的，\n                 //因为这东西肯定单调非递减，所以一直找到最小的满足的k就好\n                 while(Mink<j&&(sum[j]-sum[Mink])>ans) //找到最小的满足条件的k\n                 {\n                     s-=dp[Mink][pre]; //减去前mink块不符合条件的 切了i-1下的\n                     s=(s+MOD)%MOD;\n                     Mink++;\n                 }\n                 dp[j][now]=s%MOD; //别忘了取模\n             }\n             s=(s+dp[j][pre])%MOD; // s加上前j块割i-1下的\n         }\n         res=(res+dp[n][now])%MOD; //总数相当于总数加上n块割i下的\n         now^=1; //滚动数组\n         pre=now^1;\n    }\n    printf(\"%d %d\\n\",ans,res);\n    return 0;\n}\n```\n\n","tags":["滚动数组"],"categories":["算法"]},{"title":"Buy a ticket (最短路SPFA)","url":"/2018/04/18/2018-04-18-Buy-a-ticket-(最短路SPFA)/","content":"\n# Buy a ticket\n\n## 题意\n\n给你n个城市，m条无向路，每条路有vi的权值（>0），每个城市有ai的音乐会花费。\n\n某人想去看音乐会，如果她在i城，他要去j城看演出，那么要花费的钱相当于来回的路费加上j城的演唱会的钱（也可以在自家看演出）。求的是，每个城市的人看一场音乐会的最少花费。\n\n## 思路\n\n很熟悉的思路，定义一个超级原点，将超级原点和每个城市连起来，路的权值设为该城市的音乐会花费，同时加其他的路的权值设为原来的两倍（来回的花费），那么从原点到每个城市的最小花费就是每个城市的人看音乐会的最小花费。（最短路）\n\n开头用dijkstra写，看了一下复杂度肯定会T，o(n^2)的样子，然后交了一发。后来换用SPFA，队列啥的，还是T，然后看了一下过的人的代码，发现他们用优先队列优化，将花费大的放在了前面。\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nint n,m;\nstruct  node{\n    int to; //目的\n    long long val; //花费\n};\nstruct  Node{\n    int to;   \n    long long val;\n    bool operator<(const Node k)const{\n        return val>k.val; \n    }\n};\nvector<node>Next[200005]; //路\nint vis[200005]={0}; //在Q里的情况\nlong long dis[200005];  //距离原点的最短距离\nvoid SPFA()\n{\n    memset(dis,INF,sizeof(dis)); \n    priority_queue<Node> Q; //修改成优先队列，默认路径花费大的放前面，是的\n    Node temp;\n    temp.to=0;temp.val=0;\n    Q.push(temp);  //把原点先入队\n    vis[0]=1;dis[0]=0; //原点到原点当然是0啦  \n    int now,a;\n    while(!Q.empty())\n    {\n        temp=Q.top();\n        Q.pop();\n        now=temp.to;\n        vis[now]=0;  //出队的点vis更新\n        for(int i=0;i<Next[now].size();i++)  //遍历连接的城市\n        {\n            a=Next[now][i].to;  \n            if(dis[a]>(dis[now]+Next[now][i].val)) //如果从原点到这个城市的距离比中间接这个城市跳转要远\n            {\n                dis[a]=dis[now]+Next[now][i].val;\n                if(vis[a]==0) //如果a不在队列里\n                {\n                    vis[a]=1;temp.to=a;temp.val=dis[a];\n                    Q.push(temp);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int ori,to;\n    node temp;\n    scanf(\"%d%d\",&n,&m);\n    while(m--)\n    {\n        scanf(\"%d%d%lld\",&ori,&to,&temp.val);\n        temp.to=to;\n        temp.val*=2;\n        Next[ori].push_back(temp);\n        temp.to=ori;\n        Next[to].push_back(temp);\n    }\n    dis[0]=0;\n    for(int i=0;i<n;i++)\n    {\n        scanf(\"%lld\",&dis[i+1]);\n        temp.to=i+1;temp.val=dis[i+1];\n        Next[0].push_back(temp);\n    }\n    SPFA();\n    for(int i=1;i<=n-1;i++) printf(\"%lld \",dis[i]);\n    printf(\"%lld\\n\",dis[n]);\n    return 0;\n}\n```\n\n","tags":["图论"],"categories":["算法"]},{"title":"Cashback (DP 区间最小值)","url":"/2018/04/18/2018-04-18-Cashback-(DP-区间最小值)/","content":"\n# Cashback\n\n## 题意\n\n输入n和c。接下来给出长度为n的数组A。你可以将数组A划分成任意个子数组，假设其中一个子数组的长度为k，那么可以减去这个子数组内前k/c个（向下取整）小的数。要使划分后数组内的元素和最小，问最小的和为多少？\n\n## 思路\n\n预感到是DP，但是没有什么L用……\n\n分析一下：如果其中一个子数组的长度k< c，那么这个数组就一个也不能减少；如果长度k=c，那么就刚好减少一个；如果长度在c< k< 2c之间，并没有任何贡献，还是只能少一个。也就是说，长度正好为c的数组是优秀的。那么长度为2c的数组呢？我们假设[0,c-1]内，最小的数字为min1，第二小的是min2，[c,2c-1]内，最小的数字为min3，那么，如果min2< min3，对于划分（2个长度为c）来说，消去的数字是min1+min3，而对于划分（1个长度为2c），消去的数字就是min1+min2，显然是两个c长度的划算。如果min2>=min3，对于划分成（2个长度为c）来说，消去的数字就是min1+min3，对于划分（一个长度为2c），消去的数字为min1+min3，两者是相等的。因此综上而言，将数组划分成长度为c的小数组更划算一些。\n\n那么就用到dp了，dp[i]指 前i个数字的最小和。\n\n对于一个数字a[i]来说，（i>c）dp[i] 要么是接受前一个数字的dp再加上自己的大小，要么就是重新进入一个长度是c的数组，起始index为i-c+1，dp[i]=dp[i-c] (前i-c的最小和）+sum[i]-sum[i-c] （这一段新的长度为c的数组的总和）- min{a[i-c+1], … , a[i] }（这一段长度是c的区间里的最小值），即：\n\n**dp[i] = min(dp[i-1]+a[i] , dp[i-c] + sum[i] - sum[i-c] -  min{a[i-c+1], … , a[i] } )**\n\n对于区间最小值min，用一个multiset维护就好了。multiset里只放当前i为最后一个数字的c个数字。而multiset中的.begin() 会返回容器中最小的数的指针。如果去掉最前面一个放进来的数字呢？. erase( .find(a[i-c+1]))就好了。\n\n## 看！代码\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=100010;\nint n,c;\nlong long dp[MAX],a[MAX]; //dp[i]指前i个元素相加的最小和\nlong long sum[MAX]; //前i个元素和\nmultiset<long long>s; //s用来维护长度为c的区间内的最小值\nint main()\n{\n\tscanf(\"%d%d\",&n,&c);\n\tsum[0]=0;\n\tfor(int i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&a[i]);\n\t\tdp[i]=sum[i]=sum[i-1]+a[i]; \n\t\t//初始化dp值，显然长度不足c的dp值为前i个数之和，其他的默认初始值为前i个数之和\n    }\n    for(int i=1;i<c;i++)\n        s.insert(a[i]);\n    for(int i=c;i<=n;i++)\n    {\n        s.insert(a[i]);\n        dp[i]=min(dp[i-1]+a[i],dp[i-c]+sum[i]-sum[i-c]-*s.begin());\n        //前一个数加上自己的和，前一个c区间及之前的最小和加上这个新的c区间的总和，减去这个区间的最小值\n        s.erase(s.find(a[i-c+1]));//删去下一步到了区间外的数字\n    }\n\tprintf(\"%lld\",dp[n]);\n\treturn 0;\n}\n\n```\n\n","tags":["DP"],"categories":["算法"]},{"title":"二数(就没啥)","url":"/2018/04/15/2018-04-15-二数(就没啥)/","content":"\n# [二数](https://www.nowcoder.com/acm/contest/91/I)\n\n## 题意\n\n一个T<=100,一个n, 1<=n<=10^100000-1 \n\n二数：十进制下每一位都是偶数的数\n\n求离n最近的二数\n\n## 思路\n\n用字符串存。\n\n思考可以得到，对于n要么向小了变，要么向大了变。\n\n遍历，对于遇到的第一个奇数k，\n\n1、变小：k-- \n\n​      然后其他所有的数字都变成‘8’\n\n2、变大：k++\n\n​     然后其他所有数字变成’0‘\n\n对于k=='9'的情况，直接取变小就好了，因为变小的代价肯定小于变大的代价。\n\n然后比较谁更近的话，从高位开始一位一位的比较差值大小就好了……\n\n输出的时候去掉前导0，就好了……\n\n（代码依旧丑，其实很多地方可以改进，但我也懒得……）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t,len,flag;\n    cin>>t;\n    string s,sm,sb;\n    while(t--)\n    {\n        cin>>s;\n        len=s.size(),flag=0;\n        if(len==1&&(s[0]=='1'||s[0]=='0')) { printf(\"0\\n\");continue; } //1 0特判一下\n        sm=sb=s;\n        for(int i=0;i<len;i++) //向下,\n        {\n            if((sm[i]-'0')%2==1)\n            {\n                if(flag==0) sm[i]--,flag=1; //第一个数变小\n                else  //后面的数变大\n                    if(sm[i]=='9') sm[i]='8'; //9变8\n                    else sm[i]='8'; //其他数字变8\n                continue;\n            }\n            if(flag==1)\n                sm[i]='8'; //其他数字变8\n        }\n        flag=0;\n        for(int i=0;i<len;i++) //向上\n        {\n            if((sb[i]-'0')%2==1)\n            {\n                if(sb[i]=='9'&&flag==0) //9同sm\n                {\n                    sb=sm;break;\n                }\n                if(flag==0)  sb[i]++,flag=1;//第一个变大\n                else sb[i]='0';\n                continue;\n            }\n            if(flag==1) sb[i]='0';\n        }\n        //比较\n\n        flag=0;\n        for(int i=0;i<len;i++)\n        {\n            if((s[i]-sm[i])<(sb[i]-s[i])) //前者小\n            {\n                flag=-1;break;\n            }\n            else if((s[i]-sm[i])>(sb[i]-s[i])) //后者小\n            {\n                flag=1;break;\n            }\n        }\n        if(flag==1) s=sb;\n        else s=sm;\n        flag=0;\n        for(int i=0;i<len;i++)\n            if(s[i]!='0') { flag=1; printf(\"%c\",s[i]); }\n            else\n                if(flag==0) continue;\n                else printf(\"%c\",s[i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n","categories":["算法"]},{"title":"K序列（DP）","url":"/2018/04/15/2018-04-15-K序列（DP）/","content":"\n# [K序列](https://www.nowcoder.com/acm/contest/91/L)\n\n\n\n## 题目\n\n给一个数组 a，长度为 n，若某个子序列中的和为 K 的倍数，那么这个序列被称为“K 序列”。对数组 a 求出最长的子序列的长度，满足这个序列是 K 序列。 \n\n输入一个n，k，接下来输入n个整数，表示A[1]~A[n] ,1<=n<=1e5,1<=a[i]<=1e9,1<=nK<=1e7。输出最长子序列的长度。\n\n## 思路\n\n又一道DP。\n\ndp[i][j] : 表示前i个数中，对k取模余数为j的最长的子序列长度\n\ndp[i][j] =max (dp[i-1][j],dp[i-1][(k-a[i]%k+j)%k]+1) \n\n解释一下，指的是上一层（前i-1个数字）余数一样的，和上一层再加上a[i]（前i个数字）[余数]+1。\n\n这里有个条件是要判断一下这个取模的余数是否已经存在了，不然就不能比较。\n\n讲的不太清楚，看代码吧。\n\n（这里用二维 vector存dp）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint a[100010];\nint main()\n{\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    vector<vector<int> >dp(n+5);\n    for(int i=0;i<=n;i++)\n        dp[i].resize(k);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<k;j++)\n        {\n            if(a[i]%k==j) dp[i][j]=1;\n            dp[i][j]=max(dp[i-1][j],dp[i][j]);\n            if(dp[i-1][(j-a[i]%k+k)%k]!=0)\n                dp[i][j]=max(dp[i][j],dp[i-1][(j-a[i]%k+k)%k]+1);\n        }\n    printf(\"%d\\n\",dp[n][0]);\n    return 0;\n}\n```\n\n","tags":["DP"],"categories":["算法"]},{"title":"1+2=3?(奇怪的斐波那契规律题)","url":"/2018/04/15/2018-04-15-1+2=3(奇怪的斐波那契规律题)/","content":"\n# [1+2=3？](https://www.nowcoder.com/acm/contest/91/F)\n\n## 题目\n\n输入一个T，接下来T行，每行一个N，输出满足 x异或2x== 3x 的第N个数字。\n\nT<=100,N<=1e12\n\n## 思路\n\n打了表，[整数数列百科全书](http://oeis.org/?language=english)中找到符合规律的数列，观察二进制形式后发现：\n\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/FB.jpg\"  alt=\"规律\" />\n\n斐波那契数列：\n\n1 2 3 5 8 13 21 34 55 ……\n\n题中若N=60，则60= 55 + 5 （第9项+第4项）\n\n则第60个满足条件的数为：1(9)00001(4)000 = 264 (4、9号位数为1，其他都是0)\n\n由于1e12小于斐波那契的第59项，故开一个59大的数组，里面存斐波那契数，然后对于每一个N寻找最少的组成它的斐波那契数，找到他是第x项，那么ans+2^x即可。\n\n（问题是我的代码怎么这么丑= =）\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;\n    scanf(\"%d\",&t);\n    vector<long long>fei; //算斐波那契 1 2 3 5这样的\n    fei.push_back(1);fei.push_back(2);\n    while(fei[fei.size()-1]<(1e12+5)) fei.push_back(fei[fei.size()-1]+fei[fei.size()-2]);\n \n    while(t--)\n    {\n        long long n,temp;\n        scanf(\"%lld\",&n);\n        temp=n;\n        long long weishu[100],x=1,ans=0;\n        for(int i=0;i<60;i++)\n            weishu[i]=x,x*=2; //计算2的i次\n      \n        for(int i=57;i>=0;i--)\n            if(temp>=fei[i]) //找能组成他的斐波那契数，直接算\n                temp-=fei[i],ans+=weishu[i];\n      \n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n","tags":["规律"],"categories":["算法"]},{"title":"归途","url":"/2018/04/05/归途/","content":"\n<img src=\"https://xheartbeat.top/mdpicture/拉杆箱会飞吗.jpg\"  alt=\"如果拉杆箱会飞\" />\n\n回家，带着我的拉杆箱。\n\n拉杆箱好沉啊，下着雨，要撑伞。红色的卫衣，薄荷绿的伞。\n\n<br/>\n\n## 城隍百味\n\n<img src=\"http://xheartbeat.top/mdpicture/城隍百味.jpg\"  alt=\"城隍庙地铁站\" />\n\n### 食\n\n和小可爱在一起。\n\n\"我要吃三色杯！\"\n\n\"上口爱！\"\n\n\"给我尝一口！\"\n\n\"好冷呐哥！\"\n\n\"我要吃炸鱿鱼！\"\n\n\"好脆呀！\"\n\n\"别扯呀别扯！\"\n\n\"我没我咬不动！\"\n\n\"看你满嘴！\"\n\n\"哼！\"\n\n\"老板来三根肉串！\"\n\n\"还吃……\"\n\n\"臭豆腐要吗！\"\n\n\"……要！\"\n\n\"来一口！\"\n\n\"哇呜是香菜！！TOT \"\n\n\"很香！\"\n\n\"哦这个味道！\"\n\n\"这才是真正的臭豆腐！\"\n\n\"霉的很完美！\"\n\n\"……\"\n\n<br/>\n\n<img src=\"https://xheartbeat.top/mdpicture/臭豆腐.jpg\"  alt=\"城隍庙臭豆腐\" />\n\n<br/>\n\n\n\n### 遇\n\n老地方，又遇见了一个乞讨的老爷爷，但是好像没有人愿意给他钱。\n\n以前也遇到过一次，等饮料的时候，他伸出破烂的碗，看着我，上下颠一颠，几块钱硬币在碗里面当啷响。\n\n我犹豫着响掏出一点碎钱，被小可爱制止了。\n\n貌似有些残酷的冲老爷爷摆摆手，然后拿了饮料转身离开，给他一个背影。\n\n后来我们往下走，在风很大的路口遇见了一个卖报纸的老婆婆，忘记了多少钱一份，两块还是三块？只记得小可爱二话不说就买了一份。报纸还是过期的，早就不知道哪儿去了。\n\n记得他当时这样说：\n\n\"如果我们刚才给了那个乞丐钱，那对这个辛苦卖报的老婆婆是不是不公平？\"\n\n<br/>\n\n## 归途\n\n> 不断更新着的一切\n>\n> 高楼 大厦\n>\n> 人\n\n<img src=\"https://xheartbeat.top/mdpicture/高樓.jpg\"  alt=\"萬達新樓\" />\n\n<br/>\n\n> 清明时节雨 纷纷\n\n<img src=\"https://xheartbeat.top/mdpicture/我.jpg\"  alt=\"潮湿的\" />\n\n<br/>","tags":["随想"],"categories":["Life & Story"]},{"title":"Missing Leslie","url":"/2018/04/01/2018-04-01-Missing-Leslie/","content":"\n<img src=\"http://qgsuuzgw0.hn-bkt.clouddn.com/Leslie1.jpg\"  alt=\"春天该很好，你若尚在场\" />\n\n\n\n> 春天该很好，你若尚在场。\n\n<br/>","tags":["随想"]},{"title":"CF 957C Three-level Laser (二分)","url":"/2018/04/01/2018-04-01-CF-957C-Three-level-Laser-(二分)/","content":"\n# [Three-level Laser](http://codeforces.com/contest/957/problem/C) \n\n## 题意\n\n输入一个n，m，n代表接下来有n个数字（从小到大），\n\n接下来从n个数字中选3个数字i，j，k（i<j<k），\n\n使得k-j/k-i 最大，且（k-i）<=m。(n<1e5)\n\n## 思路\n\n开头直接写，j=1开始遍历，要让值最大，i=j-1,（必定），k为可允许内最大的值。\n\n用for找k，会T，于是改用二分，输出用.15f（精度限制，double到.6）。\n\n## 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 7;\nint a[N];\nint main()\n{\n    int n,U;\n    scanf(\"%d%d\",&n,&U);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    double res=-1.0;\n    for(int i=1;i<=n-2;i++) \n    {\n        int t1=a[i],t2=a[i+1],up=U+t1;\n        int k=upper_bound(a+1,a+1+n,up)-a-1;\n        if(k<i+2) continue;\n        res=max(res,(a[k]-t2*1.0)/(a[k]-t1));\n    }\n    printf(\"%.15f\\n\",res);\n    return 0;\n}\n```\n\n","tags":["二分"],"categories":["算法"]},{"title":"Yilia","url":"/2018/03/31/Change/","content":"\n\n\n<img src=\"https://xheartbeat.top/mdpicture/18033102.jpg\"  alt=\"回老家的时候，在奶奶家旁边的荒地前拍的，一轮小小的月亮， 好像一个小小的我\" />\n\n<br/> <!--http://qgsuuzgw0.hn-bkt.clouddn.com/18033102.jpg -->\n\nHexo 找如何搭建相册的时候，发现的一个主题，yilia，简洁，充满魅力。\n\n创作这个主题的作者Litten是鹅厂的一名前端。\n好奇心的驱使，让我开始翻看着他的随笔，生活中的点点滴滴，却感叹于他的心思和文笔的细腻。\n\n他写凛冬将至，说人的老去，很多是因为忘记了年轻。\n他写生病，说意外的中断是多么可爱，欢乐可放歌，悲伤可饮酒。\n要是心情郁闷的话，就用手托腮，手臂会因为帮上忙而开心。\n…\n\n以及各种稀奇古怪的专业文章，\n讲反爬虫的，讲Unicode，\n…\n\n他的相册里的照片，\n我实在是喜欢。\n非常的生活，和触动。\n\n我想了想，换掉了我执念的透明色主题。\n毕竟看多了还是觉得花里胡哨。\n博客嘛，\n回到内容上来，还是更好。\n我想谢谢这位陌生的，\n不知道怎么称呼，\n在这些天茫然的夜晚，我又重新感受到了，\n生活该是什么样，就是什么样。\n\n<br/>\n\n> 事情无非是let，变化历历；或者是const，永恒安息。","tags":["随想"],"categories":["Life & Story"]},{"title":"文章置顶","url":"/2018/03/31/文章置顶/","content":"\n1、Hexo bash ：\n\n```\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n\n2、在需要置顶的文章的`Front-matter`中加上：`top: true`\n\n完毕。\n\n3、置顶的文章添加置顶标志\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"LiveRe 留言板 GET(适用于第一个主题，改变中)","url":"/2018/03/31/LiveRe-留言板-GET/","content":"\n\n\n在正式开始之前！\n\n容我先大笑三声！\n\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈！！！\n\n<!--more-->\n\n在尝试了Valine一直失败之后，\n\nLiveRe终于赐予了我成功的喜悦！\n\n看了很多乱七八糟的安装指南，就是合不到我的网站上来，\n\n很多人都是next主题，导致很多步骤其实跟我自己的都是不搭嘎的，所以我现在来记录一下这个过程吧：\n\n1、首先，当然是注册LiveRe啦！<a href=\"https://livere.com/\"> 来必力 </a>\n\n2、选择安装板块，这里我们安装的是City版~\n\n<img src=\"https://xheartbeat.top/mdpicture/1803291.jpg\" width=\"511\" height=\"646\" alt=\"City\" />\n\n3、接下来填写一些关于你想将LiveRe用于的博客的一些信息：（图片来自网络）\n\n<img src=\"https://xheartbeat.top/mdpicture/1803292.JPG\" width=\"875\" height=\"593\" alt=\"填写\" />\n\n4、填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来：\n\n<img src=\"https://xheartbeat.top/mdpicture/1803293.JPG\" width=\"794\" height=\"756\" alt=\"代码\" />\n\n5、在个人博客中加入LiveRe代码，首先去如路径：*hexo_bolg/themes/your-theme/layout/_partial/post*下创建livere.ejs代码。livere.ejs的内容就是上一步中获取的代码。\n\n6、然后修改路径：hexo_bolg/themes/your-theme/layout/_partial下的article.ejs文件，在`<% if (!index && post.comments){ %>` 代码块下添加如下代码：\n\n```js\n<% if (!index){ %>\n  <% if (post.comments){ %>\n  <%- partial('post/livere') %>\n  <% } else { %>\n    <div class=\"lv-container\"></div>\n  <% } %>\n<% } %>\n```\n\n如图：\n\n<img src=\"https://xheartbeat.top/mdpicture/1803294.JPG\" width=\"593\" height=\"765\" alt=\"修改\" />\n\n7、git g，git d~\n\n完成！！！\n\n我先去试用一波啦哈哈哈哈哈！！！！\n\n:laughing:\n\n(p.s.这个markdown的小表情好可爱。。输冒号的时候意外发现的。。。Surprise？？)","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"日常反省","url":"/2018/03/31/反省/","content":"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哎呀，其实也是昨天的事情了。\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是觉得，自己很犹豫不决，凡事一下子解决不了，又喜欢拖着，结果就导致最后处理不好两边的结果，会有一种左右不是人的味道，但是毕竟也是自己的错啊，明明心里想着这样这样，但是又不跟人家讲清楚，太**失败**了吧！\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后要学会**果断**和**决绝**，不要把心思放在人后面去讨论。\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就是这样，反省自己。\n<br/>\n\n---------\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由这两个词语我还想到，我爸的事情。你说他要是果敢一点，哪里会折腾这么个来回。\n\n&nbsp;&nbsp;&nbsp;&nbsp;    我们爷俩就是在这性格的薄弱方面，特别像了。\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"聚餐","url":"/2018/03/31/聚餐/","content":"&nbsp;&nbsp;&nbsp;&nbsp;长辈一代的遥远的许久未见的亲戚，如今因为后代重新联系在一起，对于后代来说，忽然承受了很大的责任与压力，自己仿佛变成了维系这种关系的纽带。\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;有时候想也不是，不想也不是，去也不是，不去也不是，只能默默地做好自己身为纽带的职责。\n\n&nbsp;&nbsp;&nbsp;&nbsp;虽然对方长辈待自己不薄，但是底下的子子孙孙确实不关他们什么事情了，于是家庭聚会这种事情，大概就是名为尴尬的存在吧。\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"MoonLight","url":"/2018/03/31/MoonLight/","content":"\n**We go about our daily lives understanding almost nothing of the world.**\n\n**We give little thought of the machinery that generates the sunlight that makes life possible.**\n\n**To the gravity that glues us to the earth that would otherwise send us spinning off into the space.**\n\n**Or to the atoms, which we are made, and on who's stability we  fundamentally depend.**\n\n**Few of us spend much time wondering why nature is the way it is.**\n\n**where the cosmos came from.**\n\n**Whether it was always there.**\n\n**If time will one day flow backward.**\n\n**Or whether there are ultimate limits to what humans can know.**\n\n**What is the smallest piece of the matter.**\n\n**Why  we remember the past and not the future.**\n\n***AND WHY THERE IS A UNIVERSE ?***\n\n<br/>\n\n<a href=\"https://download.sublimetext.com/Sublime%20Text%20Build%203143%20x64%20Setup.exe\"> If  The Moon Were Only 1 Pixel . </a>\n\n<br/>","tags":["Universe"],"categories":["English Matters"]},{"title":"Subline text 3 插件","url":"/2018/03/31/ST3插件/","content":"\n## 插件\n\n**View In Browser**\n\nhtml文件+快捷键在浏览器打开 （个人：ctrl+alt+f）\n\n**SideBarEnhancements**\n\n设置默认打开浏览器\n\n<!--more-->\n\n在设置里输入：\n\n`{`\n  `\"default_browser\": \"chrome\" //one of this list: firefox, aurora, chrome, canary, chromium, opera, safari`\n`}`\n\n然后在快捷键中设置：\n\n```\n{    \n    \"keys\": [\"ctrl+alt+f\"],\n    \"command\": \"side_bar_open_in_browser\",\n    \"args\": {\n                \"paths\": [],\n                \"type\": \"testing\",\n                \"browser\": \"\"\n            }\n}\n```\n\n\n## 快捷键\n\n###### <b> Q：如何设置快捷键？ </b>\n\n**A：** *Preferences->Key Bindings-User* ，打开*Default (Windows).sublime-keymap*文件，\n\n输入`[ { \"keys\": [\"ctrl+alt+f\"], \"command\": \"open_in_browser\" },]` （eg）\n\n快捷键即ctrl+alt+f。\n\n\n\n","tags":["Subline"],"categories":["前端"]},{"title":"进度条颜色修改","url":"/2018/03/31/进度条颜色修改/","content":"\n**在路径：*/theme/sw/source/css/path/path-theme-flash.css* 中，找到代码：**\n\n```\n.pace .pace-progress {\n  background: #FFB6C1;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n```\n\n**修改background颜色即可。**\n**本站颜色为<span  style=\"color:#FFB6C1\">浅粉</span>。**\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"推荐blog","url":"/2018/03/31/参考博客/","content":"## 文字直接链接\n\n[美化](http://blog.csdn.net/com_ma/article/details/76039859)\n\n[插件什么的](https://www.jianshu.com/p/a52b68794a6b)\n\n[相册和音乐页](http://blog.csdn.net/u013775952/article/details/52524015?locationNum=4)\n\n[一个侧边隐藏音乐界面的hexo主题github](https://github.com/th720309/hexo-theme-believe)  [demo](http://www.tianhao.site/)\n\n[欢迎页面制作介绍](http://blog.lightina.cn/2016/10/27/HexoOverview/) [demo](https://jacklightchen.github.io/)\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"如何插入音乐","url":"/2018/03/31/插入音乐/","content":"\n<ol>\n    <b/><li>使用GIT BASH在根目录安装下列插件：<li>\n\t<p>npm install hexo-tag-dplayer </p>\n    <p>npm install hexo-tag-aplayer</p>\n<!--more-->\n​\t<li>打开[网易云音乐](http://music.163.com/)</li>\n​    <li>搜索你喜欢的音乐，点开歌名，然后点击“生成外链播放器”\n​    <li>选择iframe插件，复制代码 \n​    <li>在负责需要放置该播放器的代码文件的最后粘贴该代码：\n​    如：我在左边的菜单底部放置，那么我选择了\n​    \\themes\\sw\\layout\\_partial 中的left-col.ejs 文件，粘贴了以下代码：\n\n```\n<div style=\"position:absolute; bottom:0px; left:0px; width:76%\">\n\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=80 src=\"//music.163.com/outchain/player?type=2&id=504797899&auto=1&height=66\"></iframe>\n\n</div>\n```\n**注意，div中的style，bottom为距离底部的高度，left为距离左边的宽度，中间的代码块是复制的网易给的代码，而里面的width和height可以自己调节。**\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"ZOJ 4011 Happy Sequence (DP)","url":"/2018/03/31/ZOJ 4011 Happy Sequence (DP)/","content":"## [Happy Sequence](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4011)\n\n### 题意\n找一组数列；要求长度为m，且数列的每一项都是前一项的倍数，且数字不大于n。\n\n\n<!-- more -->\n### 思路\n\n这道题用动态规划去做，首先找状态，我们设数组f[i][j]表示以i结尾且长度为j的happy sequence个数。\n\n那么状态方程则为：\n\nf[i][j]=sum（f[k][j-1]），k为i的所有因子\n\n解释一下状态方程：\n\n既然f[i][j]表示以i结尾且长度为j的happy sequence个数，那么在此类数列后面再加个i的倍数（i*k%i==0）也是一个happy sequence，所以以i结尾的长度为j的happy sequence个数为所有的以i的因子结尾的长度为j-1的happy sequence个数之和。\n\n### 参考代码\n\n\n```\n#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint f[2005][2005];\nvector<int>V[2005];\nvoid init()\n{\n    memset(f,0,sizeof(f));\n\n    for(int i=1; i<=2005; i++)V[i].clear();\n    for(int i=1; i<=2005; i++)\n    {\n        for(int j=1; j<=2005; j++)\n        {\n            if(j%i==0)\n            {\n                V[j].push_back(i);\n            }\n        }\n    }\n    for(int i=1; i<=2005; i++)f[i][1]=1;\n    for(int i=2; i<=2000; i++)\n    {\n        for(int j=1; j<=2000; j++)\n        {\n            for(int k=0; k<V[j].size(); k++)\n            {\n                f[j][i]=(f[j][i]%mod+f[V[j][k]][i-1]%mod)%mod;\n            }\n            f[j][i]%=mod;\n        }\n    }\n}\nint main()\n{\n    int t;\n    init();//直接一次性都算出\n    while(~scanf(\"%d\",&t))\n    {\n        while(t--)\n        {\n            int n,m;\n            scanf(\"%d%d\",&n,&m);\n            int sum=0;\n            for(int i=1; i<=n; i++)\n            {\n                sum=(sum+f[i][m])%mod;//将所有以不大于n的数结尾且长度为m的happy sequence个数加起来就是答案了\n            }\n            printf(\"%d\\n\",sum);\n        }\n    }\n\n}\n```\n\n参考自[网络](http://blog.csdn.net/zyy_1998/article/details/79511442/)\n\n","tags":["ZOJ"],"categories":["算法"]},{"title":"绑定域名","url":"/2018/03/31/绑定域名/","content":"\n1. 买一个域名并认证，如：xheartbeat.top\n\n   <!--more-->\n\n2. 解析域名：添加解析记录：\n\n   ​      A：@  192.30.252.154\n\n   ​      A :  @  192.30.252.153\n\n   ​     CNAME :  www   xxq1999.github.io\n\n3. hexo根目录source新建无后缀名的CNAME文件，并输入：\n\n   ​      xheartbeat.top（自己的域名）\n\n4. 然后hexo g，hexo d\n\n5. 打开github，在setting上的GitHub Pages：Custom domain：填入域名\n\n6. 结束。\n\n","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"HDU 1024 Max Sum Plus Plus(DP+最大M子段和)","url":"/2018/03/31/HDU-1024-Max-Sum-Plus-Plus(DP+最大M子段和)/","content":"\n## [Max Sum Plus Plus](http://acm.hdu.edu.cn/showproblem.php?pid=1024)\n\n### 题意\n\nn个数字，选m组，使得SUM最大。\n\n<!--more-->\n\n### 思路\n\ndp[i][j]=max(dp[i][j-1]+a[j],max(dp[i-1][k])+a[j]) (0<k<j)。\n\ndp[i][j-1]+a[j]表示的是前j-1分成i组，第j个必须放在前一组里面。\n\nmax( dp[i-1][k] ) + a[j] )表示的前（0<k<j）分成i-1组，第j个单独分成一组。\n\n但是题目的数据量比较大，时间复杂度为n^3，n<=1000000，显然会超时，继续优化。\n\nmax( dp[i-1][k] ) 就是上一组 0....j-1 的最大值。我们可以在每次计算dp[i][j]的时候记录下前j个\n的最大值 用数组保存下来 ，这样时间复杂度为 n^2。\n\n**(1)节省时间**\n\n由基本思路，我们可以知道，dp[i][j]=max(dp[i][j-1]+num[j],dp(i-1,t)+num[j])，其中i-1<=t<=j-1.我们只要找到dp[i][j-1] 和dp[i-1][t]的最大值加上num[j]即为dp[i][j].所以，定义一个数组pre_max[n]，用pre_max[j-1]来表示求解dp[i][j]时dp[i-1][t]的最大值,则dp[i][j]=max(pre_max[j-1],dp[i][j-1])+num[j]。特别注意，pre_max[n]这个位置的存储空间是始终用不到的，因此可以用来存储其他数值，在接下来会用到。在求解dp[i][j]的同时，我们可以计算出dp[i][t];i<=t<=j的最大值，这个最大值在计算dp[i+1][j+1]的时候需要作为pre_max[j]的形式被使用，我们先把它存在pre_max[n]中。\n你可能会问：为什么不把它直接放在pre_max[j]中呢？因为你接下来需要计算dp[i][j+1]的值，需要用到pre_max[j]中原来的值，如果你把它存在这里，就会覆盖掉计算dp[i][j+1]所需要的那个值。所以，先把它放在pre_max[n]中。当我们计算完dp[i][j+1]之后，就会发现pre_max[j]中的值已经没有用处了，我们可以把它更新为计算dp[i+1][j+1]所需要的那个值，  即之前放在pre_max[n]中的那个值，即执行pre_max[j]=pre_max[n]。这样我们就节省了计算最大值时付出的时间代价。\n\n **(2)节省空间**\n\n通过时间的节省，我们突然间发现程序执行结束后pre_max[n]的值即为最后的结果，pre_max[n]数组才是我们希望求解的，dp[m][n]这个庞大的数组已经不是那么重要了，因此，我们现在用整型数tmp来代替dp[m][n]，用来临时存储dp[i][j]的值，作为求解pre_max[n]的中介。这样就节省了dp[i][j]占用的极大的空间。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\nint dp[1000010],MAX[1000010],a[1000010];\nint main()\n{\n    int n,m;\n    int maxx;\n    while (~scanf(\"%d%d\",&m,&n))\n    {\n        memset(dp,0,sizeof(dp));\n        memset(MAX,0,sizeof(MAX));\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&a[i]);\n        for(int i=1;i<=m;i++)\n        {\n            maxx=-INF;\n            for(int j=i;j<=n;j++)\n            {\n                dp[j]=max(dp[j-1]+a[j],MAX[j-1]+a[j]);\n                MAX[j-1]=maxx;\n                maxx=max(maxx,dp[j]);\n            }\n        }\n        printf(\"%d\\n\",maxx);\n    }\n    return 0;\n}\n```\n\n[][][][]\n\n","tags":["HDU"],"categories":["算法"]},{"title":"HDU 1069 Monkey and Banana (简单dp)","url":"/2018/03/31/HDU-1069-Monkey-and-Banana-(简单dp)/","content":"\n## [Monkey and Banana](http://acm.hdu.edu.cn/showproblem.php?pid=1069)\n\n### 题意\n\n有一些方块，三维属性x，y，z，每一块方块都有无限个，求这些方块堆起来能达到的最高海拔？\n\n（下面的方块的x，y必须严格大于上面的x，y（对应））\n\n<!--more-->\n\n<br\\>\n\n### 思路\n\n简单dp，由于方块有无限个，就让一个方块一次存6种可能的摆放方式，dp表示这个方块加上它下面的方块能达到的最大高度。\n\n我按照x，y，z的降序排序，两重for循环中，因排序的不同而写的略微有差别，我的意思是a[i]在下，a[j]在上面的话，即满足a[i].x>a[j].x&&a[i].y>a[j].y , a[j].dp = max(a[j].dp, a[i].dp+a[j].z) ，就是说dp的是小方块。没错。嗯。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct node{\n    int x,y,z;\n    int high;\n};\nbool cmp(node a,node b)\n{\n    if(a.x==b.x)\n    {\n        if(a.y==b.y)\n            return a.z>b.z;\n        return a.y>b.y;\n    }\n    return a.x>b.x;\n}\nint main()\n{\n    int n,cas=1;\n    int x,y,z;\n    while(~scanf(\"%d\",&n)&&n)\n    {\n        node a[10010];\n        int index=0;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&x,&y,&z);\n            a[index].x=x;a[index].y=y;a[index].z=a[index].high=z;index++;\n            a[index].x=x;a[index].y=z;a[index].z=a[index].high=y;index++;\n            a[index].x=y;a[index].y=x;a[index].z=a[index].high=z;index++;\n            a[index].x=y;a[index].y=z;a[index].z=a[index].high=x;index++;\n            a[index].x=z;a[index].y=y;a[index].z=a[index].high=x;index++;\n            a[index].x=z;a[index].y=x;a[index].z=a[index].high=y;index++;\n        }\n        sort(a,a+index,cmp);\n        for(int i=0;i<index;i++)\n            for(int j=i+1;j<index;j++)\n                if(a[i].x>a[j].x&&a[i].y>a[j].y)\n                    a[j].high=max(a[j].high,a[i].high+a[j].z);\n        int ans=-1;\n        for(int i=0;i<index;i++)\n            ans=max(ans,a[i].high);\n        printf(\"Case %d: maximum height = %d\\n\",cas++,ans);\n    }\n    return 0;\n}\n\n```\n\n","tags":["HDU"],"categories":["算法"]},{"title":"CSS 属性","url":"/2018/03/31/CSS-属性/","content":"\n[W3Cschool CSS](http://www.w3school.com.cn/css/css_jianjie.asp)\n\n<!--more-->\n\ntips:\n\n~~<span> <p> </p> </span>~~ \n\n<p><span></span></p>\n\n#####类选择器\n\n .center /*类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。*/\n\n```\n.fancy td {\n\tcolor: #f60;\n\tbackground: #666;\n\t}\n在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）\ntd.fancy {\n\tcolor: #f60;\n\tbackground: #666;\n\t}\n<td class=\"fancy\">\n```\n\n##### id选择器 \n\nsidebar\n\n##### 派生选择器\n\n##### 属性选择器\n\n##### front-style: \n\n字体\n\n##### text-align:\n\n  规定元素中的文本的水平对齐方式 center，right，left\n\n##### margin-top:\n\n 元素的上外边距 (单位多样)\n\n##### font-weight:\n\n 文本粗细 （支持数字）\n\n##### font-size:\n\n 设置不同的 HTML 元素的尺寸\n\n##### line-height: \n\n行距（行高）\n\n#####border: \n\n1px dotted #000 （边框 dotted solid）\n\n##### padding: \n\n10px （文字距离边框的内边距）\n\n##### display : \n\n| 值                  | 描述                                       |\n| ------------------ | ---------------------------------------- |\n| none               | 此元素不会被显示。                                |\n| block              | 此元素将显示为块级元素，此元素前后会带有换行符。                 |\n| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。               |\n| inline-block       | 行内块元素。（CSS2.1 新增的值）                      |\n| list-item          | 此元素会作为列表显示。                              |\n| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。                  |\n| compact            | CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |\n| marker             | CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 |\n| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。     |\n| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。     |\n| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。          |\n| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。          |\n| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。          |\n| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                  |\n| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。       |\n| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                 |\n| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |\n| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）             |\n| inherit            | 规定应该从父元素继承 display 属性的值。                 |\n\n#### CSS背景 background \n\n```\nbody\n{ \nbackground: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center; \n} //所有背景属性在一个声明之中\n```\n\n##### background-color\n\n可以为所有元素设置背景色，这包括 body 一直到 em 和 a 等行内元素。\n\nbackground-color 不能继承，其默认值是 transparent。transparent 有“透明”之意。也就是说，如果一个元素没有指定背景色，那么背景就是透明的，这样其祖先元素的背景才能可见。\n\n##### background-image\n\nbackground-image 属性的默认值是 none，表示背景上没有放置任何图像。\n\n```\nbody {background-image: url(/i/eg_bg_04.gif);}\n```\n\n大多数背景都应用到 body 元素，不过并不仅限于此。\n\n下面例子为一个段落应用了一个背景，而不会对文档的其他部分应用背景：\n\n```\np.flower {background-image: url(/i/eg_bg_03.gif);}\n```\n\n您甚至可以为行内元素设置背景图像，下面的例子为一个链接设置了背景图像：\n\n```\na.radio {background-image: url(/i/eg_bg_07.gif);}\n```\n\n##### background-repeat\n\n属性值 repeat 导致图像在水平垂直方向上都平铺，就像以往背景图像的通常做法一样。repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。\n\n默认地，背景图像将从一个元素的左上角开始。\n\n ##### background-position\n\n背景图的位置。首先，可以使用一些关键字：top、bottom、left、right 和 center。通常，这些关键字会成对出现，不过也不总是这样。还可以使用长度值，如 100px 或 5cm，最后也可以使用百分数值。不同类型的值对于背景图像的放置稍有差异。\n\n**关键字**\n\n图像放置关键字最容易理解，其作用如其名称所表明的。例如，top right 使图像放置在元素内边距区的右上角。\n\n根据规范，位置关键字可以按任何顺序出现，只要保证不超过两个关键字 - 一个对应水平方向，另一个对应垂直方向。\n\n如果只出现一个关键字，则认为另一个关键字是 center。\n\n所以，如果希望每个段落的中部上方出现一个图像，只需声明如下：\n\n```\np\n  { \n    background-image:url('bgimg.gif');\n    background-repeat:no-repeat;\n    background-position:top;\n  }\n\n```\n\n下面是等价的位置关键字：\n\n| 单一关键字  | 等价的关键字                        |\n| ------ | ----------------------------- |\n| center | center center                 |\n| top    | top center 或 center top       |\n| bottom | bottom center 或 center bottom |\n| right  | right center 或 center right   |\n| left   | left center 或 center left     |\n\n**百分数值**\n\n百分数值的表现方式更为复杂。假设你希望用百分数值将图像在其元素中居中，这很容易：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:50% 50%;\n  }\n\n```\n\n这会导致图像适当放置，其中心与其元素的中心对齐。**换句话说，百分数值同时应用于元素和图像。**也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。\n\n如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。\n\n因此，如果你想把一个图像放在水平方向 2/3、垂直方向 1/3 处，可以这样声明：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:66% 33%;\n  }\n\n```\n\n如果只提供一个百分数值，所提供的这个值将用作水平值，垂直值将假设为 50%。这一点与关键字类似。\n\nbackground-position 的默认值是 0% 0%，在功能上相当于 top left。这就解释了背景图像为什么总是从元素内边距区的左上角开始平铺，除非您设置了不同的位置值。\n\n**长度值**\n\n长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。\n\n比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上：\n\n```\nbody\n  { \n    background-image:url('/i/eg_bg_03.gif');\n    background-repeat:no-repeat;\n    background-position:50px 100px;\n  }\n\n```\n\n注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。\n\n#####background-attachment 背景关联\n\n如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。\n\n您可以通过 background-attachment 属性防止这种滚动。通过这个属性，可以声明图像相对于可视区是固定的（fixed），因此不会受到滚动的影响：\n\n```\nbody \n  {\n  background-image:url(/i/eg_bg_02.gif);\n  background-repeat:no-repeat;\n  background-attachment:fixed\n  }\n\n```\n\nbackground-attachment 属性的默认值是 scroll，也就是说，在默认的情况下，背景会随文档滚动。\n\n#### CSS 文本\n\n","tags":["CSS"],"categories":["前端"]},{"title":"Everything","url":"/2018/03/31/Everything/","content":"\n**The void, is like a space.**\n\n**Now space contains everything,**\n\n**the mountains, the oceans, the stars,  the good  people and the bad people,**\n\n**the plants, the animals, everything.**\n\n**Now the mind in us, the true mind is like that.**\n\n**You will find that when bullists use the word \"mind\",** \n\n**they've several words for \"mind\",**\n\n**But I'm not going into the technicality at the monment.**\n\n**They mean space.**\n\n**See,  SPACE IS YOUR MIND.**\n\n\n\n","tags":["English"],"categories":["English Matters"]},{"title":"839C Journey (简单dfs)","url":"/2018/03/31/839C-Journey-(简单dfs)/","content":"\n## [Journey](http://codeforces.com/problemset/problem/839/C)\n\n### 题意\n\nSeven Kingdoms 上有n个城市，他们之间由n-1条路连接，每个城市之间都无向连通，从第一个城市出发，每条路长度为1，若一个城市有x条岔路通向其他城市，那么这些城市的概率相同，均为1/x，走过的城市不会再走，那么一直走到走不了为止，求期望的路径长度？\n\n<!--more-->\n\n### 思路\n\n一看就是简单搜索，搜遍每条路，（zz的人永远不好好看题目，不是简单的路径/路的数量啊！），这里用结构体+vector来存图，结构体中加一个变量fencha来表示路径的分叉点，跑一下就好了。\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct node{\n    vector<int>next;\n    double fencha;\n};\nint n;\ndouble all=0,way=0;\nint viss[100010];\nnode city[100010];\nvoid solve(int cur,int step,int vis[])\n{\n    int len=city[cur].next.size();\n    int flag=0;\n    for(int i=0;i<len;i++)\n        if(!vis[city[cur].next[i]])\n            flag++;\n    for(int i=0;i<len;i++)\n    {\n        if(!vis[city[cur].next[i]])\n        {\n            vis[city[cur].next[i]]=true;\n            city[city[cur].next[i]].fencha=city[cur].fencha*flag;\n            solve(city[cur].next[i],step+1,vis);\n            vis[city[cur].next[i]]=false;\n        }\n    }\n    if(flag==0||len==0)\n        all+=(1.0/city[cur].fencha)*step;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    int a,b;\n    if(n==1)\n    {\n        printf(\"0.000000000000000\\n\");\n        return 0;\n    }\n    for(int i=0;i<n-1;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        city[a].next.push_back(b);\n        city[b].next.push_back(a);\n        viss[a]=viss[b]=false;\n        city[a].fencha=city[b].fencha=1;\n    }\n    viss[1]=true;\n    solve(1,0,viss);\n    printf(\"%.15f\\n\",all);\n    return 0;\n}\n```\n\n","tags":["dfs"],"categories":["算法"]},{"title":"934C A Twisty Movement(前缀和+思维)","url":"/2018/03/31/934C-A-Twisty-Movement(前缀和+思维)/","content":"\n## [A Twisty Movement](http://codeforces.com/problemset/problem/934/C)\n\n### 题意\n\n给出n个数字，由1、2组成，你可以选择一个区间[L,R]，将其逆转，使得集合中的***非递减子序列***最长。\n\n（不是子串。。。）\n\n<!--more-->\n\n### 思路\n\n“ 由于序列只由1和2组成，显然我们需要找到最长非递减子序列中第一个2出现的位置pos，那么逆序后[l,pos]会使后面2个数目增加，[pos,r]会使前面1个数目增加。\n\n于是我们先处理出“1”的前缀个数和与“2”的后缀个数和，然后我们每次枚举前面提到的位置pos，然后再依次枚举区间的l和r。\n\n然后分别滑动L，R的值，计算其对最长不降子序列贡献的最大值。\n\n对于l,计算[1,L-1]中1的个数和[l,pos]中2的个数和的最大值。\n\n对于2,计算[R,n]中2的个数和[pos,r-1]中1的个数和的最大值。” （网络）\n\n### 看！代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n,ans=0;\n    scanf(\"%d\",&n);\n    vector<int>a(n+2);\n    vector<int>pre1(n+2);\n    vector<int>pre2(n+2);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        pre1[i]=pre1[i-1]+(a[i]==1);\n    }\n    for(int i=n;i>=1;i--)\n        pre2[i]=pre2[i+1]+(a[i]==2);\n    for(int k=1;k<=n+1;k++)\n    {\n        int t1=0,t2=0;\n        for(int i=1;i<=k;i++)\n            t1=max(t1,pre1[i-1]+pre2[i]-pre2[k]);\n        for(int i=k;i<=n+1;i++)\n            t2=max(t2,pre2[i]+pre1[i-1]-pre1[k-1]);\n        ans=max(ans,t1+t2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n```\n\n","tags":["前缀和"],"categories":["算法"]},{"title":"954C Marix Walk(思维)","url":"/2018/03/31/954C-Marix-Walk(思维)/","content":"\n## [Marix Walk](http://codeforces.com/problemset/problem/954/C)\n\n### 题意\n\n走一个n*m的方格，一次走一格，上下左右都能走，输出使得这个走动合理的n，m大小。\n\n<!--more-->\n\n### 思路\n\n我真的是信了邪，直接输出***n=100000000***不就好了，mdzz。\n\n至于m的部分么，我们先不急，先来讲讲那个NO的情况:\n\n1. 原地不动\n2. 上下走的时候，非法 ，如：1 2 3 5\n3. 左右走的时候，非法，如： 1 2 3 6 7\n\n那么m怎么搞呢，如果是一个合法的走动，那么上下走的话，怎么走他们的差值都是不变的，也就是要求的m。\n\n微笑 微笑 ：）\n\n### 看！代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\nconst int N = 3e5 + 10;\nint a[N];\n\nint main()\n{\n    int n;\n    int y=1;\n    scanf(\"%d\",&n);\n    for (int i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        if(i==0) continue;\n        if(a[i]==a[i-1])\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        if(abs(a[i]-a[i-1])!=1)\n            y=abs(a[i]-a[i-1]);\n    }\n    for (int i=1;i<n;i++)\n    {\n        if((abs(a[i]-a[i-1])!=1&&abs(a[i]-a[i-1])!=y))\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        if(a[i]%y==0&&a[i-1]-a[i]==1&&y!=1)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n        else if(a[i]%y==1&&a[i]-a[i-1]==1)\n        {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    printf(\"YES\\n1000000000 %d\\n\",y);\n    return 0;\n}\n```\n\n","tags":["思维"],"categories":["算法"]},{"title":"无题，仅记","url":"/2018/03/30/无题，仅记/","content":"\n其实自己的心里不知道是什么滋味，感觉很复杂，很奇怪。\n\n<!--more-->\n\n努力的想挣脱出来，跳出来。\n\n或许是太肤浅？\n\n用别的话说，见识的太少，\n\n没有看过这个世界……\n\n所以心始终狭隘，多的是芥蒂，即使是现在，\n\n还是心照不宣，脑袋里的想法和内心的，好像差了很多。\n\n我想要变得理性，\n\n不要把自己捆绑在一个人的身上，\n\n独立的个体……\n\n开朗……\n\n积极……\n\n充满自己的个性……\n\n自由自在的样子，\n\n很美。\n\n可既要这样，\n\n我又该如何是好？\n\n红肿的眼睛，\n\n隐隐作痛的太阳穴，\n\n厌弃这样的自己，\n\n有时候就像尘埃，\n\n很低……\n\n很低……\n\n要多学、多看、多闻、多思……\n\n你啊，\n\n笨死了啊……\n\n不要再悸动了，\n\n不要再那么感情用事了，\n\n没有好处的，\n\n已经……\n\n二十一了啊。\n\n年龄在增长，\n\n心智，也该慢慢成熟了。\n\n天很热，\n\n很热。\n\n很丧。\n\n\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"觅香","url":"/2018/03/28/不如你/","content":"\n<img src=\"https://xheartbeat.top/mdpicture/MX3.jpg\"  alt=\"遛狗时发现春天正盛\" />\n\n## 词\n\n**春风十里，五十里，一百里，体测八百米，海底两万里。**\n\n**德芙巧克力，香草味八喜，可可布朗尼。**\n\n**榴莲，菠萝蜜，芝士玉米粒，鸡汁土豆泥。**\n\n**黑椒牛里脊，黄焖辣子鸡，红烧排骨醋酱鱼。**\n\n**冰糖雪梨，梅菜扣肉饼，柠檬味雪碧，椒盐九吐鱼。**\n\n**白酒，青啤，安慕希，**\n\n**不如你，全都不如你。**\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **—— 《觅香》**\n\n<!--more-->\n\n<br/>\n\n## 叨叨\n\n歌词实在可爱，听得我都饿了呀！\n\n昨天，二十五度，完全没想到自己在这种温度之下还穿着加绒裤和加绒鞋垫！\n\n正好小可爱回来了，我果断牵着他买了冰淇淋QwQ，然后顺便在隔壁杨国福吃了麻辣烫嘿嘿嘿~（顺带吐槽一下某人的打扮，我远远的望去，见他身着白衬衫，很是好看，走进了一看，我他妈，你脖子上怎么还露出一截紫色呢？？啥玩意儿白衬衫里面穿了一件这么高的还是紫色的棉毛衫？？然后他一抬手……幻灭，绝对是幻灭，袖口上还露出五公分的深灰色毛衣？？我……我们不如分开走？？）\n\n晚上的选修课乌七麻黑看电影，带着小可爱潜入了教室，吃了两把鸡，想到这里，他要是还在上学，和我念一个学校一个专业多好呀~那我就可以每天每天每天打爆他的狗头！喵了个咪的，前天做梦梦到他居然牵着一个小姑娘的手还冲我挑眉得瑟？？气得我把新买的手机扔了出去屏幕都裂了他还不愿意赔？？哼，男人。\n\n从寝室下来的楼梯口闻到一个女生手上拎着的鸡排的香味，忽然感觉又饿了！可是我不是刚吃的麻辣烫吗？？（世界未解之谜：xxQ的胃）看着小可爱的脸，我非常认真的说了了一句：\n\n“ 我饿了，想吃关东煮w “\n\n真是作孽的一天，**虽然**我一早有想到家里的惨状，但是我也。。。没想到有这么惨。。。\n\n<img src=\"https://xheartbeat.top/mdpicture/18032801.jpg\" width=\"270\" height=\"360\" alt=\"ice-cream\" />&nbsp;<img src=\"https://xheartbeat.top/mdpicture/18032802.jpg\" width=\"270\" height=\"360\" alt=\"mess\" />\n\n但是！狗奴们应该都能体会我这种心情把！看到狗子热情四射的笑脸，看到她蹦蹦跳跳围着你开心的转，扑腾扑腾的，实在是太可爱了根本就不生气啊！！反而觉得她可爱极了！！好吧，你最萌，你最萌，让我来收拾这一切把！你出去玩吧！Orz\n\n哼！听话是听话的！臭臭和小便都没有乱拉乱撒，乖乖的在屎盆子上上厕所，我家狗子就是聪明嘻嘻嘻~\n\n带她出去溜的时候，她爱跑，我就看四下没有人，松开绳子让她肆意的奔跑，她知道我跑得慢，还跑两步，然后转回头来等我，看到我走的差不多了，再继续跑，啊啊啊啊我怎么能不爱你啊啊啊啊啊！太贴心了~ 一首《觅香》送给你！！德芙巧克力香草味八喜可可布朗尼！全都不如你！！\n\n<img src=\"https://xheartbeat.top/mdpicture/18032803.jpg\" width=\"360\" height=\"270\" alt=\"狗子上屋\" />\n\n<br/>\n\n<img src=\"https://xheartbeat.top/mdpicture/MX2.jpg\"  alt=\"吃外卖时开心的看着你的狗子\" />\n\n诶，意外的点题了，我真棒！（hhhh\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n<br/>\n\n哦对啦，附赠收获的什么叫的一把表情包，应该也没有人能看见吧，哈哈哈哈哈哈哈哈哈哈哈，上课的时候笑到不能自已！\n\n<img src=\"https://xheartbeat.top/mdpicture/18032805.jpg\" width=\"576\" height=\"360\" alt=\"smj表情包原图\" /><img src=\"https://xheartbeat.top/mdpicture/18032804.jpg\" width=\"355\" height=\"360\" alt=\"smj表情包\" />\n\n<br/>\n\n被发现就完了。（逃\n\n\n","tags":["歌词"],"categories":["Life & Story"]},{"title":"冥冥","url":"/2018/03/26/冥冥/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=300 height=86 src=\"//music.163.com/outchain/player?type=2&id=547281157&auto=0&height=66\"></iframe>\n\n## 词\n\n<br/>\n\n**“**\n\n**在冥冥中掌控命运的力量，到底是什么？**\n\n**高山变成深谷，沧海化为桑田。**\n\n**夏冬的枯荣，国家的兴衰。**\n\n**人的生死。**\n\n**真的是神秘莫测？**\n\n**十年可见春去秋来，百年可证生老病死，千年可叹王朝更替，万年可见斗转星移。**\n\n**凡人如果用一天的视野，去窥探百万年的天地，是否就如同井底之蛙？**\n\n**”**\n\n<!--more-->\n\n<br/>\n\n## 思\n\n<br/>\n\n**这番台词，真是让我想起了从前的故事。**\n\n**我也曾是个爱天马行空的家伙。**\n\n<br/>\n\n**我忘掉了很多的事情，却始终记得这个片段。**\n\n**这么多年过去了，那个认认真真回答我对宇宙的困惑的男孩，现在又过的怎么样呢？**\n\n<br/>\n\n<img src=\"https://xheartbeat.top/mdpicture/1803267.jpg\" width=\"240\" height=\"360\" alt=\"极光\" />\n\n<img src=\"https://xheartbeat.top/mdpicture/1803268.jpg\" width=\"270\" height=\"360\" alt=\"新月\" />\n\n<img src=\"https://xheartbeat.top/mdpicture/1803266.jpg\" width=\"288\" height=\"360\" alt=\"超级蓝血月\" />\n\n<br/>\n\n<br/>\n\n*【PHOTO FROM INTERNET】*","tags":["随想"],"categories":["天行九歌"]},{"title":"小心心送给你","url":"/2018/03/25/如何鼠标点击出爱心/","content":"\n\n\n**1、在/theme/sw/source/js/src 中创建一个js文件**（eg. ***love.js***，没有src文件夹就创建一个）\n**2、复制下列代码到*love.js*中：**\n\n<!--more-->\n<br/>\n\n```\n    !function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);\n```\n\n代码块似乎显示不全，[这里](http://7u2ss1.com1.z0.glb.clouddn.com/love.js)是源代码\n\n**3、在/theme/sw/layout/layout.ejs 的<u>最后面</u>添加下列代码：**\n```\n<!-- 页面点击小红心 -->\n<script type=\"text/javascript\" src=\"/js/src/love.js\"></script>\n```\n**4、结束~**\n\n<br/><br/>\n参考自网路","tags":["网站优化"],"categories":["Web Dairy"]},{"title":"今天份的快乐","url":"/2018/03/20/今天份的快乐/","content":"\n<!-- more -->\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**觉得SOUL是一个不错的APP。**\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**随性，也很清爽。**\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**昨天晚上日常丧病，随手发了一条瞬间：**\n<br/>\n![image](https://xheartbeat.top/mdpicture/1803121.jpg)\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**只是没有想到会有人这样回复，感觉很温暖**\n<br/>\n![image](https://xheartbeat.top/mdpicture/1803122.jpg)\n<br/>\n![image](http://qgsuuzgw0.hn-bkt.clouddn.com/1803123.jpg)\n<br/>\n![image](http://qgsuuzgw0.hn-bkt.clouddn.com/1803124.jpg)\n<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**感谢来自陌生人的，算是小小的关心吧。♥**\n\n","tags":["随想"],"categories":["Life & Story"]},{"title":"后青春期的诗","url":"/2018/03/09/后青春期的诗/","content":"\n18/03/09\n>  **“ 盛夏正要一天一天一天的灿烂“ ** \n\n<!-- more -->\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;不知不觉，已经是大二，即将大三了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;愧疚的是，定下的目标、曾经的方向，都没有实现。\n\n&nbsp;&nbsp;&nbsp;&nbsp;周围的人一点一点学习，一点一点进步。\n\n&nbsp;&nbsp;&nbsp;&nbsp;上课的时候，听老师讲那些往届的学长学姐的故事，成就非凡，事业前途也一片光明；下课了之后，看网路上大神们讲述着自己成功的经历，感叹着某某某真是厉害呀，某某某太叼啦，又会为自己的未来担忧。\n\n&nbsp;&nbsp;&nbsp;&nbsp;不爱刷题，对算法提不起兴趣，在ACM的道路上慢慢被赶超，然后只能划划水。\n\n&nbsp;&nbsp;&nbsp;&nbsp;我希望总要有一样东西，是我现在能够做的，做到底的，于是借由这个个人网站，督促自己。\n\n<br/>\n<br/>\nP.S.感谢大佬的模板 ❤","tags":["随想"],"categories":["Life & Story"]},{"title":"写给你","url":"/1997/11/07/写给你/","content":"\n\n\n华梁：\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之所以想要送你礼物，是觉得感情中也需要浪漫和惊喜，以维持那份新鲜和热情……而节日不过是一个正好的借口罢了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你向来志气远大，自在洒脱，和我不同。两个人开始拥有各自的生活之后，也在慢慢改变。依赖你成了瘾的我，总是想同你分享一些什么，只是一来学习枯燥乏味，每天的笑容都是由代码承包，二来你工作辛苦繁忙，不愿太多打扰。我想了很久的礼物，思来想去决定不了。只是常常浮现出你某一日身着西服，站在寝室楼下，乖巧等我的模样。想到以后的你，一定会更加成熟、稳重，更加深刻，成为一位真正的男士，你的事业如日中天，甚至如你所愿赚的盆满钵满。不知道那时候的我又在哪儿呢？（笑）希望别失了如今的这份浪漫的心情吧。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想到这一切，我买下了这对袖扣，只可惜囊中羞涩，无法给你更好的。它们是我的私欲，是送给未来的你的礼物。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好啦好啦，你也不要说我，现在都用不到，花这钱做什么。也许你连一件能用上这袖扣的衬衫都没有。但是会有的嘛，对吧？衬衫，幸福，很多很多，都会有的。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的老父亲曾经给他老婆写了一张贺卡，现在我也来酸溜溜的模仿：\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“ 华梁，愿这份礼物能为你带来久违的温暖与期盼。”\n\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;爱你的，晓青\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n\n<img src=\"https://xheartbeat.top/mdpicture/m.xxqrhl.icoc.me.png\" height=\"200\" width=\"200\" alt=\"曾经傻傻的我，曾经什么都不会的我，千千万万个我，都一样爱你\">","tags":["随想"],"categories":["Life & Story"]}]